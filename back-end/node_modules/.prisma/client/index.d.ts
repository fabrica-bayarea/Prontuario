
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model BoardMember
 * 
 */
export type BoardMember = $Result.DefaultSelection<Prisma.$BoardMemberPayload>
/**
 * Model List
 * 
 */
export type List = $Result.DefaultSelection<Prisma.$ListPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model TaskLabel
 * 
 */
export type TaskLabel = $Result.DefaultSelection<Prisma.$TaskLabelPayload>
/**
 * Model Dashboard
 * 
 */
export type Dashboard = $Result.DefaultSelection<Prisma.$DashboardPayload>
/**
 * Model Pendencia
 * 
 */
export type Pendencia = $Result.DefaultSelection<Prisma.$PendenciaPayload>
/**
 * Model Notificacao
 * 
 */
export type Notificacao = $Result.DefaultSelection<Prisma.$NotificacaoPayload>
/**
 * Model GraficoCurso
 * 
 */
export type GraficoCurso = $Result.DefaultSelection<Prisma.$GraficoCursoPayload>
/**
 * Model GraficoBeneficiario
 * 
 */
export type GraficoBeneficiario = $Result.DefaultSelection<Prisma.$GraficoBeneficiarioPayload>
/**
 * Model Curso
 * 
 */
export type Curso = $Result.DefaultSelection<Prisma.$CursoPayload>
/**
 * Model coordenador
 * 
 */
export type coordenador = $Result.DefaultSelection<Prisma.$coordenadorPayload>
/**
 * Model Agendamento
 * 
 */
export type Agendamento = $Result.DefaultSelection<Prisma.$AgendamentoPayload>
/**
 * Model ProgramaAgendamento
 * 
 */
export type ProgramaAgendamento = $Result.DefaultSelection<Prisma.$ProgramaAgendamentoPayload>
/**
 * Model TipoAtendimentoAgendamento
 * 
 */
export type TipoAtendimentoAgendamento = $Result.DefaultSelection<Prisma.$TipoAtendimentoAgendamentoPayload>
/**
 * Model Aluno
 * 
 */
export type Aluno = $Result.DefaultSelection<Prisma.$AlunoPayload>
/**
 * Model TipoAtendimento
 * 
 */
export type TipoAtendimento = $Result.DefaultSelection<Prisma.$TipoAtendimentoPayload>
/**
 * Model Programa
 * 
 */
export type Programa = $Result.DefaultSelection<Prisma.$ProgramaPayload>
/**
 * Model Escala
 * 
 */
export type Escala = $Result.DefaultSelection<Prisma.$EscalaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  local: 'local',
  google: 'google',
  microsoft: 'microsoft'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const Role: {
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  OBSERVER: 'OBSERVER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Visibilidade: {
  ALUNO_E_BENEFICIARIO: 'ALUNO_E_BENEFICIARIO',
  SOMENTE_ALUNO: 'SOMENTE_ALUNO',
  SOMENTE_COORDENADOR: 'SOMENTE_COORDENADOR'
};

export type Visibilidade = (typeof Visibilidade)[keyof typeof Visibilidade]


export const BoardVisibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  TEAM: 'TEAM'
};

export type BoardVisibility = (typeof BoardVisibility)[keyof typeof BoardVisibility]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Visibilidade = $Enums.Visibilidade

export const Visibilidade: typeof $Enums.Visibilidade

export type BoardVisibility = $Enums.BoardVisibility

export const BoardVisibility: typeof $Enums.BoardVisibility

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boardMember`: Exposes CRUD operations for the **BoardMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardMembers
    * const boardMembers = await prisma.boardMember.findMany()
    * ```
    */
  get boardMember(): Prisma.BoardMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.list`: Exposes CRUD operations for the **List** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.list.findMany()
    * ```
    */
  get list(): Prisma.ListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskLabel`: Exposes CRUD operations for the **TaskLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLabels
    * const taskLabels = await prisma.taskLabel.findMany()
    * ```
    */
  get taskLabel(): Prisma.TaskLabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboard`: Exposes CRUD operations for the **Dashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboards
    * const dashboards = await prisma.dashboard.findMany()
    * ```
    */
  get dashboard(): Prisma.DashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendencia`: Exposes CRUD operations for the **Pendencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pendencias
    * const pendencias = await prisma.pendencia.findMany()
    * ```
    */
  get pendencia(): Prisma.PendenciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacao`: Exposes CRUD operations for the **Notificacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacaos
    * const notificacaos = await prisma.notificacao.findMany()
    * ```
    */
  get notificacao(): Prisma.NotificacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.graficoCurso`: Exposes CRUD operations for the **GraficoCurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GraficoCursos
    * const graficoCursos = await prisma.graficoCurso.findMany()
    * ```
    */
  get graficoCurso(): Prisma.GraficoCursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.graficoBeneficiario`: Exposes CRUD operations for the **GraficoBeneficiario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GraficoBeneficiarios
    * const graficoBeneficiarios = await prisma.graficoBeneficiario.findMany()
    * ```
    */
  get graficoBeneficiario(): Prisma.GraficoBeneficiarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.curso.findMany()
    * ```
    */
  get curso(): Prisma.CursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coordenador`: Exposes CRUD operations for the **coordenador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coordenadors
    * const coordenadors = await prisma.coordenador.findMany()
    * ```
    */
  get coordenador(): Prisma.coordenadorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendamento`: Exposes CRUD operations for the **Agendamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendamentos
    * const agendamentos = await prisma.agendamento.findMany()
    * ```
    */
  get agendamento(): Prisma.AgendamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programaAgendamento`: Exposes CRUD operations for the **ProgramaAgendamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramaAgendamentos
    * const programaAgendamentos = await prisma.programaAgendamento.findMany()
    * ```
    */
  get programaAgendamento(): Prisma.ProgramaAgendamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoAtendimentoAgendamento`: Exposes CRUD operations for the **TipoAtendimentoAgendamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoAtendimentoAgendamentos
    * const tipoAtendimentoAgendamentos = await prisma.tipoAtendimentoAgendamento.findMany()
    * ```
    */
  get tipoAtendimentoAgendamento(): Prisma.TipoAtendimentoAgendamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aluno`: Exposes CRUD operations for the **Aluno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alunos
    * const alunos = await prisma.aluno.findMany()
    * ```
    */
  get aluno(): Prisma.AlunoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoAtendimento`: Exposes CRUD operations for the **TipoAtendimento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoAtendimentos
    * const tipoAtendimentos = await prisma.tipoAtendimento.findMany()
    * ```
    */
  get tipoAtendimento(): Prisma.TipoAtendimentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programa`: Exposes CRUD operations for the **Programa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programas
    * const programas = await prisma.programa.findMany()
    * ```
    */
  get programa(): Prisma.ProgramaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escala`: Exposes CRUD operations for the **Escala** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escalas
    * const escalas = await prisma.escala.findMany()
    * ```
    */
  get escala(): Prisma.EscalaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Board: 'Board',
    BoardMember: 'BoardMember',
    List: 'List',
    Task: 'Task',
    Label: 'Label',
    TaskLabel: 'TaskLabel',
    Dashboard: 'Dashboard',
    Pendencia: 'Pendencia',
    Notificacao: 'Notificacao',
    GraficoCurso: 'GraficoCurso',
    GraficoBeneficiario: 'GraficoBeneficiario',
    Curso: 'Curso',
    coordenador: 'coordenador',
    Agendamento: 'Agendamento',
    ProgramaAgendamento: 'ProgramaAgendamento',
    TipoAtendimentoAgendamento: 'TipoAtendimentoAgendamento',
    Aluno: 'Aluno',
    TipoAtendimento: 'TipoAtendimento',
    Programa: 'Programa',
    Escala: 'Escala'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "board" | "boardMember" | "list" | "task" | "label" | "taskLabel" | "dashboard" | "pendencia" | "notificacao" | "graficoCurso" | "graficoBeneficiario" | "curso" | "coordenador" | "agendamento" | "programaAgendamento" | "tipoAtendimentoAgendamento" | "aluno" | "tipoAtendimento" | "programa" | "escala"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      BoardMember: {
        payload: Prisma.$BoardMemberPayload<ExtArgs>
        fields: Prisma.BoardMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          findFirst: {
            args: Prisma.BoardMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          findMany: {
            args: Prisma.BoardMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>[]
          }
          create: {
            args: Prisma.BoardMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          createMany: {
            args: Prisma.BoardMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>[]
          }
          delete: {
            args: Prisma.BoardMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          update: {
            args: Prisma.BoardMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          deleteMany: {
            args: Prisma.BoardMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>[]
          }
          upsert: {
            args: Prisma.BoardMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardMemberPayload>
          }
          aggregate: {
            args: Prisma.BoardMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoardMember>
          }
          groupBy: {
            args: Prisma.BoardMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardMemberCountArgs<ExtArgs>
            result: $Utils.Optional<BoardMemberCountAggregateOutputType> | number
          }
        }
      }
      List: {
        payload: Prisma.$ListPayload<ExtArgs>
        fields: Prisma.ListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findFirst: {
            args: Prisma.ListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findMany: {
            args: Prisma.ListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          create: {
            args: Prisma.ListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          createMany: {
            args: Prisma.ListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          delete: {
            args: Prisma.ListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          update: {
            args: Prisma.ListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          deleteMany: {
            args: Prisma.ListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          upsert: {
            args: Prisma.ListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          aggregate: {
            args: Prisma.ListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateList>
          }
          groupBy: {
            args: Prisma.ListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListCountArgs<ExtArgs>
            result: $Utils.Optional<ListCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      TaskLabel: {
        payload: Prisma.$TaskLabelPayload<ExtArgs>
        fields: Prisma.TaskLabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findFirst: {
            args: Prisma.TaskLabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findMany: {
            args: Prisma.TaskLabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          create: {
            args: Prisma.TaskLabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          createMany: {
            args: Prisma.TaskLabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskLabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          delete: {
            args: Prisma.TaskLabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          update: {
            args: Prisma.TaskLabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          deleteMany: {
            args: Prisma.TaskLabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskLabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          upsert: {
            args: Prisma.TaskLabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          aggregate: {
            args: Prisma.TaskLabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLabel>
          }
          groupBy: {
            args: Prisma.TaskLabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLabelCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelCountAggregateOutputType> | number
          }
        }
      }
      Dashboard: {
        payload: Prisma.$DashboardPayload<ExtArgs>
        fields: Prisma.DashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findFirst: {
            args: Prisma.DashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findMany: {
            args: Prisma.DashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          create: {
            args: Prisma.DashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          createMany: {
            args: Prisma.DashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          delete: {
            args: Prisma.DashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          update: {
            args: Prisma.DashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          deleteMany: {
            args: Prisma.DashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          upsert: {
            args: Prisma.DashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          aggregate: {
            args: Prisma.DashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboard>
          }
          groupBy: {
            args: Prisma.DashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardCountAggregateOutputType> | number
          }
        }
      }
      Pendencia: {
        payload: Prisma.$PendenciaPayload<ExtArgs>
        fields: Prisma.PendenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          findFirst: {
            args: Prisma.PendenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          findMany: {
            args: Prisma.PendenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>[]
          }
          create: {
            args: Prisma.PendenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          createMany: {
            args: Prisma.PendenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>[]
          }
          delete: {
            args: Prisma.PendenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          update: {
            args: Prisma.PendenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          deleteMany: {
            args: Prisma.PendenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendenciaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>[]
          }
          upsert: {
            args: Prisma.PendenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendenciaPayload>
          }
          aggregate: {
            args: Prisma.PendenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendencia>
          }
          groupBy: {
            args: Prisma.PendenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendenciaCountArgs<ExtArgs>
            result: $Utils.Optional<PendenciaCountAggregateOutputType> | number
          }
        }
      }
      Notificacao: {
        payload: Prisma.$NotificacaoPayload<ExtArgs>
        fields: Prisma.NotificacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          findFirst: {
            args: Prisma.NotificacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          findMany: {
            args: Prisma.NotificacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>[]
          }
          create: {
            args: Prisma.NotificacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          createMany: {
            args: Prisma.NotificacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>[]
          }
          delete: {
            args: Prisma.NotificacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          update: {
            args: Prisma.NotificacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          deleteMany: {
            args: Prisma.NotificacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificacaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>[]
          }
          upsert: {
            args: Prisma.NotificacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacaoPayload>
          }
          aggregate: {
            args: Prisma.NotificacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacao>
          }
          groupBy: {
            args: Prisma.NotificacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacaoCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacaoCountAggregateOutputType> | number
          }
        }
      }
      GraficoCurso: {
        payload: Prisma.$GraficoCursoPayload<ExtArgs>
        fields: Prisma.GraficoCursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GraficoCursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GraficoCursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          findFirst: {
            args: Prisma.GraficoCursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GraficoCursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          findMany: {
            args: Prisma.GraficoCursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>[]
          }
          create: {
            args: Prisma.GraficoCursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          createMany: {
            args: Prisma.GraficoCursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GraficoCursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>[]
          }
          delete: {
            args: Prisma.GraficoCursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          update: {
            args: Prisma.GraficoCursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          deleteMany: {
            args: Prisma.GraficoCursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GraficoCursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GraficoCursoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>[]
          }
          upsert: {
            args: Prisma.GraficoCursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoCursoPayload>
          }
          aggregate: {
            args: Prisma.GraficoCursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGraficoCurso>
          }
          groupBy: {
            args: Prisma.GraficoCursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GraficoCursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GraficoCursoCountArgs<ExtArgs>
            result: $Utils.Optional<GraficoCursoCountAggregateOutputType> | number
          }
        }
      }
      GraficoBeneficiario: {
        payload: Prisma.$GraficoBeneficiarioPayload<ExtArgs>
        fields: Prisma.GraficoBeneficiarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GraficoBeneficiarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GraficoBeneficiarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          findFirst: {
            args: Prisma.GraficoBeneficiarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GraficoBeneficiarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          findMany: {
            args: Prisma.GraficoBeneficiarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>[]
          }
          create: {
            args: Prisma.GraficoBeneficiarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          createMany: {
            args: Prisma.GraficoBeneficiarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GraficoBeneficiarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>[]
          }
          delete: {
            args: Prisma.GraficoBeneficiarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          update: {
            args: Prisma.GraficoBeneficiarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          deleteMany: {
            args: Prisma.GraficoBeneficiarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GraficoBeneficiarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GraficoBeneficiarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>[]
          }
          upsert: {
            args: Prisma.GraficoBeneficiarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GraficoBeneficiarioPayload>
          }
          aggregate: {
            args: Prisma.GraficoBeneficiarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGraficoBeneficiario>
          }
          groupBy: {
            args: Prisma.GraficoBeneficiarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<GraficoBeneficiarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.GraficoBeneficiarioCountArgs<ExtArgs>
            result: $Utils.Optional<GraficoBeneficiarioCountAggregateOutputType> | number
          }
        }
      }
      Curso: {
        payload: Prisma.$CursoPayload<ExtArgs>
        fields: Prisma.CursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findFirst: {
            args: Prisma.CursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findMany: {
            args: Prisma.CursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          create: {
            args: Prisma.CursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          createMany: {
            args: Prisma.CursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          delete: {
            args: Prisma.CursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          update: {
            args: Prisma.CursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          deleteMany: {
            args: Prisma.CursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CursoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          upsert: {
            args: Prisma.CursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          aggregate: {
            args: Prisma.CursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurso>
          }
          groupBy: {
            args: Prisma.CursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CursoCountArgs<ExtArgs>
            result: $Utils.Optional<CursoCountAggregateOutputType> | number
          }
        }
      }
      coordenador: {
        payload: Prisma.$coordenadorPayload<ExtArgs>
        fields: Prisma.coordenadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coordenadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coordenadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          findFirst: {
            args: Prisma.coordenadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coordenadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          findMany: {
            args: Prisma.coordenadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>[]
          }
          create: {
            args: Prisma.coordenadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          createMany: {
            args: Prisma.coordenadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.coordenadorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>[]
          }
          delete: {
            args: Prisma.coordenadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          update: {
            args: Prisma.coordenadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          deleteMany: {
            args: Prisma.coordenadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coordenadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.coordenadorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>[]
          }
          upsert: {
            args: Prisma.coordenadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coordenadorPayload>
          }
          aggregate: {
            args: Prisma.CoordenadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoordenador>
          }
          groupBy: {
            args: Prisma.coordenadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoordenadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.coordenadorCountArgs<ExtArgs>
            result: $Utils.Optional<CoordenadorCountAggregateOutputType> | number
          }
        }
      }
      Agendamento: {
        payload: Prisma.$AgendamentoPayload<ExtArgs>
        fields: Prisma.AgendamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          findFirst: {
            args: Prisma.AgendamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          findMany: {
            args: Prisma.AgendamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>[]
          }
          create: {
            args: Prisma.AgendamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          createMany: {
            args: Prisma.AgendamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgendamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>[]
          }
          delete: {
            args: Prisma.AgendamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          update: {
            args: Prisma.AgendamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          deleteMany: {
            args: Prisma.AgendamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgendamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>[]
          }
          upsert: {
            args: Prisma.AgendamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendamentoPayload>
          }
          aggregate: {
            args: Prisma.AgendamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendamento>
          }
          groupBy: {
            args: Prisma.AgendamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgendamentoCountArgs<ExtArgs>
            result: $Utils.Optional<AgendamentoCountAggregateOutputType> | number
          }
        }
      }
      ProgramaAgendamento: {
        payload: Prisma.$ProgramaAgendamentoPayload<ExtArgs>
        fields: Prisma.ProgramaAgendamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramaAgendamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramaAgendamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          findFirst: {
            args: Prisma.ProgramaAgendamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramaAgendamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          findMany: {
            args: Prisma.ProgramaAgendamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>[]
          }
          create: {
            args: Prisma.ProgramaAgendamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          createMany: {
            args: Prisma.ProgramaAgendamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramaAgendamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>[]
          }
          delete: {
            args: Prisma.ProgramaAgendamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          update: {
            args: Prisma.ProgramaAgendamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          deleteMany: {
            args: Prisma.ProgramaAgendamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramaAgendamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramaAgendamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>[]
          }
          upsert: {
            args: Prisma.ProgramaAgendamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaAgendamentoPayload>
          }
          aggregate: {
            args: Prisma.ProgramaAgendamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramaAgendamento>
          }
          groupBy: {
            args: Prisma.ProgramaAgendamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramaAgendamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramaAgendamentoCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramaAgendamentoCountAggregateOutputType> | number
          }
        }
      }
      TipoAtendimentoAgendamento: {
        payload: Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>
        fields: Prisma.TipoAtendimentoAgendamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoAtendimentoAgendamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoAtendimentoAgendamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          findFirst: {
            args: Prisma.TipoAtendimentoAgendamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoAtendimentoAgendamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          findMany: {
            args: Prisma.TipoAtendimentoAgendamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>[]
          }
          create: {
            args: Prisma.TipoAtendimentoAgendamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          createMany: {
            args: Prisma.TipoAtendimentoAgendamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoAtendimentoAgendamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>[]
          }
          delete: {
            args: Prisma.TipoAtendimentoAgendamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          update: {
            args: Prisma.TipoAtendimentoAgendamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          deleteMany: {
            args: Prisma.TipoAtendimentoAgendamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoAtendimentoAgendamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoAtendimentoAgendamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>[]
          }
          upsert: {
            args: Prisma.TipoAtendimentoAgendamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoAgendamentoPayload>
          }
          aggregate: {
            args: Prisma.TipoAtendimentoAgendamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoAtendimentoAgendamento>
          }
          groupBy: {
            args: Prisma.TipoAtendimentoAgendamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoAtendimentoAgendamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoAtendimentoAgendamentoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoAtendimentoAgendamentoCountAggregateOutputType> | number
          }
        }
      }
      Aluno: {
        payload: Prisma.$AlunoPayload<ExtArgs>
        fields: Prisma.AlunoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlunoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlunoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          findFirst: {
            args: Prisma.AlunoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlunoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          findMany: {
            args: Prisma.AlunoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>[]
          }
          create: {
            args: Prisma.AlunoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          createMany: {
            args: Prisma.AlunoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlunoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>[]
          }
          delete: {
            args: Prisma.AlunoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          update: {
            args: Prisma.AlunoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          deleteMany: {
            args: Prisma.AlunoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlunoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlunoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>[]
          }
          upsert: {
            args: Prisma.AlunoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlunoPayload>
          }
          aggregate: {
            args: Prisma.AlunoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAluno>
          }
          groupBy: {
            args: Prisma.AlunoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlunoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlunoCountArgs<ExtArgs>
            result: $Utils.Optional<AlunoCountAggregateOutputType> | number
          }
        }
      }
      TipoAtendimento: {
        payload: Prisma.$TipoAtendimentoPayload<ExtArgs>
        fields: Prisma.TipoAtendimentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoAtendimentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoAtendimentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          findFirst: {
            args: Prisma.TipoAtendimentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoAtendimentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          findMany: {
            args: Prisma.TipoAtendimentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>[]
          }
          create: {
            args: Prisma.TipoAtendimentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          createMany: {
            args: Prisma.TipoAtendimentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoAtendimentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>[]
          }
          delete: {
            args: Prisma.TipoAtendimentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          update: {
            args: Prisma.TipoAtendimentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          deleteMany: {
            args: Prisma.TipoAtendimentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoAtendimentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoAtendimentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>[]
          }
          upsert: {
            args: Prisma.TipoAtendimentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAtendimentoPayload>
          }
          aggregate: {
            args: Prisma.TipoAtendimentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoAtendimento>
          }
          groupBy: {
            args: Prisma.TipoAtendimentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoAtendimentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoAtendimentoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoAtendimentoCountAggregateOutputType> | number
          }
        }
      }
      Programa: {
        payload: Prisma.$ProgramaPayload<ExtArgs>
        fields: Prisma.ProgramaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          findFirst: {
            args: Prisma.ProgramaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          findMany: {
            args: Prisma.ProgramaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>[]
          }
          create: {
            args: Prisma.ProgramaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          createMany: {
            args: Prisma.ProgramaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>[]
          }
          delete: {
            args: Prisma.ProgramaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          update: {
            args: Prisma.ProgramaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          deleteMany: {
            args: Prisma.ProgramaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>[]
          }
          upsert: {
            args: Prisma.ProgramaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramaPayload>
          }
          aggregate: {
            args: Prisma.ProgramaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrograma>
          }
          groupBy: {
            args: Prisma.ProgramaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramaCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramaCountAggregateOutputType> | number
          }
        }
      }
      Escala: {
        payload: Prisma.$EscalaPayload<ExtArgs>
        fields: Prisma.EscalaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscalaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscalaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          findFirst: {
            args: Prisma.EscalaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscalaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          findMany: {
            args: Prisma.EscalaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>[]
          }
          create: {
            args: Prisma.EscalaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          createMany: {
            args: Prisma.EscalaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscalaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>[]
          }
          delete: {
            args: Prisma.EscalaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          update: {
            args: Prisma.EscalaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          deleteMany: {
            args: Prisma.EscalaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscalaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EscalaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>[]
          }
          upsert: {
            args: Prisma.EscalaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaPayload>
          }
          aggregate: {
            args: Prisma.EscalaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscala>
          }
          groupBy: {
            args: Prisma.EscalaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscalaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscalaCountArgs<ExtArgs>
            result: $Utils.Optional<EscalaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    board?: BoardOmit
    boardMember?: BoardMemberOmit
    list?: ListOmit
    task?: TaskOmit
    label?: LabelOmit
    taskLabel?: TaskLabelOmit
    dashboard?: DashboardOmit
    pendencia?: PendenciaOmit
    notificacao?: NotificacaoOmit
    graficoCurso?: GraficoCursoOmit
    graficoBeneficiario?: GraficoBeneficiarioOmit
    curso?: CursoOmit
    coordenador?: coordenadorOmit
    agendamento?: AgendamentoOmit
    programaAgendamento?: ProgramaAgendamentoOmit
    tipoAtendimentoAgendamento?: TipoAtendimentoAgendamentoOmit
    aluno?: AlunoOmit
    tipoAtendimento?: TipoAtendimentoOmit
    programa?: ProgramaOmit
    escala?: EscalaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    boards: number
    memberships: number
    tasksCreated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | UserCountOutputTypeCountBoardsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    members: number
    lists: number
    labels: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | BoardCountOutputTypeCountMembersArgs
    lists?: boolean | BoardCountOutputTypeCountListsArgs
    labels?: boolean | BoardCountOutputTypeCountLabelsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardMemberWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }


  /**
   * Count Type ListCountOutputType
   */

  export type ListCountOutputType = {
    tasks: number
  }

  export type ListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ListCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListCountOutputType
     */
    select?: ListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    labels: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labels?: boolean | TaskCountOutputTypeCountLabelsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }


  /**
   * Count Type LabelCountOutputType
   */

  export type LabelCountOutputType = {
    tasks: number
  }

  export type LabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | LabelCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     */
    select?: LabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }


  /**
   * Count Type DashboardCountOutputType
   */

  export type DashboardCountOutputType = {
    pendencias: number
    notificacoes: number
    graficoCursos: number
    graficoBeneficiarios: number
  }

  export type DashboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendencias?: boolean | DashboardCountOutputTypeCountPendenciasArgs
    notificacoes?: boolean | DashboardCountOutputTypeCountNotificacoesArgs
    graficoCursos?: boolean | DashboardCountOutputTypeCountGraficoCursosArgs
    graficoBeneficiarios?: boolean | DashboardCountOutputTypeCountGraficoBeneficiariosArgs
  }

  // Custom InputTypes
  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardCountOutputType
     */
    select?: DashboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountPendenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendenciaWhereInput
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountNotificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacaoWhereInput
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountGraficoCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraficoCursoWhereInput
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountGraficoBeneficiariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraficoBeneficiarioWhereInput
  }


  /**
   * Count Type ProgramaCountOutputType
   */

  export type ProgramaCountOutputType = {
    tiposAtendimento: number
    Escala: number
  }

  export type ProgramaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiposAtendimento?: boolean | ProgramaCountOutputTypeCountTiposAtendimentoArgs
    Escala?: boolean | ProgramaCountOutputTypeCountEscalaArgs
  }

  // Custom InputTypes
  /**
   * ProgramaCountOutputType without action
   */
  export type ProgramaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaCountOutputType
     */
    select?: ProgramaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramaCountOutputType without action
   */
  export type ProgramaCountOutputTypeCountTiposAtendimentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoAtendimentoWhereInput
  }

  /**
   * ProgramaCountOutputType without action
   */
  export type ProgramaCountOutputTypeCountEscalaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscalaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    userName: string | null
    passwordHash: string | null
    authProvider: $Enums.AuthProvider | null
    isVerified: boolean | null
    CreatedAt: Date | null
    updatedAt: Date | null
    providerId: string | null
    isAdmin: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    userName: string | null
    passwordHash: string | null
    authProvider: $Enums.AuthProvider | null
    isVerified: boolean | null
    CreatedAt: Date | null
    updatedAt: Date | null
    providerId: string | null
    isAdmin: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role: number
    name: number
    email: number
    userName: number
    passwordHash: number
    authProvider: number
    isVerified: number
    CreatedAt: number
    updatedAt: number
    providerId: number
    isAdmin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    userName?: true
    passwordHash?: true
    authProvider?: true
    isVerified?: true
    CreatedAt?: true
    updatedAt?: true
    providerId?: true
    isAdmin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    userName?: true
    passwordHash?: true
    authProvider?: true
    isVerified?: true
    CreatedAt?: true
    updatedAt?: true
    providerId?: true
    isAdmin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    userName?: true
    passwordHash?: true
    authProvider?: true
    isVerified?: true
    CreatedAt?: true
    updatedAt?: true
    providerId?: true
    isAdmin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    role: $Enums.Role
    name: string | null
    email: string
    userName: string | null
    passwordHash: string | null
    authProvider: $Enums.AuthProvider
    isVerified: boolean
    CreatedAt: Date
    updatedAt: Date
    providerId: string | null
    isAdmin: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    userName?: boolean
    passwordHash?: boolean
    authProvider?: boolean
    isVerified?: boolean
    CreatedAt?: boolean
    updatedAt?: boolean
    providerId?: boolean
    isAdmin?: boolean
    boards?: boolean | User$boardsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    userName?: boolean
    passwordHash?: boolean
    authProvider?: boolean
    isVerified?: boolean
    CreatedAt?: boolean
    updatedAt?: boolean
    providerId?: boolean
    isAdmin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    userName?: boolean
    passwordHash?: boolean
    authProvider?: boolean
    isVerified?: boolean
    CreatedAt?: boolean
    updatedAt?: boolean
    providerId?: boolean
    isAdmin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    userName?: boolean
    passwordHash?: boolean
    authProvider?: boolean
    isVerified?: boolean
    CreatedAt?: boolean
    updatedAt?: boolean
    providerId?: boolean
    isAdmin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "name" | "email" | "userName" | "passwordHash" | "authProvider" | "isVerified" | "CreatedAt" | "updatedAt" | "providerId" | "isAdmin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | User$boardsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      boards: Prisma.$BoardPayload<ExtArgs>[]
      memberships: Prisma.$BoardMemberPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      name: string | null
      email: string
      userName: string | null
      passwordHash: string | null
      authProvider: $Enums.AuthProvider
      isVerified: boolean
      CreatedAt: Date
      updatedAt: Date
      providerId: string | null
      isAdmin: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boards<T extends User$boardsArgs<ExtArgs> = {}>(args?: Subset<T, User$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly CreatedAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly providerId: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.boards
   */
  export type User$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    where?: BoardMemberWhereInput
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    cursor?: BoardMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardMemberScalarFieldEnum | BoardMemberScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    visibility: $Enums.BoardVisibility | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoardMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    title: string | null
    description: string | null
    visibility: $Enums.BoardVisibility | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    ownerId: number
    title: number
    description: number
    visibility: number
    isArchived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoardMinAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    visibility?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    visibility?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    ownerId?: true
    title?: true
    description?: true
    visibility?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: string
    ownerId: string
    title: string
    description: string | null
    visibility: $Enums.BoardVisibility
    isArchived: boolean
    createdAt: Date
    updatedAt: Date
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Board$membersArgs<ExtArgs>
    lists?: boolean | Board$listsArgs<ExtArgs>
    labels?: boolean | Board$labelsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    ownerId?: boolean
    title?: boolean
    description?: boolean
    visibility?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "title" | "description" | "visibility" | "isArchived" | "createdAt" | "updatedAt", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Board$membersArgs<ExtArgs>
    lists?: boolean | Board$listsArgs<ExtArgs>
    labels?: boolean | Board$labelsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$BoardMemberPayload<ExtArgs>[]
      lists: Prisma.$ListPayload<ExtArgs>[]
      labels: Prisma.$LabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      title: string
      description: string | null
      visibility: $Enums.BoardVisibility
      isArchived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Board$membersArgs<ExtArgs> = {}>(args?: Subset<T, Board$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lists<T extends Board$listsArgs<ExtArgs> = {}>(args?: Subset<T, Board$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labels<T extends Board$labelsArgs<ExtArgs> = {}>(args?: Subset<T, Board$labelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'String'>
    readonly ownerId: FieldRef<"Board", 'String'>
    readonly title: FieldRef<"Board", 'String'>
    readonly description: FieldRef<"Board", 'String'>
    readonly visibility: FieldRef<"Board", 'BoardVisibility'>
    readonly isArchived: FieldRef<"Board", 'Boolean'>
    readonly createdAt: FieldRef<"Board", 'DateTime'>
    readonly updatedAt: FieldRef<"Board", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.members
   */
  export type Board$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    where?: BoardMemberWhereInput
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    cursor?: BoardMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardMemberScalarFieldEnum | BoardMemberScalarFieldEnum[]
  }

  /**
   * Board.lists
   */
  export type Board$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * Board.labels
   */
  export type Board$labelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model BoardMember
   */

  export type AggregateBoardMember = {
    _count: BoardMemberCountAggregateOutputType | null
    _min: BoardMemberMinAggregateOutputType | null
    _max: BoardMemberMaxAggregateOutputType | null
  }

  export type BoardMemberMinAggregateOutputType = {
    boardId: string | null
    userId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type BoardMemberMaxAggregateOutputType = {
    boardId: string | null
    userId: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
  }

  export type BoardMemberCountAggregateOutputType = {
    boardId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type BoardMemberMinAggregateInputType = {
    boardId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type BoardMemberMaxAggregateInputType = {
    boardId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type BoardMemberCountAggregateInputType = {
    boardId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type BoardMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardMember to aggregate.
     */
    where?: BoardMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardMembers to fetch.
     */
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardMembers
    **/
    _count?: true | BoardMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMemberMaxAggregateInputType
  }

  export type GetBoardMemberAggregateType<T extends BoardMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardMember[P]>
      : GetScalarType<T[P], AggregateBoardMember[P]>
  }




  export type BoardMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardMemberWhereInput
    orderBy?: BoardMemberOrderByWithAggregationInput | BoardMemberOrderByWithAggregationInput[]
    by: BoardMemberScalarFieldEnum[] | BoardMemberScalarFieldEnum
    having?: BoardMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardMemberCountAggregateInputType | true
    _min?: BoardMemberMinAggregateInputType
    _max?: BoardMemberMaxAggregateInputType
  }

  export type BoardMemberGroupByOutputType = {
    boardId: string
    userId: string
    role: $Enums.Role
    joinedAt: Date
    _count: BoardMemberCountAggregateOutputType | null
    _min: BoardMemberMinAggregateOutputType | null
    _max: BoardMemberMaxAggregateOutputType | null
  }

  type GetBoardMemberGroupByPayload<T extends BoardMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardMemberGroupByOutputType[P]>
            : GetScalarType<T[P], BoardMemberGroupByOutputType[P]>
        }
      >
    >


  export type BoardMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardMember"]>

  export type BoardMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardMember"]>

  export type BoardMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardMember"]>

  export type BoardMemberSelectScalar = {
    boardId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type BoardMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"boardId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["boardMember"]>
  export type BoardMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BoardMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BoardMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BoardMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoardMember"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      boardId: string
      userId: string
      role: $Enums.Role
      joinedAt: Date
    }, ExtArgs["result"]["boardMember"]>
    composites: {}
  }

  type BoardMemberGetPayload<S extends boolean | null | undefined | BoardMemberDefaultArgs> = $Result.GetResult<Prisma.$BoardMemberPayload, S>

  type BoardMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardMemberCountAggregateInputType | true
    }

  export interface BoardMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardMember'], meta: { name: 'BoardMember' } }
    /**
     * Find zero or one BoardMember that matches the filter.
     * @param {BoardMemberFindUniqueArgs} args - Arguments to find a BoardMember
     * @example
     * // Get one BoardMember
     * const boardMember = await prisma.boardMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardMemberFindUniqueArgs>(args: SelectSubset<T, BoardMemberFindUniqueArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoardMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardMemberFindUniqueOrThrowArgs} args - Arguments to find a BoardMember
     * @example
     * // Get one BoardMember
     * const boardMember = await prisma.boardMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberFindFirstArgs} args - Arguments to find a BoardMember
     * @example
     * // Get one BoardMember
     * const boardMember = await prisma.boardMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardMemberFindFirstArgs>(args?: SelectSubset<T, BoardMemberFindFirstArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberFindFirstOrThrowArgs} args - Arguments to find a BoardMember
     * @example
     * // Get one BoardMember
     * const boardMember = await prisma.boardMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoardMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardMembers
     * const boardMembers = await prisma.boardMember.findMany()
     * 
     * // Get first 10 BoardMembers
     * const boardMembers = await prisma.boardMember.findMany({ take: 10 })
     * 
     * // Only select the `boardId`
     * const boardMemberWithBoardIdOnly = await prisma.boardMember.findMany({ select: { boardId: true } })
     * 
     */
    findMany<T extends BoardMemberFindManyArgs>(args?: SelectSubset<T, BoardMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoardMember.
     * @param {BoardMemberCreateArgs} args - Arguments to create a BoardMember.
     * @example
     * // Create one BoardMember
     * const BoardMember = await prisma.boardMember.create({
     *   data: {
     *     // ... data to create a BoardMember
     *   }
     * })
     * 
     */
    create<T extends BoardMemberCreateArgs>(args: SelectSubset<T, BoardMemberCreateArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoardMembers.
     * @param {BoardMemberCreateManyArgs} args - Arguments to create many BoardMembers.
     * @example
     * // Create many BoardMembers
     * const boardMember = await prisma.boardMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardMemberCreateManyArgs>(args?: SelectSubset<T, BoardMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoardMembers and returns the data saved in the database.
     * @param {BoardMemberCreateManyAndReturnArgs} args - Arguments to create many BoardMembers.
     * @example
     * // Create many BoardMembers
     * const boardMember = await prisma.boardMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoardMembers and only return the `boardId`
     * const boardMemberWithBoardIdOnly = await prisma.boardMember.createManyAndReturn({
     *   select: { boardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoardMember.
     * @param {BoardMemberDeleteArgs} args - Arguments to delete one BoardMember.
     * @example
     * // Delete one BoardMember
     * const BoardMember = await prisma.boardMember.delete({
     *   where: {
     *     // ... filter to delete one BoardMember
     *   }
     * })
     * 
     */
    delete<T extends BoardMemberDeleteArgs>(args: SelectSubset<T, BoardMemberDeleteArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoardMember.
     * @param {BoardMemberUpdateArgs} args - Arguments to update one BoardMember.
     * @example
     * // Update one BoardMember
     * const boardMember = await prisma.boardMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardMemberUpdateArgs>(args: SelectSubset<T, BoardMemberUpdateArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoardMembers.
     * @param {BoardMemberDeleteManyArgs} args - Arguments to filter BoardMembers to delete.
     * @example
     * // Delete a few BoardMembers
     * const { count } = await prisma.boardMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardMemberDeleteManyArgs>(args?: SelectSubset<T, BoardMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardMembers
     * const boardMember = await prisma.boardMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardMemberUpdateManyArgs>(args: SelectSubset<T, BoardMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardMembers and returns the data updated in the database.
     * @param {BoardMemberUpdateManyAndReturnArgs} args - Arguments to update many BoardMembers.
     * @example
     * // Update many BoardMembers
     * const boardMember = await prisma.boardMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoardMembers and only return the `boardId`
     * const boardMemberWithBoardIdOnly = await prisma.boardMember.updateManyAndReturn({
     *   select: { boardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoardMember.
     * @param {BoardMemberUpsertArgs} args - Arguments to update or create a BoardMember.
     * @example
     * // Update or create a BoardMember
     * const boardMember = await prisma.boardMember.upsert({
     *   create: {
     *     // ... data to create a BoardMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardMember we want to update
     *   }
     * })
     */
    upsert<T extends BoardMemberUpsertArgs>(args: SelectSubset<T, BoardMemberUpsertArgs<ExtArgs>>): Prisma__BoardMemberClient<$Result.GetResult<Prisma.$BoardMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoardMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberCountArgs} args - Arguments to filter BoardMembers to count.
     * @example
     * // Count the number of BoardMembers
     * const count = await prisma.boardMember.count({
     *   where: {
     *     // ... the filter for the BoardMembers we want to count
     *   }
     * })
    **/
    count<T extends BoardMemberCountArgs>(
      args?: Subset<T, BoardMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardMemberAggregateArgs>(args: Subset<T, BoardMemberAggregateArgs>): Prisma.PrismaPromise<GetBoardMemberAggregateType<T>>

    /**
     * Group by BoardMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardMemberGroupByArgs['orderBy'] }
        : { orderBy?: BoardMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoardMember model
   */
  readonly fields: BoardMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoardMember model
   */
  interface BoardMemberFieldRefs {
    readonly boardId: FieldRef<"BoardMember", 'String'>
    readonly userId: FieldRef<"BoardMember", 'String'>
    readonly role: FieldRef<"BoardMember", 'Role'>
    readonly joinedAt: FieldRef<"BoardMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BoardMember findUnique
   */
  export type BoardMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter, which BoardMember to fetch.
     */
    where: BoardMemberWhereUniqueInput
  }

  /**
   * BoardMember findUniqueOrThrow
   */
  export type BoardMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter, which BoardMember to fetch.
     */
    where: BoardMemberWhereUniqueInput
  }

  /**
   * BoardMember findFirst
   */
  export type BoardMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter, which BoardMember to fetch.
     */
    where?: BoardMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardMembers to fetch.
     */
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardMembers.
     */
    cursor?: BoardMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardMembers.
     */
    distinct?: BoardMemberScalarFieldEnum | BoardMemberScalarFieldEnum[]
  }

  /**
   * BoardMember findFirstOrThrow
   */
  export type BoardMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter, which BoardMember to fetch.
     */
    where?: BoardMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardMembers to fetch.
     */
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardMembers.
     */
    cursor?: BoardMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardMembers.
     */
    distinct?: BoardMemberScalarFieldEnum | BoardMemberScalarFieldEnum[]
  }

  /**
   * BoardMember findMany
   */
  export type BoardMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter, which BoardMembers to fetch.
     */
    where?: BoardMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardMembers to fetch.
     */
    orderBy?: BoardMemberOrderByWithRelationInput | BoardMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardMembers.
     */
    cursor?: BoardMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardMembers.
     */
    skip?: number
    distinct?: BoardMemberScalarFieldEnum | BoardMemberScalarFieldEnum[]
  }

  /**
   * BoardMember create
   */
  export type BoardMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a BoardMember.
     */
    data: XOR<BoardMemberCreateInput, BoardMemberUncheckedCreateInput>
  }

  /**
   * BoardMember createMany
   */
  export type BoardMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardMembers.
     */
    data: BoardMemberCreateManyInput | BoardMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoardMember createManyAndReturn
   */
  export type BoardMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * The data used to create many BoardMembers.
     */
    data: BoardMemberCreateManyInput | BoardMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardMember update
   */
  export type BoardMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a BoardMember.
     */
    data: XOR<BoardMemberUpdateInput, BoardMemberUncheckedUpdateInput>
    /**
     * Choose, which BoardMember to update.
     */
    where: BoardMemberWhereUniqueInput
  }

  /**
   * BoardMember updateMany
   */
  export type BoardMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardMembers.
     */
    data: XOR<BoardMemberUpdateManyMutationInput, BoardMemberUncheckedUpdateManyInput>
    /**
     * Filter which BoardMembers to update
     */
    where?: BoardMemberWhereInput
    /**
     * Limit how many BoardMembers to update.
     */
    limit?: number
  }

  /**
   * BoardMember updateManyAndReturn
   */
  export type BoardMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * The data used to update BoardMembers.
     */
    data: XOR<BoardMemberUpdateManyMutationInput, BoardMemberUncheckedUpdateManyInput>
    /**
     * Filter which BoardMembers to update
     */
    where?: BoardMemberWhereInput
    /**
     * Limit how many BoardMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardMember upsert
   */
  export type BoardMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the BoardMember to update in case it exists.
     */
    where: BoardMemberWhereUniqueInput
    /**
     * In case the BoardMember found by the `where` argument doesn't exist, create a new BoardMember with this data.
     */
    create: XOR<BoardMemberCreateInput, BoardMemberUncheckedCreateInput>
    /**
     * In case the BoardMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardMemberUpdateInput, BoardMemberUncheckedUpdateInput>
  }

  /**
   * BoardMember delete
   */
  export type BoardMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
    /**
     * Filter which BoardMember to delete.
     */
    where: BoardMemberWhereUniqueInput
  }

  /**
   * BoardMember deleteMany
   */
  export type BoardMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardMembers to delete
     */
    where?: BoardMemberWhereInput
    /**
     * Limit how many BoardMembers to delete.
     */
    limit?: number
  }

  /**
   * BoardMember without action
   */
  export type BoardMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardMember
     */
    select?: BoardMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardMember
     */
    omit?: BoardMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardMemberInclude<ExtArgs> | null
  }


  /**
   * Model List
   */

  export type AggregateList = {
    _count: ListCountAggregateOutputType | null
    _avg: ListAvgAggregateOutputType | null
    _sum: ListSumAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  export type ListAvgAggregateOutputType = {
    position: number | null
  }

  export type ListSumAggregateOutputType = {
    position: number | null
  }

  export type ListMinAggregateOutputType = {
    id: string | null
    boardId: string | null
    title: string | null
    position: number | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListMaxAggregateOutputType = {
    id: string | null
    boardId: string | null
    title: string | null
    position: number | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListCountAggregateOutputType = {
    id: number
    boardId: number
    title: number
    position: number
    isArchived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListAvgAggregateInputType = {
    position?: true
  }

  export type ListSumAggregateInputType = {
    position?: true
  }

  export type ListMinAggregateInputType = {
    id?: true
    boardId?: true
    title?: true
    position?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListMaxAggregateInputType = {
    id?: true
    boardId?: true
    title?: true
    position?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListCountAggregateInputType = {
    id?: true
    boardId?: true
    title?: true
    position?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which List to aggregate.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lists
    **/
    _count?: true | ListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListMaxAggregateInputType
  }

  export type GetListAggregateType<T extends ListAggregateArgs> = {
        [P in keyof T & keyof AggregateList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateList[P]>
      : GetScalarType<T[P], AggregateList[P]>
  }




  export type ListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
    orderBy?: ListOrderByWithAggregationInput | ListOrderByWithAggregationInput[]
    by: ListScalarFieldEnum[] | ListScalarFieldEnum
    having?: ListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListCountAggregateInputType | true
    _avg?: ListAvgAggregateInputType
    _sum?: ListSumAggregateInputType
    _min?: ListMinAggregateInputType
    _max?: ListMaxAggregateInputType
  }

  export type ListGroupByOutputType = {
    id: string
    boardId: string
    title: string
    position: number
    isArchived: boolean
    createdAt: Date
    updatedAt: Date
    _count: ListCountAggregateOutputType | null
    _avg: ListAvgAggregateOutputType | null
    _sum: ListSumAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  type GetListGroupByPayload<T extends ListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListGroupByOutputType[P]>
            : GetScalarType<T[P], ListGroupByOutputType[P]>
        }
      >
    >


  export type ListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    title?: boolean
    position?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | List$tasksArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    title?: boolean
    position?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    title?: boolean
    position?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectScalar = {
    id?: boolean
    boardId?: boolean
    title?: boolean
    position?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boardId" | "title" | "position" | "isArchived" | "createdAt" | "updatedAt", ExtArgs["result"]["list"]>
  export type ListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | List$tasksArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type ListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $ListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "List"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      boardId: string
      title: string
      position: number
      isArchived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["list"]>
    composites: {}
  }

  type ListGetPayload<S extends boolean | null | undefined | ListDefaultArgs> = $Result.GetResult<Prisma.$ListPayload, S>

  type ListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListCountAggregateInputType | true
    }

  export interface ListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['List'], meta: { name: 'List' } }
    /**
     * Find zero or one List that matches the filter.
     * @param {ListFindUniqueArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListFindUniqueArgs>(args: SelectSubset<T, ListFindUniqueArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one List that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListFindUniqueOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListFindUniqueOrThrowArgs>(args: SelectSubset<T, ListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListFindFirstArgs>(args?: SelectSubset<T, ListFindFirstArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListFindFirstOrThrowArgs>(args?: SelectSubset<T, ListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lists
     * const lists = await prisma.list.findMany()
     * 
     * // Get first 10 Lists
     * const lists = await prisma.list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listWithIdOnly = await prisma.list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListFindManyArgs>(args?: SelectSubset<T, ListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a List.
     * @param {ListCreateArgs} args - Arguments to create a List.
     * @example
     * // Create one List
     * const List = await prisma.list.create({
     *   data: {
     *     // ... data to create a List
     *   }
     * })
     * 
     */
    create<T extends ListCreateArgs>(args: SelectSubset<T, ListCreateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lists.
     * @param {ListCreateManyArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListCreateManyArgs>(args?: SelectSubset<T, ListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lists and returns the data saved in the database.
     * @param {ListCreateManyAndReturnArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListCreateManyAndReturnArgs>(args?: SelectSubset<T, ListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a List.
     * @param {ListDeleteArgs} args - Arguments to delete one List.
     * @example
     * // Delete one List
     * const List = await prisma.list.delete({
     *   where: {
     *     // ... filter to delete one List
     *   }
     * })
     * 
     */
    delete<T extends ListDeleteArgs>(args: SelectSubset<T, ListDeleteArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one List.
     * @param {ListUpdateArgs} args - Arguments to update one List.
     * @example
     * // Update one List
     * const list = await prisma.list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListUpdateArgs>(args: SelectSubset<T, ListUpdateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lists.
     * @param {ListDeleteManyArgs} args - Arguments to filter Lists to delete.
     * @example
     * // Delete a few Lists
     * const { count } = await prisma.list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListDeleteManyArgs>(args?: SelectSubset<T, ListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListUpdateManyArgs>(args: SelectSubset<T, ListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists and returns the data updated in the database.
     * @param {ListUpdateManyAndReturnArgs} args - Arguments to update many Lists.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListUpdateManyAndReturnArgs>(args: SelectSubset<T, ListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one List.
     * @param {ListUpsertArgs} args - Arguments to update or create a List.
     * @example
     * // Update or create a List
     * const list = await prisma.list.upsert({
     *   create: {
     *     // ... data to create a List
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the List we want to update
     *   }
     * })
     */
    upsert<T extends ListUpsertArgs>(args: SelectSubset<T, ListUpsertArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListCountArgs} args - Arguments to filter Lists to count.
     * @example
     * // Count the number of Lists
     * const count = await prisma.list.count({
     *   where: {
     *     // ... the filter for the Lists we want to count
     *   }
     * })
    **/
    count<T extends ListCountArgs>(
      args?: Subset<T, ListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListAggregateArgs>(args: Subset<T, ListAggregateArgs>): Prisma.PrismaPromise<GetListAggregateType<T>>

    /**
     * Group by List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListGroupByArgs['orderBy'] }
        : { orderBy?: ListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the List model
   */
  readonly fields: ListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for List.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends List$tasksArgs<ExtArgs> = {}>(args?: Subset<T, List$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the List model
   */
  interface ListFieldRefs {
    readonly id: FieldRef<"List", 'String'>
    readonly boardId: FieldRef<"List", 'String'>
    readonly title: FieldRef<"List", 'String'>
    readonly position: FieldRef<"List", 'Int'>
    readonly isArchived: FieldRef<"List", 'Boolean'>
    readonly createdAt: FieldRef<"List", 'DateTime'>
    readonly updatedAt: FieldRef<"List", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * List findUnique
   */
  export type ListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findUniqueOrThrow
   */
  export type ListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findFirst
   */
  export type ListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findFirstOrThrow
   */
  export type ListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findMany
   */
  export type ListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which Lists to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List create
   */
  export type ListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to create a List.
     */
    data: XOR<ListCreateInput, ListUncheckedCreateInput>
  }

  /**
   * List createMany
   */
  export type ListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * List createManyAndReturn
   */
  export type ListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * List update
   */
  export type ListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to update a List.
     */
    data: XOR<ListUpdateInput, ListUncheckedUpdateInput>
    /**
     * Choose, which List to update.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List updateMany
   */
  export type ListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
  }

  /**
   * List updateManyAndReturn
   */
  export type ListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * List upsert
   */
  export type ListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The filter to search for the List to update in case it exists.
     */
    where: ListWhereUniqueInput
    /**
     * In case the List found by the `where` argument doesn't exist, create a new List with this data.
     */
    create: XOR<ListCreateInput, ListUncheckedCreateInput>
    /**
     * In case the List was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListUpdateInput, ListUncheckedUpdateInput>
  }

  /**
   * List delete
   */
  export type ListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter which List to delete.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List deleteMany
   */
  export type ListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lists to delete
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to delete.
     */
    limit?: number
  }

  /**
   * List.tasks
   */
  export type List$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * List without action
   */
  export type ListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    position: number | null
  }

  export type TaskSumAggregateOutputType = {
    position: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    listId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    position: number | null
    status: string | null
    dueDate: Date | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    listId: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    position: number | null
    status: string | null
    dueDate: Date | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    listId: number
    creatorId: number
    title: number
    description: number
    position: number
    status: number
    dueDate: number
    isArchived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    position?: true
  }

  export type TaskSumAggregateInputType = {
    position?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    listId?: true
    creatorId?: true
    title?: true
    description?: true
    position?: true
    status?: true
    dueDate?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    listId?: true
    creatorId?: true
    title?: true
    description?: true
    position?: true
    status?: true
    dueDate?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    listId?: true
    creatorId?: true
    title?: true
    description?: true
    position?: true
    status?: true
    dueDate?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    listId: string
    creatorId: string
    title: string
    description: string | null
    position: number
    status: string
    dueDate: Date | null
    isArchived: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    dueDate?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    dueDate?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    dueDate?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    listId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    status?: boolean
    dueDate?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listId" | "creatorId" | "title" | "description" | "position" | "status" | "dueDate" | "isArchived" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | ListDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      list: Prisma.$ListPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      labels: Prisma.$TaskLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listId: string
      creatorId: string
      title: string
      description: string | null
      position: number
      status: string
      dueDate: Date | null
      isArchived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends ListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListDefaultArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labels<T extends Task$labelsArgs<ExtArgs> = {}>(args?: Subset<T, Task$labelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly listId: FieldRef<"Task", 'String'>
    readonly creatorId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly position: FieldRef<"Task", 'Int'>
    readonly status: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly isArchived: FieldRef<"Task", 'Boolean'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.labels
   */
  export type Task$labelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelMinAggregateOutputType = {
    id: string | null
    boardId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabelMaxAggregateOutputType = {
    id: string | null
    boardId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    boardId: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabelMinAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: string
    boardId: string
    name: string
    color: string
    createdAt: Date
    updatedAt: Date
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | Label$tasksArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectScalar = {
    id?: boolean
    boardId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boardId" | "name" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["label"]>
  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    tasks?: boolean | Label$tasksArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type LabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      tasks: Prisma.$TaskLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      boardId: string
      name: string
      color: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labels and returns the data saved in the database.
     * @param {LabelCreateManyAndReturnArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabelCreateManyAndReturnArgs>(args?: SelectSubset<T, LabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels and returns the data updated in the database.
     * @param {LabelUpdateManyAndReturnArgs} args - Arguments to update many Labels.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabelUpdateManyAndReturnArgs>(args: SelectSubset<T, LabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Label$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Label$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'String'>
    readonly boardId: FieldRef<"Label", 'String'>
    readonly name: FieldRef<"Label", 'String'>
    readonly color: FieldRef<"Label", 'String'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
    readonly updatedAt: FieldRef<"Label", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Label createManyAndReturn
   */
  export type LabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
  }

  /**
   * Label updateManyAndReturn
   */
  export type LabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to delete.
     */
    limit?: number
  }

  /**
   * Label.tasks
   */
  export type Label$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model TaskLabel
   */

  export type AggregateTaskLabel = {
    _count: TaskLabelCountAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  export type TaskLabelMinAggregateOutputType = {
    taskId: string | null
    labelId: string | null
  }

  export type TaskLabelMaxAggregateOutputType = {
    taskId: string | null
    labelId: string | null
  }

  export type TaskLabelCountAggregateOutputType = {
    taskId: number
    labelId: number
    _all: number
  }


  export type TaskLabelMinAggregateInputType = {
    taskId?: true
    labelId?: true
  }

  export type TaskLabelMaxAggregateInputType = {
    taskId?: true
    labelId?: true
  }

  export type TaskLabelCountAggregateInputType = {
    taskId?: true
    labelId?: true
    _all?: true
  }

  export type TaskLabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabel to aggregate.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLabels
    **/
    _count?: true | TaskLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLabelMaxAggregateInputType
  }

  export type GetTaskLabelAggregateType<T extends TaskLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLabel[P]>
      : GetScalarType<T[P], AggregateTaskLabel[P]>
  }




  export type TaskLabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithAggregationInput | TaskLabelOrderByWithAggregationInput[]
    by: TaskLabelScalarFieldEnum[] | TaskLabelScalarFieldEnum
    having?: TaskLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLabelCountAggregateInputType | true
    _min?: TaskLabelMinAggregateInputType
    _max?: TaskLabelMaxAggregateInputType
  }

  export type TaskLabelGroupByOutputType = {
    taskId: string
    labelId: string
    _count: TaskLabelCountAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  type GetTaskLabelGroupByPayload<T extends TaskLabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
        }
      >
    >


  export type TaskLabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>

  export type TaskLabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>

  export type TaskLabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>

  export type TaskLabelSelectScalar = {
    taskId?: boolean
    labelId?: boolean
  }

  export type TaskLabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"taskId" | "labelId", ExtArgs["result"]["taskLabel"]>
  export type TaskLabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }
  export type TaskLabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }
  export type TaskLabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    label?: boolean | LabelDefaultArgs<ExtArgs>
  }

  export type $TaskLabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLabel"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      label: Prisma.$LabelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: string
      labelId: string
    }, ExtArgs["result"]["taskLabel"]>
    composites: {}
  }

  type TaskLabelGetPayload<S extends boolean | null | undefined | TaskLabelDefaultArgs> = $Result.GetResult<Prisma.$TaskLabelPayload, S>

  type TaskLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskLabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskLabelCountAggregateInputType | true
    }

  export interface TaskLabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLabel'], meta: { name: 'TaskLabel' } }
    /**
     * Find zero or one TaskLabel that matches the filter.
     * @param {TaskLabelFindUniqueArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLabelFindUniqueArgs>(args: SelectSubset<T, TaskLabelFindUniqueArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskLabel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskLabelFindUniqueOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLabelFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLabelFindFirstArgs>(args?: SelectSubset<T, TaskLabelFindFirstArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskLabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLabelFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany()
     * 
     * // Get first 10 TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskLabelFindManyArgs>(args?: SelectSubset<T, TaskLabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskLabel.
     * @param {TaskLabelCreateArgs} args - Arguments to create a TaskLabel.
     * @example
     * // Create one TaskLabel
     * const TaskLabel = await prisma.taskLabel.create({
     *   data: {
     *     // ... data to create a TaskLabel
     *   }
     * })
     * 
     */
    create<T extends TaskLabelCreateArgs>(args: SelectSubset<T, TaskLabelCreateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskLabels.
     * @param {TaskLabelCreateManyArgs} args - Arguments to create many TaskLabels.
     * @example
     * // Create many TaskLabels
     * const taskLabel = await prisma.taskLabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLabelCreateManyArgs>(args?: SelectSubset<T, TaskLabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskLabels and returns the data saved in the database.
     * @param {TaskLabelCreateManyAndReturnArgs} args - Arguments to create many TaskLabels.
     * @example
     * // Create many TaskLabels
     * const taskLabel = await prisma.taskLabel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskLabels and only return the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.createManyAndReturn({
     *   select: { taskId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskLabelCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskLabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskLabel.
     * @param {TaskLabelDeleteArgs} args - Arguments to delete one TaskLabel.
     * @example
     * // Delete one TaskLabel
     * const TaskLabel = await prisma.taskLabel.delete({
     *   where: {
     *     // ... filter to delete one TaskLabel
     *   }
     * })
     * 
     */
    delete<T extends TaskLabelDeleteArgs>(args: SelectSubset<T, TaskLabelDeleteArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskLabel.
     * @param {TaskLabelUpdateArgs} args - Arguments to update one TaskLabel.
     * @example
     * // Update one TaskLabel
     * const taskLabel = await prisma.taskLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLabelUpdateArgs>(args: SelectSubset<T, TaskLabelUpdateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskLabels.
     * @param {TaskLabelDeleteManyArgs} args - Arguments to filter TaskLabels to delete.
     * @example
     * // Delete a few TaskLabels
     * const { count } = await prisma.taskLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLabelDeleteManyArgs>(args?: SelectSubset<T, TaskLabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLabels
     * const taskLabel = await prisma.taskLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLabelUpdateManyArgs>(args: SelectSubset<T, TaskLabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLabels and returns the data updated in the database.
     * @param {TaskLabelUpdateManyAndReturnArgs} args - Arguments to update many TaskLabels.
     * @example
     * // Update many TaskLabels
     * const taskLabel = await prisma.taskLabel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskLabels and only return the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.updateManyAndReturn({
     *   select: { taskId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskLabelUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskLabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskLabel.
     * @param {TaskLabelUpsertArgs} args - Arguments to update or create a TaskLabel.
     * @example
     * // Update or create a TaskLabel
     * const taskLabel = await prisma.taskLabel.upsert({
     *   create: {
     *     // ... data to create a TaskLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLabel we want to update
     *   }
     * })
     */
    upsert<T extends TaskLabelUpsertArgs>(args: SelectSubset<T, TaskLabelUpsertArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelCountArgs} args - Arguments to filter TaskLabels to count.
     * @example
     * // Count the number of TaskLabels
     * const count = await prisma.taskLabel.count({
     *   where: {
     *     // ... the filter for the TaskLabels we want to count
     *   }
     * })
    **/
    count<T extends TaskLabelCountArgs>(
      args?: Subset<T, TaskLabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLabelAggregateArgs>(args: Subset<T, TaskLabelAggregateArgs>): Prisma.PrismaPromise<GetTaskLabelAggregateType<T>>

    /**
     * Group by TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLabelGroupByArgs['orderBy'] }
        : { orderBy?: TaskLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLabel model
   */
  readonly fields: TaskLabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    label<T extends LabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabelDefaultArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLabel model
   */
  interface TaskLabelFieldRefs {
    readonly taskId: FieldRef<"TaskLabel", 'String'>
    readonly labelId: FieldRef<"TaskLabel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskLabel findUnique
   */
  export type TaskLabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findUniqueOrThrow
   */
  export type TaskLabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findFirst
   */
  export type TaskLabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findFirstOrThrow
   */
  export type TaskLabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findMany
   */
  export type TaskLabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabels to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel create
   */
  export type TaskLabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLabel.
     */
    data: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
  }

  /**
   * TaskLabel createMany
   */
  export type TaskLabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLabels.
     */
    data: TaskLabelCreateManyInput | TaskLabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskLabel createManyAndReturn
   */
  export type TaskLabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * The data used to create many TaskLabels.
     */
    data: TaskLabelCreateManyInput | TaskLabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLabel update
   */
  export type TaskLabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLabel.
     */
    data: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
    /**
     * Choose, which TaskLabel to update.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel updateMany
   */
  export type TaskLabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLabels.
     */
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyInput>
    /**
     * Filter which TaskLabels to update
     */
    where?: TaskLabelWhereInput
    /**
     * Limit how many TaskLabels to update.
     */
    limit?: number
  }

  /**
   * TaskLabel updateManyAndReturn
   */
  export type TaskLabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * The data used to update TaskLabels.
     */
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyInput>
    /**
     * Filter which TaskLabels to update
     */
    where?: TaskLabelWhereInput
    /**
     * Limit how many TaskLabels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLabel upsert
   */
  export type TaskLabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLabel to update in case it exists.
     */
    where: TaskLabelWhereUniqueInput
    /**
     * In case the TaskLabel found by the `where` argument doesn't exist, create a new TaskLabel with this data.
     */
    create: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
    /**
     * In case the TaskLabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
  }

  /**
   * TaskLabel delete
   */
  export type TaskLabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter which TaskLabel to delete.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel deleteMany
   */
  export type TaskLabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabels to delete
     */
    where?: TaskLabelWhereInput
    /**
     * Limit how many TaskLabels to delete.
     */
    limit?: number
  }

  /**
   * TaskLabel without action
   */
  export type TaskLabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLabel
     */
    omit?: TaskLabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
  }


  /**
   * Model Dashboard
   */

  export type AggregateDashboard = {
    _count: DashboardCountAggregateOutputType | null
    _avg: DashboardAvgAggregateOutputType | null
    _sum: DashboardSumAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  export type DashboardAvgAggregateOutputType = {
    id: number | null
    cursos: number | null
    programas: number | null
    usuarios: number | null
    atendimentosMes: number | null
  }

  export type DashboardSumAggregateOutputType = {
    id: number | null
    cursos: number | null
    programas: number | null
    usuarios: number | null
    atendimentosMes: number | null
  }

  export type DashboardMinAggregateOutputType = {
    id: number | null
    cursos: number | null
    programas: number | null
    usuarios: number | null
    atendimentosMes: number | null
  }

  export type DashboardMaxAggregateOutputType = {
    id: number | null
    cursos: number | null
    programas: number | null
    usuarios: number | null
    atendimentosMes: number | null
  }

  export type DashboardCountAggregateOutputType = {
    id: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    _all: number
  }


  export type DashboardAvgAggregateInputType = {
    id?: true
    cursos?: true
    programas?: true
    usuarios?: true
    atendimentosMes?: true
  }

  export type DashboardSumAggregateInputType = {
    id?: true
    cursos?: true
    programas?: true
    usuarios?: true
    atendimentosMes?: true
  }

  export type DashboardMinAggregateInputType = {
    id?: true
    cursos?: true
    programas?: true
    usuarios?: true
    atendimentosMes?: true
  }

  export type DashboardMaxAggregateInputType = {
    id?: true
    cursos?: true
    programas?: true
    usuarios?: true
    atendimentosMes?: true
  }

  export type DashboardCountAggregateInputType = {
    id?: true
    cursos?: true
    programas?: true
    usuarios?: true
    atendimentosMes?: true
    _all?: true
  }

  export type DashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard to aggregate.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboards
    **/
    _count?: true | DashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMaxAggregateInputType
  }

  export type GetDashboardAggregateType<T extends DashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard[P]>
      : GetScalarType<T[P], AggregateDashboard[P]>
  }




  export type DashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithAggregationInput | DashboardOrderByWithAggregationInput[]
    by: DashboardScalarFieldEnum[] | DashboardScalarFieldEnum
    having?: DashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardCountAggregateInputType | true
    _avg?: DashboardAvgAggregateInputType
    _sum?: DashboardSumAggregateInputType
    _min?: DashboardMinAggregateInputType
    _max?: DashboardMaxAggregateInputType
  }

  export type DashboardGroupByOutputType = {
    id: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    _count: DashboardCountAggregateOutputType | null
    _avg: DashboardAvgAggregateOutputType | null
    _sum: DashboardSumAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  type GetDashboardGroupByPayload<T extends DashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardGroupByOutputType[P]>
        }
      >
    >


  export type DashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursos?: boolean
    programas?: boolean
    usuarios?: boolean
    atendimentosMes?: boolean
    pendencias?: boolean | Dashboard$pendenciasArgs<ExtArgs>
    notificacoes?: boolean | Dashboard$notificacoesArgs<ExtArgs>
    graficoCursos?: boolean | Dashboard$graficoCursosArgs<ExtArgs>
    graficoBeneficiarios?: boolean | Dashboard$graficoBeneficiariosArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursos?: boolean
    programas?: boolean
    usuarios?: boolean
    atendimentosMes?: boolean
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursos?: boolean
    programas?: boolean
    usuarios?: boolean
    atendimentosMes?: boolean
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectScalar = {
    id?: boolean
    cursos?: boolean
    programas?: boolean
    usuarios?: boolean
    atendimentosMes?: boolean
  }

  export type DashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursos" | "programas" | "usuarios" | "atendimentosMes", ExtArgs["result"]["dashboard"]>
  export type DashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendencias?: boolean | Dashboard$pendenciasArgs<ExtArgs>
    notificacoes?: boolean | Dashboard$notificacoesArgs<ExtArgs>
    graficoCursos?: boolean | Dashboard$graficoCursosArgs<ExtArgs>
    graficoBeneficiarios?: boolean | Dashboard$graficoBeneficiariosArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DashboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DashboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dashboard"
    objects: {
      pendencias: Prisma.$PendenciaPayload<ExtArgs>[]
      notificacoes: Prisma.$NotificacaoPayload<ExtArgs>[]
      graficoCursos: Prisma.$GraficoCursoPayload<ExtArgs>[]
      graficoBeneficiarios: Prisma.$GraficoBeneficiarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cursos: number
      programas: number
      usuarios: number
      atendimentosMes: number
    }, ExtArgs["result"]["dashboard"]>
    composites: {}
  }

  type DashboardGetPayload<S extends boolean | null | undefined | DashboardDefaultArgs> = $Result.GetResult<Prisma.$DashboardPayload, S>

  type DashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardCountAggregateInputType | true
    }

  export interface DashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dashboard'], meta: { name: 'Dashboard' } }
    /**
     * Find zero or one Dashboard that matches the filter.
     * @param {DashboardFindUniqueArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardFindUniqueArgs>(args: SelectSubset<T, DashboardFindUniqueArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardFindUniqueOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardFindFirstArgs>(args?: SelectSubset<T, DashboardFindFirstArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboard.findMany()
     * 
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardFindManyArgs>(args?: SelectSubset<T, DashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dashboard.
     * @param {DashboardCreateArgs} args - Arguments to create a Dashboard.
     * @example
     * // Create one Dashboard
     * const Dashboard = await prisma.dashboard.create({
     *   data: {
     *     // ... data to create a Dashboard
     *   }
     * })
     * 
     */
    create<T extends DashboardCreateArgs>(args: SelectSubset<T, DashboardCreateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dashboards.
     * @param {DashboardCreateManyArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardCreateManyArgs>(args?: SelectSubset<T, DashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dashboards and returns the data saved in the database.
     * @param {DashboardCreateManyAndReturnArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dashboard.
     * @param {DashboardDeleteArgs} args - Arguments to delete one Dashboard.
     * @example
     * // Delete one Dashboard
     * const Dashboard = await prisma.dashboard.delete({
     *   where: {
     *     // ... filter to delete one Dashboard
     *   }
     * })
     * 
     */
    delete<T extends DashboardDeleteArgs>(args: SelectSubset<T, DashboardDeleteArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dashboard.
     * @param {DashboardUpdateArgs} args - Arguments to update one Dashboard.
     * @example
     * // Update one Dashboard
     * const dashboard = await prisma.dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardUpdateArgs>(args: SelectSubset<T, DashboardUpdateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardDeleteManyArgs>(args?: SelectSubset<T, DashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardUpdateManyArgs>(args: SelectSubset<T, DashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards and returns the data updated in the database.
     * @param {DashboardUpdateManyAndReturnArgs} args - Arguments to update many Dashboards.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dashboard.
     * @param {DashboardUpsertArgs} args - Arguments to update or create a Dashboard.
     * @example
     * // Update or create a Dashboard
     * const dashboard = await prisma.dashboard.upsert({
     *   create: {
     *     // ... data to create a Dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard we want to update
     *   }
     * })
     */
    upsert<T extends DashboardUpsertArgs>(args: SelectSubset<T, DashboardUpsertArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboard.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
    **/
    count<T extends DashboardCountArgs>(
      args?: Subset<T, DashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAggregateArgs>(args: Subset<T, DashboardAggregateArgs>): Prisma.PrismaPromise<GetDashboardAggregateType<T>>

    /**
     * Group by Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardGroupByArgs['orderBy'] }
        : { orderBy?: DashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dashboard model
   */
  readonly fields: DashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendencias<T extends Dashboard$pendenciasArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$pendenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificacoes<T extends Dashboard$notificacoesArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$notificacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    graficoCursos<T extends Dashboard$graficoCursosArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$graficoCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    graficoBeneficiarios<T extends Dashboard$graficoBeneficiariosArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$graficoBeneficiariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dashboard model
   */
  interface DashboardFieldRefs {
    readonly id: FieldRef<"Dashboard", 'Int'>
    readonly cursos: FieldRef<"Dashboard", 'Int'>
    readonly programas: FieldRef<"Dashboard", 'Int'>
    readonly usuarios: FieldRef<"Dashboard", 'Int'>
    readonly atendimentosMes: FieldRef<"Dashboard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Dashboard findUnique
   */
  export type DashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findUniqueOrThrow
   */
  export type DashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findFirst
   */
  export type DashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findFirstOrThrow
   */
  export type DashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findMany
   */
  export type DashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboards to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard create
   */
  export type DashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Dashboard.
     */
    data: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
  }

  /**
   * Dashboard createMany
   */
  export type DashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard createManyAndReturn
   */
  export type DashboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard update
   */
  export type DashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Dashboard.
     */
    data: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
    /**
     * Choose, which Dashboard to update.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard updateMany
   */
  export type DashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard updateManyAndReturn
   */
  export type DashboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard upsert
   */
  export type DashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Dashboard to update in case it exists.
     */
    where: DashboardWhereUniqueInput
    /**
     * In case the Dashboard found by the `where` argument doesn't exist, create a new Dashboard with this data.
     */
    create: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
    /**
     * In case the Dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
  }

  /**
   * Dashboard delete
   */
  export type DashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter which Dashboard to delete.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard deleteMany
   */
  export type DashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboards to delete
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to delete.
     */
    limit?: number
  }

  /**
   * Dashboard.pendencias
   */
  export type Dashboard$pendenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    where?: PendenciaWhereInput
    orderBy?: PendenciaOrderByWithRelationInput | PendenciaOrderByWithRelationInput[]
    cursor?: PendenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendenciaScalarFieldEnum | PendenciaScalarFieldEnum[]
  }

  /**
   * Dashboard.notificacoes
   */
  export type Dashboard$notificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    where?: NotificacaoWhereInput
    orderBy?: NotificacaoOrderByWithRelationInput | NotificacaoOrderByWithRelationInput[]
    cursor?: NotificacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacaoScalarFieldEnum | NotificacaoScalarFieldEnum[]
  }

  /**
   * Dashboard.graficoCursos
   */
  export type Dashboard$graficoCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    where?: GraficoCursoWhereInput
    orderBy?: GraficoCursoOrderByWithRelationInput | GraficoCursoOrderByWithRelationInput[]
    cursor?: GraficoCursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GraficoCursoScalarFieldEnum | GraficoCursoScalarFieldEnum[]
  }

  /**
   * Dashboard.graficoBeneficiarios
   */
  export type Dashboard$graficoBeneficiariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    where?: GraficoBeneficiarioWhereInput
    orderBy?: GraficoBeneficiarioOrderByWithRelationInput | GraficoBeneficiarioOrderByWithRelationInput[]
    cursor?: GraficoBeneficiarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GraficoBeneficiarioScalarFieldEnum | GraficoBeneficiarioScalarFieldEnum[]
  }

  /**
   * Dashboard without action
   */
  export type DashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
  }


  /**
   * Model Pendencia
   */

  export type AggregatePendencia = {
    _count: PendenciaCountAggregateOutputType | null
    _avg: PendenciaAvgAggregateOutputType | null
    _sum: PendenciaSumAggregateOutputType | null
    _min: PendenciaMinAggregateOutputType | null
    _max: PendenciaMaxAggregateOutputType | null
  }

  export type PendenciaAvgAggregateOutputType = {
    id: number | null
    dashboardId: number | null
  }

  export type PendenciaSumAggregateOutputType = {
    id: number | null
    dashboardId: number | null
  }

  export type PendenciaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    dashboardId: number | null
  }

  export type PendenciaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    dashboardId: number | null
  }

  export type PendenciaCountAggregateOutputType = {
    id: number
    descricao: number
    dashboardId: number
    _all: number
  }


  export type PendenciaAvgAggregateInputType = {
    id?: true
    dashboardId?: true
  }

  export type PendenciaSumAggregateInputType = {
    id?: true
    dashboardId?: true
  }

  export type PendenciaMinAggregateInputType = {
    id?: true
    descricao?: true
    dashboardId?: true
  }

  export type PendenciaMaxAggregateInputType = {
    id?: true
    descricao?: true
    dashboardId?: true
  }

  export type PendenciaCountAggregateInputType = {
    id?: true
    descricao?: true
    dashboardId?: true
    _all?: true
  }

  export type PendenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pendencia to aggregate.
     */
    where?: PendenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendencias to fetch.
     */
    orderBy?: PendenciaOrderByWithRelationInput | PendenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pendencias
    **/
    _count?: true | PendenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendenciaMaxAggregateInputType
  }

  export type GetPendenciaAggregateType<T extends PendenciaAggregateArgs> = {
        [P in keyof T & keyof AggregatePendencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendencia[P]>
      : GetScalarType<T[P], AggregatePendencia[P]>
  }




  export type PendenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendenciaWhereInput
    orderBy?: PendenciaOrderByWithAggregationInput | PendenciaOrderByWithAggregationInput[]
    by: PendenciaScalarFieldEnum[] | PendenciaScalarFieldEnum
    having?: PendenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendenciaCountAggregateInputType | true
    _avg?: PendenciaAvgAggregateInputType
    _sum?: PendenciaSumAggregateInputType
    _min?: PendenciaMinAggregateInputType
    _max?: PendenciaMaxAggregateInputType
  }

  export type PendenciaGroupByOutputType = {
    id: number
    descricao: string
    dashboardId: number
    _count: PendenciaCountAggregateOutputType | null
    _avg: PendenciaAvgAggregateOutputType | null
    _sum: PendenciaSumAggregateOutputType | null
    _min: PendenciaMinAggregateOutputType | null
    _max: PendenciaMaxAggregateOutputType | null
  }

  type GetPendenciaGroupByPayload<T extends PendenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendenciaGroupByOutputType[P]>
            : GetScalarType<T[P], PendenciaGroupByOutputType[P]>
        }
      >
    >


  export type PendenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendencia"]>

  export type PendenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendencia"]>

  export type PendenciaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendencia"]>

  export type PendenciaSelectScalar = {
    id?: boolean
    descricao?: boolean
    dashboardId?: boolean
  }

  export type PendenciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "dashboardId", ExtArgs["result"]["pendencia"]>
  export type PendenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type PendenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type PendenciaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }

  export type $PendenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pendencia"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      dashboardId: number
    }, ExtArgs["result"]["pendencia"]>
    composites: {}
  }

  type PendenciaGetPayload<S extends boolean | null | undefined | PendenciaDefaultArgs> = $Result.GetResult<Prisma.$PendenciaPayload, S>

  type PendenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendenciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendenciaCountAggregateInputType | true
    }

  export interface PendenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pendencia'], meta: { name: 'Pendencia' } }
    /**
     * Find zero or one Pendencia that matches the filter.
     * @param {PendenciaFindUniqueArgs} args - Arguments to find a Pendencia
     * @example
     * // Get one Pendencia
     * const pendencia = await prisma.pendencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendenciaFindUniqueArgs>(args: SelectSubset<T, PendenciaFindUniqueArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pendencia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendenciaFindUniqueOrThrowArgs} args - Arguments to find a Pendencia
     * @example
     * // Get one Pendencia
     * const pendencia = await prisma.pendencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, PendenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pendencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaFindFirstArgs} args - Arguments to find a Pendencia
     * @example
     * // Get one Pendencia
     * const pendencia = await prisma.pendencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendenciaFindFirstArgs>(args?: SelectSubset<T, PendenciaFindFirstArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pendencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaFindFirstOrThrowArgs} args - Arguments to find a Pendencia
     * @example
     * // Get one Pendencia
     * const pendencia = await prisma.pendencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, PendenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pendencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pendencias
     * const pendencias = await prisma.pendencia.findMany()
     * 
     * // Get first 10 Pendencias
     * const pendencias = await prisma.pendencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendenciaWithIdOnly = await prisma.pendencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendenciaFindManyArgs>(args?: SelectSubset<T, PendenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pendencia.
     * @param {PendenciaCreateArgs} args - Arguments to create a Pendencia.
     * @example
     * // Create one Pendencia
     * const Pendencia = await prisma.pendencia.create({
     *   data: {
     *     // ... data to create a Pendencia
     *   }
     * })
     * 
     */
    create<T extends PendenciaCreateArgs>(args: SelectSubset<T, PendenciaCreateArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pendencias.
     * @param {PendenciaCreateManyArgs} args - Arguments to create many Pendencias.
     * @example
     * // Create many Pendencias
     * const pendencia = await prisma.pendencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendenciaCreateManyArgs>(args?: SelectSubset<T, PendenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pendencias and returns the data saved in the database.
     * @param {PendenciaCreateManyAndReturnArgs} args - Arguments to create many Pendencias.
     * @example
     * // Create many Pendencias
     * const pendencia = await prisma.pendencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pendencias and only return the `id`
     * const pendenciaWithIdOnly = await prisma.pendencia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, PendenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pendencia.
     * @param {PendenciaDeleteArgs} args - Arguments to delete one Pendencia.
     * @example
     * // Delete one Pendencia
     * const Pendencia = await prisma.pendencia.delete({
     *   where: {
     *     // ... filter to delete one Pendencia
     *   }
     * })
     * 
     */
    delete<T extends PendenciaDeleteArgs>(args: SelectSubset<T, PendenciaDeleteArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pendencia.
     * @param {PendenciaUpdateArgs} args - Arguments to update one Pendencia.
     * @example
     * // Update one Pendencia
     * const pendencia = await prisma.pendencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendenciaUpdateArgs>(args: SelectSubset<T, PendenciaUpdateArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pendencias.
     * @param {PendenciaDeleteManyArgs} args - Arguments to filter Pendencias to delete.
     * @example
     * // Delete a few Pendencias
     * const { count } = await prisma.pendencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendenciaDeleteManyArgs>(args?: SelectSubset<T, PendenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pendencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pendencias
     * const pendencia = await prisma.pendencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendenciaUpdateManyArgs>(args: SelectSubset<T, PendenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pendencias and returns the data updated in the database.
     * @param {PendenciaUpdateManyAndReturnArgs} args - Arguments to update many Pendencias.
     * @example
     * // Update many Pendencias
     * const pendencia = await prisma.pendencia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pendencias and only return the `id`
     * const pendenciaWithIdOnly = await prisma.pendencia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendenciaUpdateManyAndReturnArgs>(args: SelectSubset<T, PendenciaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pendencia.
     * @param {PendenciaUpsertArgs} args - Arguments to update or create a Pendencia.
     * @example
     * // Update or create a Pendencia
     * const pendencia = await prisma.pendencia.upsert({
     *   create: {
     *     // ... data to create a Pendencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pendencia we want to update
     *   }
     * })
     */
    upsert<T extends PendenciaUpsertArgs>(args: SelectSubset<T, PendenciaUpsertArgs<ExtArgs>>): Prisma__PendenciaClient<$Result.GetResult<Prisma.$PendenciaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pendencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaCountArgs} args - Arguments to filter Pendencias to count.
     * @example
     * // Count the number of Pendencias
     * const count = await prisma.pendencia.count({
     *   where: {
     *     // ... the filter for the Pendencias we want to count
     *   }
     * })
    **/
    count<T extends PendenciaCountArgs>(
      args?: Subset<T, PendenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pendencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendenciaAggregateArgs>(args: Subset<T, PendenciaAggregateArgs>): Prisma.PrismaPromise<GetPendenciaAggregateType<T>>

    /**
     * Group by Pendencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendenciaGroupByArgs['orderBy'] }
        : { orderBy?: PendenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pendencia model
   */
  readonly fields: PendenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pendencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardDefaultArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pendencia model
   */
  interface PendenciaFieldRefs {
    readonly id: FieldRef<"Pendencia", 'Int'>
    readonly descricao: FieldRef<"Pendencia", 'String'>
    readonly dashboardId: FieldRef<"Pendencia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pendencia findUnique
   */
  export type PendenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter, which Pendencia to fetch.
     */
    where: PendenciaWhereUniqueInput
  }

  /**
   * Pendencia findUniqueOrThrow
   */
  export type PendenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter, which Pendencia to fetch.
     */
    where: PendenciaWhereUniqueInput
  }

  /**
   * Pendencia findFirst
   */
  export type PendenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter, which Pendencia to fetch.
     */
    where?: PendenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendencias to fetch.
     */
    orderBy?: PendenciaOrderByWithRelationInput | PendenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pendencias.
     */
    cursor?: PendenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pendencias.
     */
    distinct?: PendenciaScalarFieldEnum | PendenciaScalarFieldEnum[]
  }

  /**
   * Pendencia findFirstOrThrow
   */
  export type PendenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter, which Pendencia to fetch.
     */
    where?: PendenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendencias to fetch.
     */
    orderBy?: PendenciaOrderByWithRelationInput | PendenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pendencias.
     */
    cursor?: PendenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pendencias.
     */
    distinct?: PendenciaScalarFieldEnum | PendenciaScalarFieldEnum[]
  }

  /**
   * Pendencia findMany
   */
  export type PendenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter, which Pendencias to fetch.
     */
    where?: PendenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pendencias to fetch.
     */
    orderBy?: PendenciaOrderByWithRelationInput | PendenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pendencias.
     */
    cursor?: PendenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pendencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pendencias.
     */
    skip?: number
    distinct?: PendenciaScalarFieldEnum | PendenciaScalarFieldEnum[]
  }

  /**
   * Pendencia create
   */
  export type PendenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pendencia.
     */
    data: XOR<PendenciaCreateInput, PendenciaUncheckedCreateInput>
  }

  /**
   * Pendencia createMany
   */
  export type PendenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pendencias.
     */
    data: PendenciaCreateManyInput | PendenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pendencia createManyAndReturn
   */
  export type PendenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * The data used to create many Pendencias.
     */
    data: PendenciaCreateManyInput | PendenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pendencia update
   */
  export type PendenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pendencia.
     */
    data: XOR<PendenciaUpdateInput, PendenciaUncheckedUpdateInput>
    /**
     * Choose, which Pendencia to update.
     */
    where: PendenciaWhereUniqueInput
  }

  /**
   * Pendencia updateMany
   */
  export type PendenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pendencias.
     */
    data: XOR<PendenciaUpdateManyMutationInput, PendenciaUncheckedUpdateManyInput>
    /**
     * Filter which Pendencias to update
     */
    where?: PendenciaWhereInput
    /**
     * Limit how many Pendencias to update.
     */
    limit?: number
  }

  /**
   * Pendencia updateManyAndReturn
   */
  export type PendenciaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * The data used to update Pendencias.
     */
    data: XOR<PendenciaUpdateManyMutationInput, PendenciaUncheckedUpdateManyInput>
    /**
     * Filter which Pendencias to update
     */
    where?: PendenciaWhereInput
    /**
     * Limit how many Pendencias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pendencia upsert
   */
  export type PendenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pendencia to update in case it exists.
     */
    where: PendenciaWhereUniqueInput
    /**
     * In case the Pendencia found by the `where` argument doesn't exist, create a new Pendencia with this data.
     */
    create: XOR<PendenciaCreateInput, PendenciaUncheckedCreateInput>
    /**
     * In case the Pendencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendenciaUpdateInput, PendenciaUncheckedUpdateInput>
  }

  /**
   * Pendencia delete
   */
  export type PendenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
    /**
     * Filter which Pendencia to delete.
     */
    where: PendenciaWhereUniqueInput
  }

  /**
   * Pendencia deleteMany
   */
  export type PendenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pendencias to delete
     */
    where?: PendenciaWhereInput
    /**
     * Limit how many Pendencias to delete.
     */
    limit?: number
  }

  /**
   * Pendencia without action
   */
  export type PendenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pendencia
     */
    select?: PendenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pendencia
     */
    omit?: PendenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendenciaInclude<ExtArgs> | null
  }


  /**
   * Model Notificacao
   */

  export type AggregateNotificacao = {
    _count: NotificacaoCountAggregateOutputType | null
    _avg: NotificacaoAvgAggregateOutputType | null
    _sum: NotificacaoSumAggregateOutputType | null
    _min: NotificacaoMinAggregateOutputType | null
    _max: NotificacaoMaxAggregateOutputType | null
  }

  export type NotificacaoAvgAggregateOutputType = {
    id: number | null
    dashboardId: number | null
  }

  export type NotificacaoSumAggregateOutputType = {
    id: number | null
    dashboardId: number | null
  }

  export type NotificacaoMinAggregateOutputType = {
    id: number | null
    mensagem: string | null
    dashboardId: number | null
  }

  export type NotificacaoMaxAggregateOutputType = {
    id: number | null
    mensagem: string | null
    dashboardId: number | null
  }

  export type NotificacaoCountAggregateOutputType = {
    id: number
    mensagem: number
    dashboardId: number
    _all: number
  }


  export type NotificacaoAvgAggregateInputType = {
    id?: true
    dashboardId?: true
  }

  export type NotificacaoSumAggregateInputType = {
    id?: true
    dashboardId?: true
  }

  export type NotificacaoMinAggregateInputType = {
    id?: true
    mensagem?: true
    dashboardId?: true
  }

  export type NotificacaoMaxAggregateInputType = {
    id?: true
    mensagem?: true
    dashboardId?: true
  }

  export type NotificacaoCountAggregateInputType = {
    id?: true
    mensagem?: true
    dashboardId?: true
    _all?: true
  }

  export type NotificacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacao to aggregate.
     */
    where?: NotificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacaos to fetch.
     */
    orderBy?: NotificacaoOrderByWithRelationInput | NotificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacaos
    **/
    _count?: true | NotificacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacaoMaxAggregateInputType
  }

  export type GetNotificacaoAggregateType<T extends NotificacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacao[P]>
      : GetScalarType<T[P], AggregateNotificacao[P]>
  }




  export type NotificacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacaoWhereInput
    orderBy?: NotificacaoOrderByWithAggregationInput | NotificacaoOrderByWithAggregationInput[]
    by: NotificacaoScalarFieldEnum[] | NotificacaoScalarFieldEnum
    having?: NotificacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacaoCountAggregateInputType | true
    _avg?: NotificacaoAvgAggregateInputType
    _sum?: NotificacaoSumAggregateInputType
    _min?: NotificacaoMinAggregateInputType
    _max?: NotificacaoMaxAggregateInputType
  }

  export type NotificacaoGroupByOutputType = {
    id: number
    mensagem: string
    dashboardId: number
    _count: NotificacaoCountAggregateOutputType | null
    _avg: NotificacaoAvgAggregateOutputType | null
    _sum: NotificacaoSumAggregateOutputType | null
    _min: NotificacaoMinAggregateOutputType | null
    _max: NotificacaoMaxAggregateOutputType | null
  }

  type GetNotificacaoGroupByPayload<T extends NotificacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacaoGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacaoGroupByOutputType[P]>
        }
      >
    >


  export type NotificacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacao"]>

  export type NotificacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacao"]>

  export type NotificacaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacao"]>

  export type NotificacaoSelectScalar = {
    id?: boolean
    mensagem?: boolean
    dashboardId?: boolean
  }

  export type NotificacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mensagem" | "dashboardId", ExtArgs["result"]["notificacao"]>
  export type NotificacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type NotificacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type NotificacaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }

  export type $NotificacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacao"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensagem: string
      dashboardId: number
    }, ExtArgs["result"]["notificacao"]>
    composites: {}
  }

  type NotificacaoGetPayload<S extends boolean | null | undefined | NotificacaoDefaultArgs> = $Result.GetResult<Prisma.$NotificacaoPayload, S>

  type NotificacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacaoCountAggregateInputType | true
    }

  export interface NotificacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacao'], meta: { name: 'Notificacao' } }
    /**
     * Find zero or one Notificacao that matches the filter.
     * @param {NotificacaoFindUniqueArgs} args - Arguments to find a Notificacao
     * @example
     * // Get one Notificacao
     * const notificacao = await prisma.notificacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacaoFindUniqueArgs>(args: SelectSubset<T, NotificacaoFindUniqueArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacaoFindUniqueOrThrowArgs} args - Arguments to find a Notificacao
     * @example
     * // Get one Notificacao
     * const notificacao = await prisma.notificacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoFindFirstArgs} args - Arguments to find a Notificacao
     * @example
     * // Get one Notificacao
     * const notificacao = await prisma.notificacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacaoFindFirstArgs>(args?: SelectSubset<T, NotificacaoFindFirstArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoFindFirstOrThrowArgs} args - Arguments to find a Notificacao
     * @example
     * // Get one Notificacao
     * const notificacao = await prisma.notificacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacaos
     * const notificacaos = await prisma.notificacao.findMany()
     * 
     * // Get first 10 Notificacaos
     * const notificacaos = await prisma.notificacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacaoWithIdOnly = await prisma.notificacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacaoFindManyArgs>(args?: SelectSubset<T, NotificacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacao.
     * @param {NotificacaoCreateArgs} args - Arguments to create a Notificacao.
     * @example
     * // Create one Notificacao
     * const Notificacao = await prisma.notificacao.create({
     *   data: {
     *     // ... data to create a Notificacao
     *   }
     * })
     * 
     */
    create<T extends NotificacaoCreateArgs>(args: SelectSubset<T, NotificacaoCreateArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacaos.
     * @param {NotificacaoCreateManyArgs} args - Arguments to create many Notificacaos.
     * @example
     * // Create many Notificacaos
     * const notificacao = await prisma.notificacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacaoCreateManyArgs>(args?: SelectSubset<T, NotificacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificacaos and returns the data saved in the database.
     * @param {NotificacaoCreateManyAndReturnArgs} args - Arguments to create many Notificacaos.
     * @example
     * // Create many Notificacaos
     * const notificacao = await prisma.notificacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificacaos and only return the `id`
     * const notificacaoWithIdOnly = await prisma.notificacao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificacao.
     * @param {NotificacaoDeleteArgs} args - Arguments to delete one Notificacao.
     * @example
     * // Delete one Notificacao
     * const Notificacao = await prisma.notificacao.delete({
     *   where: {
     *     // ... filter to delete one Notificacao
     *   }
     * })
     * 
     */
    delete<T extends NotificacaoDeleteArgs>(args: SelectSubset<T, NotificacaoDeleteArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacao.
     * @param {NotificacaoUpdateArgs} args - Arguments to update one Notificacao.
     * @example
     * // Update one Notificacao
     * const notificacao = await prisma.notificacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacaoUpdateArgs>(args: SelectSubset<T, NotificacaoUpdateArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacaos.
     * @param {NotificacaoDeleteManyArgs} args - Arguments to filter Notificacaos to delete.
     * @example
     * // Delete a few Notificacaos
     * const { count } = await prisma.notificacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacaoDeleteManyArgs>(args?: SelectSubset<T, NotificacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacaos
     * const notificacao = await prisma.notificacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacaoUpdateManyArgs>(args: SelectSubset<T, NotificacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacaos and returns the data updated in the database.
     * @param {NotificacaoUpdateManyAndReturnArgs} args - Arguments to update many Notificacaos.
     * @example
     * // Update many Notificacaos
     * const notificacao = await prisma.notificacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificacaos and only return the `id`
     * const notificacaoWithIdOnly = await prisma.notificacao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificacaoUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificacaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificacao.
     * @param {NotificacaoUpsertArgs} args - Arguments to update or create a Notificacao.
     * @example
     * // Update or create a Notificacao
     * const notificacao = await prisma.notificacao.upsert({
     *   create: {
     *     // ... data to create a Notificacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacao we want to update
     *   }
     * })
     */
    upsert<T extends NotificacaoUpsertArgs>(args: SelectSubset<T, NotificacaoUpsertArgs<ExtArgs>>): Prisma__NotificacaoClient<$Result.GetResult<Prisma.$NotificacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoCountArgs} args - Arguments to filter Notificacaos to count.
     * @example
     * // Count the number of Notificacaos
     * const count = await prisma.notificacao.count({
     *   where: {
     *     // ... the filter for the Notificacaos we want to count
     *   }
     * })
    **/
    count<T extends NotificacaoCountArgs>(
      args?: Subset<T, NotificacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacaoAggregateArgs>(args: Subset<T, NotificacaoAggregateArgs>): Prisma.PrismaPromise<GetNotificacaoAggregateType<T>>

    /**
     * Group by Notificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacaoGroupByArgs['orderBy'] }
        : { orderBy?: NotificacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacao model
   */
  readonly fields: NotificacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardDefaultArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacao model
   */
  interface NotificacaoFieldRefs {
    readonly id: FieldRef<"Notificacao", 'Int'>
    readonly mensagem: FieldRef<"Notificacao", 'String'>
    readonly dashboardId: FieldRef<"Notificacao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notificacao findUnique
   */
  export type NotificacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Notificacao to fetch.
     */
    where: NotificacaoWhereUniqueInput
  }

  /**
   * Notificacao findUniqueOrThrow
   */
  export type NotificacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Notificacao to fetch.
     */
    where: NotificacaoWhereUniqueInput
  }

  /**
   * Notificacao findFirst
   */
  export type NotificacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Notificacao to fetch.
     */
    where?: NotificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacaos to fetch.
     */
    orderBy?: NotificacaoOrderByWithRelationInput | NotificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacaos.
     */
    cursor?: NotificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacaos.
     */
    distinct?: NotificacaoScalarFieldEnum | NotificacaoScalarFieldEnum[]
  }

  /**
   * Notificacao findFirstOrThrow
   */
  export type NotificacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Notificacao to fetch.
     */
    where?: NotificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacaos to fetch.
     */
    orderBy?: NotificacaoOrderByWithRelationInput | NotificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacaos.
     */
    cursor?: NotificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacaos.
     */
    distinct?: NotificacaoScalarFieldEnum | NotificacaoScalarFieldEnum[]
  }

  /**
   * Notificacao findMany
   */
  export type NotificacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter, which Notificacaos to fetch.
     */
    where?: NotificacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacaos to fetch.
     */
    orderBy?: NotificacaoOrderByWithRelationInput | NotificacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacaos.
     */
    cursor?: NotificacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacaos.
     */
    skip?: number
    distinct?: NotificacaoScalarFieldEnum | NotificacaoScalarFieldEnum[]
  }

  /**
   * Notificacao create
   */
  export type NotificacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacao.
     */
    data: XOR<NotificacaoCreateInput, NotificacaoUncheckedCreateInput>
  }

  /**
   * Notificacao createMany
   */
  export type NotificacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacaos.
     */
    data: NotificacaoCreateManyInput | NotificacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacao createManyAndReturn
   */
  export type NotificacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * The data used to create many Notificacaos.
     */
    data: NotificacaoCreateManyInput | NotificacaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacao update
   */
  export type NotificacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacao.
     */
    data: XOR<NotificacaoUpdateInput, NotificacaoUncheckedUpdateInput>
    /**
     * Choose, which Notificacao to update.
     */
    where: NotificacaoWhereUniqueInput
  }

  /**
   * Notificacao updateMany
   */
  export type NotificacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacaos.
     */
    data: XOR<NotificacaoUpdateManyMutationInput, NotificacaoUncheckedUpdateManyInput>
    /**
     * Filter which Notificacaos to update
     */
    where?: NotificacaoWhereInput
    /**
     * Limit how many Notificacaos to update.
     */
    limit?: number
  }

  /**
   * Notificacao updateManyAndReturn
   */
  export type NotificacaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * The data used to update Notificacaos.
     */
    data: XOR<NotificacaoUpdateManyMutationInput, NotificacaoUncheckedUpdateManyInput>
    /**
     * Filter which Notificacaos to update
     */
    where?: NotificacaoWhereInput
    /**
     * Limit how many Notificacaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacao upsert
   */
  export type NotificacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacao to update in case it exists.
     */
    where: NotificacaoWhereUniqueInput
    /**
     * In case the Notificacao found by the `where` argument doesn't exist, create a new Notificacao with this data.
     */
    create: XOR<NotificacaoCreateInput, NotificacaoUncheckedCreateInput>
    /**
     * In case the Notificacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacaoUpdateInput, NotificacaoUncheckedUpdateInput>
  }

  /**
   * Notificacao delete
   */
  export type NotificacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
    /**
     * Filter which Notificacao to delete.
     */
    where: NotificacaoWhereUniqueInput
  }

  /**
   * Notificacao deleteMany
   */
  export type NotificacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacaos to delete
     */
    where?: NotificacaoWhereInput
    /**
     * Limit how many Notificacaos to delete.
     */
    limit?: number
  }

  /**
   * Notificacao without action
   */
  export type NotificacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacao
     */
    select?: NotificacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacao
     */
    omit?: NotificacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacaoInclude<ExtArgs> | null
  }


  /**
   * Model GraficoCurso
   */

  export type AggregateGraficoCurso = {
    _count: GraficoCursoCountAggregateOutputType | null
    _avg: GraficoCursoAvgAggregateOutputType | null
    _sum: GraficoCursoSumAggregateOutputType | null
    _min: GraficoCursoMinAggregateOutputType | null
    _max: GraficoCursoMaxAggregateOutputType | null
  }

  export type GraficoCursoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoCursoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoCursoMinAggregateOutputType = {
    id: number | null
    label: string | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoCursoMaxAggregateOutputType = {
    id: number | null
    label: string | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoCursoCountAggregateOutputType = {
    id: number
    label: number
    valor: number
    dashboardId: number
    _all: number
  }


  export type GraficoCursoAvgAggregateInputType = {
    id?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoCursoSumAggregateInputType = {
    id?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoCursoMinAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoCursoMaxAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoCursoCountAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
    _all?: true
  }

  export type GraficoCursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GraficoCurso to aggregate.
     */
    where?: GraficoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoCursos to fetch.
     */
    orderBy?: GraficoCursoOrderByWithRelationInput | GraficoCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GraficoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GraficoCursos
    **/
    _count?: true | GraficoCursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GraficoCursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GraficoCursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GraficoCursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GraficoCursoMaxAggregateInputType
  }

  export type GetGraficoCursoAggregateType<T extends GraficoCursoAggregateArgs> = {
        [P in keyof T & keyof AggregateGraficoCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGraficoCurso[P]>
      : GetScalarType<T[P], AggregateGraficoCurso[P]>
  }




  export type GraficoCursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraficoCursoWhereInput
    orderBy?: GraficoCursoOrderByWithAggregationInput | GraficoCursoOrderByWithAggregationInput[]
    by: GraficoCursoScalarFieldEnum[] | GraficoCursoScalarFieldEnum
    having?: GraficoCursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GraficoCursoCountAggregateInputType | true
    _avg?: GraficoCursoAvgAggregateInputType
    _sum?: GraficoCursoSumAggregateInputType
    _min?: GraficoCursoMinAggregateInputType
    _max?: GraficoCursoMaxAggregateInputType
  }

  export type GraficoCursoGroupByOutputType = {
    id: number
    label: string
    valor: number
    dashboardId: number
    _count: GraficoCursoCountAggregateOutputType | null
    _avg: GraficoCursoAvgAggregateOutputType | null
    _sum: GraficoCursoSumAggregateOutputType | null
    _min: GraficoCursoMinAggregateOutputType | null
    _max: GraficoCursoMaxAggregateOutputType | null
  }

  type GetGraficoCursoGroupByPayload<T extends GraficoCursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GraficoCursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GraficoCursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GraficoCursoGroupByOutputType[P]>
            : GetScalarType<T[P], GraficoCursoGroupByOutputType[P]>
        }
      >
    >


  export type GraficoCursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoCurso"]>

  export type GraficoCursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoCurso"]>

  export type GraficoCursoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoCurso"]>

  export type GraficoCursoSelectScalar = {
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
  }

  export type GraficoCursoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "valor" | "dashboardId", ExtArgs["result"]["graficoCurso"]>
  export type GraficoCursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type GraficoCursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type GraficoCursoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }

  export type $GraficoCursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GraficoCurso"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      valor: number
      dashboardId: number
    }, ExtArgs["result"]["graficoCurso"]>
    composites: {}
  }

  type GraficoCursoGetPayload<S extends boolean | null | undefined | GraficoCursoDefaultArgs> = $Result.GetResult<Prisma.$GraficoCursoPayload, S>

  type GraficoCursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GraficoCursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GraficoCursoCountAggregateInputType | true
    }

  export interface GraficoCursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GraficoCurso'], meta: { name: 'GraficoCurso' } }
    /**
     * Find zero or one GraficoCurso that matches the filter.
     * @param {GraficoCursoFindUniqueArgs} args - Arguments to find a GraficoCurso
     * @example
     * // Get one GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GraficoCursoFindUniqueArgs>(args: SelectSubset<T, GraficoCursoFindUniqueArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GraficoCurso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GraficoCursoFindUniqueOrThrowArgs} args - Arguments to find a GraficoCurso
     * @example
     * // Get one GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GraficoCursoFindUniqueOrThrowArgs>(args: SelectSubset<T, GraficoCursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GraficoCurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoFindFirstArgs} args - Arguments to find a GraficoCurso
     * @example
     * // Get one GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GraficoCursoFindFirstArgs>(args?: SelectSubset<T, GraficoCursoFindFirstArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GraficoCurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoFindFirstOrThrowArgs} args - Arguments to find a GraficoCurso
     * @example
     * // Get one GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GraficoCursoFindFirstOrThrowArgs>(args?: SelectSubset<T, GraficoCursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GraficoCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GraficoCursos
     * const graficoCursos = await prisma.graficoCurso.findMany()
     * 
     * // Get first 10 GraficoCursos
     * const graficoCursos = await prisma.graficoCurso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const graficoCursoWithIdOnly = await prisma.graficoCurso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GraficoCursoFindManyArgs>(args?: SelectSubset<T, GraficoCursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GraficoCurso.
     * @param {GraficoCursoCreateArgs} args - Arguments to create a GraficoCurso.
     * @example
     * // Create one GraficoCurso
     * const GraficoCurso = await prisma.graficoCurso.create({
     *   data: {
     *     // ... data to create a GraficoCurso
     *   }
     * })
     * 
     */
    create<T extends GraficoCursoCreateArgs>(args: SelectSubset<T, GraficoCursoCreateArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GraficoCursos.
     * @param {GraficoCursoCreateManyArgs} args - Arguments to create many GraficoCursos.
     * @example
     * // Create many GraficoCursos
     * const graficoCurso = await prisma.graficoCurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GraficoCursoCreateManyArgs>(args?: SelectSubset<T, GraficoCursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GraficoCursos and returns the data saved in the database.
     * @param {GraficoCursoCreateManyAndReturnArgs} args - Arguments to create many GraficoCursos.
     * @example
     * // Create many GraficoCursos
     * const graficoCurso = await prisma.graficoCurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GraficoCursos and only return the `id`
     * const graficoCursoWithIdOnly = await prisma.graficoCurso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GraficoCursoCreateManyAndReturnArgs>(args?: SelectSubset<T, GraficoCursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GraficoCurso.
     * @param {GraficoCursoDeleteArgs} args - Arguments to delete one GraficoCurso.
     * @example
     * // Delete one GraficoCurso
     * const GraficoCurso = await prisma.graficoCurso.delete({
     *   where: {
     *     // ... filter to delete one GraficoCurso
     *   }
     * })
     * 
     */
    delete<T extends GraficoCursoDeleteArgs>(args: SelectSubset<T, GraficoCursoDeleteArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GraficoCurso.
     * @param {GraficoCursoUpdateArgs} args - Arguments to update one GraficoCurso.
     * @example
     * // Update one GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GraficoCursoUpdateArgs>(args: SelectSubset<T, GraficoCursoUpdateArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GraficoCursos.
     * @param {GraficoCursoDeleteManyArgs} args - Arguments to filter GraficoCursos to delete.
     * @example
     * // Delete a few GraficoCursos
     * const { count } = await prisma.graficoCurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GraficoCursoDeleteManyArgs>(args?: SelectSubset<T, GraficoCursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GraficoCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GraficoCursos
     * const graficoCurso = await prisma.graficoCurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GraficoCursoUpdateManyArgs>(args: SelectSubset<T, GraficoCursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GraficoCursos and returns the data updated in the database.
     * @param {GraficoCursoUpdateManyAndReturnArgs} args - Arguments to update many GraficoCursos.
     * @example
     * // Update many GraficoCursos
     * const graficoCurso = await prisma.graficoCurso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GraficoCursos and only return the `id`
     * const graficoCursoWithIdOnly = await prisma.graficoCurso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GraficoCursoUpdateManyAndReturnArgs>(args: SelectSubset<T, GraficoCursoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GraficoCurso.
     * @param {GraficoCursoUpsertArgs} args - Arguments to update or create a GraficoCurso.
     * @example
     * // Update or create a GraficoCurso
     * const graficoCurso = await prisma.graficoCurso.upsert({
     *   create: {
     *     // ... data to create a GraficoCurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GraficoCurso we want to update
     *   }
     * })
     */
    upsert<T extends GraficoCursoUpsertArgs>(args: SelectSubset<T, GraficoCursoUpsertArgs<ExtArgs>>): Prisma__GraficoCursoClient<$Result.GetResult<Prisma.$GraficoCursoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GraficoCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoCountArgs} args - Arguments to filter GraficoCursos to count.
     * @example
     * // Count the number of GraficoCursos
     * const count = await prisma.graficoCurso.count({
     *   where: {
     *     // ... the filter for the GraficoCursos we want to count
     *   }
     * })
    **/
    count<T extends GraficoCursoCountArgs>(
      args?: Subset<T, GraficoCursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GraficoCursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GraficoCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GraficoCursoAggregateArgs>(args: Subset<T, GraficoCursoAggregateArgs>): Prisma.PrismaPromise<GetGraficoCursoAggregateType<T>>

    /**
     * Group by GraficoCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoCursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GraficoCursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GraficoCursoGroupByArgs['orderBy'] }
        : { orderBy?: GraficoCursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GraficoCursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGraficoCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GraficoCurso model
   */
  readonly fields: GraficoCursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GraficoCurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GraficoCursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardDefaultArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GraficoCurso model
   */
  interface GraficoCursoFieldRefs {
    readonly id: FieldRef<"GraficoCurso", 'Int'>
    readonly label: FieldRef<"GraficoCurso", 'String'>
    readonly valor: FieldRef<"GraficoCurso", 'Int'>
    readonly dashboardId: FieldRef<"GraficoCurso", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GraficoCurso findUnique
   */
  export type GraficoCursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter, which GraficoCurso to fetch.
     */
    where: GraficoCursoWhereUniqueInput
  }

  /**
   * GraficoCurso findUniqueOrThrow
   */
  export type GraficoCursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter, which GraficoCurso to fetch.
     */
    where: GraficoCursoWhereUniqueInput
  }

  /**
   * GraficoCurso findFirst
   */
  export type GraficoCursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter, which GraficoCurso to fetch.
     */
    where?: GraficoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoCursos to fetch.
     */
    orderBy?: GraficoCursoOrderByWithRelationInput | GraficoCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GraficoCursos.
     */
    cursor?: GraficoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GraficoCursos.
     */
    distinct?: GraficoCursoScalarFieldEnum | GraficoCursoScalarFieldEnum[]
  }

  /**
   * GraficoCurso findFirstOrThrow
   */
  export type GraficoCursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter, which GraficoCurso to fetch.
     */
    where?: GraficoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoCursos to fetch.
     */
    orderBy?: GraficoCursoOrderByWithRelationInput | GraficoCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GraficoCursos.
     */
    cursor?: GraficoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GraficoCursos.
     */
    distinct?: GraficoCursoScalarFieldEnum | GraficoCursoScalarFieldEnum[]
  }

  /**
   * GraficoCurso findMany
   */
  export type GraficoCursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter, which GraficoCursos to fetch.
     */
    where?: GraficoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoCursos to fetch.
     */
    orderBy?: GraficoCursoOrderByWithRelationInput | GraficoCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GraficoCursos.
     */
    cursor?: GraficoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoCursos.
     */
    skip?: number
    distinct?: GraficoCursoScalarFieldEnum | GraficoCursoScalarFieldEnum[]
  }

  /**
   * GraficoCurso create
   */
  export type GraficoCursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * The data needed to create a GraficoCurso.
     */
    data: XOR<GraficoCursoCreateInput, GraficoCursoUncheckedCreateInput>
  }

  /**
   * GraficoCurso createMany
   */
  export type GraficoCursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GraficoCursos.
     */
    data: GraficoCursoCreateManyInput | GraficoCursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GraficoCurso createManyAndReturn
   */
  export type GraficoCursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * The data used to create many GraficoCursos.
     */
    data: GraficoCursoCreateManyInput | GraficoCursoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GraficoCurso update
   */
  export type GraficoCursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * The data needed to update a GraficoCurso.
     */
    data: XOR<GraficoCursoUpdateInput, GraficoCursoUncheckedUpdateInput>
    /**
     * Choose, which GraficoCurso to update.
     */
    where: GraficoCursoWhereUniqueInput
  }

  /**
   * GraficoCurso updateMany
   */
  export type GraficoCursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GraficoCursos.
     */
    data: XOR<GraficoCursoUpdateManyMutationInput, GraficoCursoUncheckedUpdateManyInput>
    /**
     * Filter which GraficoCursos to update
     */
    where?: GraficoCursoWhereInput
    /**
     * Limit how many GraficoCursos to update.
     */
    limit?: number
  }

  /**
   * GraficoCurso updateManyAndReturn
   */
  export type GraficoCursoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * The data used to update GraficoCursos.
     */
    data: XOR<GraficoCursoUpdateManyMutationInput, GraficoCursoUncheckedUpdateManyInput>
    /**
     * Filter which GraficoCursos to update
     */
    where?: GraficoCursoWhereInput
    /**
     * Limit how many GraficoCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GraficoCurso upsert
   */
  export type GraficoCursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * The filter to search for the GraficoCurso to update in case it exists.
     */
    where: GraficoCursoWhereUniqueInput
    /**
     * In case the GraficoCurso found by the `where` argument doesn't exist, create a new GraficoCurso with this data.
     */
    create: XOR<GraficoCursoCreateInput, GraficoCursoUncheckedCreateInput>
    /**
     * In case the GraficoCurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GraficoCursoUpdateInput, GraficoCursoUncheckedUpdateInput>
  }

  /**
   * GraficoCurso delete
   */
  export type GraficoCursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
    /**
     * Filter which GraficoCurso to delete.
     */
    where: GraficoCursoWhereUniqueInput
  }

  /**
   * GraficoCurso deleteMany
   */
  export type GraficoCursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GraficoCursos to delete
     */
    where?: GraficoCursoWhereInput
    /**
     * Limit how many GraficoCursos to delete.
     */
    limit?: number
  }

  /**
   * GraficoCurso without action
   */
  export type GraficoCursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoCurso
     */
    select?: GraficoCursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoCurso
     */
    omit?: GraficoCursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoCursoInclude<ExtArgs> | null
  }


  /**
   * Model GraficoBeneficiario
   */

  export type AggregateGraficoBeneficiario = {
    _count: GraficoBeneficiarioCountAggregateOutputType | null
    _avg: GraficoBeneficiarioAvgAggregateOutputType | null
    _sum: GraficoBeneficiarioSumAggregateOutputType | null
    _min: GraficoBeneficiarioMinAggregateOutputType | null
    _max: GraficoBeneficiarioMaxAggregateOutputType | null
  }

  export type GraficoBeneficiarioAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoBeneficiarioSumAggregateOutputType = {
    id: number | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoBeneficiarioMinAggregateOutputType = {
    id: number | null
    label: string | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoBeneficiarioMaxAggregateOutputType = {
    id: number | null
    label: string | null
    valor: number | null
    dashboardId: number | null
  }

  export type GraficoBeneficiarioCountAggregateOutputType = {
    id: number
    label: number
    valor: number
    dashboardId: number
    _all: number
  }


  export type GraficoBeneficiarioAvgAggregateInputType = {
    id?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoBeneficiarioSumAggregateInputType = {
    id?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoBeneficiarioMinAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoBeneficiarioMaxAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
  }

  export type GraficoBeneficiarioCountAggregateInputType = {
    id?: true
    label?: true
    valor?: true
    dashboardId?: true
    _all?: true
  }

  export type GraficoBeneficiarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GraficoBeneficiario to aggregate.
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoBeneficiarios to fetch.
     */
    orderBy?: GraficoBeneficiarioOrderByWithRelationInput | GraficoBeneficiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GraficoBeneficiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoBeneficiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoBeneficiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GraficoBeneficiarios
    **/
    _count?: true | GraficoBeneficiarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GraficoBeneficiarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GraficoBeneficiarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GraficoBeneficiarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GraficoBeneficiarioMaxAggregateInputType
  }

  export type GetGraficoBeneficiarioAggregateType<T extends GraficoBeneficiarioAggregateArgs> = {
        [P in keyof T & keyof AggregateGraficoBeneficiario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGraficoBeneficiario[P]>
      : GetScalarType<T[P], AggregateGraficoBeneficiario[P]>
  }




  export type GraficoBeneficiarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GraficoBeneficiarioWhereInput
    orderBy?: GraficoBeneficiarioOrderByWithAggregationInput | GraficoBeneficiarioOrderByWithAggregationInput[]
    by: GraficoBeneficiarioScalarFieldEnum[] | GraficoBeneficiarioScalarFieldEnum
    having?: GraficoBeneficiarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GraficoBeneficiarioCountAggregateInputType | true
    _avg?: GraficoBeneficiarioAvgAggregateInputType
    _sum?: GraficoBeneficiarioSumAggregateInputType
    _min?: GraficoBeneficiarioMinAggregateInputType
    _max?: GraficoBeneficiarioMaxAggregateInputType
  }

  export type GraficoBeneficiarioGroupByOutputType = {
    id: number
    label: string
    valor: number
    dashboardId: number
    _count: GraficoBeneficiarioCountAggregateOutputType | null
    _avg: GraficoBeneficiarioAvgAggregateOutputType | null
    _sum: GraficoBeneficiarioSumAggregateOutputType | null
    _min: GraficoBeneficiarioMinAggregateOutputType | null
    _max: GraficoBeneficiarioMaxAggregateOutputType | null
  }

  type GetGraficoBeneficiarioGroupByPayload<T extends GraficoBeneficiarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GraficoBeneficiarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GraficoBeneficiarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GraficoBeneficiarioGroupByOutputType[P]>
            : GetScalarType<T[P], GraficoBeneficiarioGroupByOutputType[P]>
        }
      >
    >


  export type GraficoBeneficiarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoBeneficiario"]>

  export type GraficoBeneficiarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoBeneficiario"]>

  export type GraficoBeneficiarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["graficoBeneficiario"]>

  export type GraficoBeneficiarioSelectScalar = {
    id?: boolean
    label?: boolean
    valor?: boolean
    dashboardId?: boolean
  }

  export type GraficoBeneficiarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "valor" | "dashboardId", ExtArgs["result"]["graficoBeneficiario"]>
  export type GraficoBeneficiarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type GraficoBeneficiarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type GraficoBeneficiarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }

  export type $GraficoBeneficiarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GraficoBeneficiario"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      valor: number
      dashboardId: number
    }, ExtArgs["result"]["graficoBeneficiario"]>
    composites: {}
  }

  type GraficoBeneficiarioGetPayload<S extends boolean | null | undefined | GraficoBeneficiarioDefaultArgs> = $Result.GetResult<Prisma.$GraficoBeneficiarioPayload, S>

  type GraficoBeneficiarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GraficoBeneficiarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GraficoBeneficiarioCountAggregateInputType | true
    }

  export interface GraficoBeneficiarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GraficoBeneficiario'], meta: { name: 'GraficoBeneficiario' } }
    /**
     * Find zero or one GraficoBeneficiario that matches the filter.
     * @param {GraficoBeneficiarioFindUniqueArgs} args - Arguments to find a GraficoBeneficiario
     * @example
     * // Get one GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GraficoBeneficiarioFindUniqueArgs>(args: SelectSubset<T, GraficoBeneficiarioFindUniqueArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GraficoBeneficiario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GraficoBeneficiarioFindUniqueOrThrowArgs} args - Arguments to find a GraficoBeneficiario
     * @example
     * // Get one GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GraficoBeneficiarioFindUniqueOrThrowArgs>(args: SelectSubset<T, GraficoBeneficiarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GraficoBeneficiario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioFindFirstArgs} args - Arguments to find a GraficoBeneficiario
     * @example
     * // Get one GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GraficoBeneficiarioFindFirstArgs>(args?: SelectSubset<T, GraficoBeneficiarioFindFirstArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GraficoBeneficiario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioFindFirstOrThrowArgs} args - Arguments to find a GraficoBeneficiario
     * @example
     * // Get one GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GraficoBeneficiarioFindFirstOrThrowArgs>(args?: SelectSubset<T, GraficoBeneficiarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GraficoBeneficiarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GraficoBeneficiarios
     * const graficoBeneficiarios = await prisma.graficoBeneficiario.findMany()
     * 
     * // Get first 10 GraficoBeneficiarios
     * const graficoBeneficiarios = await prisma.graficoBeneficiario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const graficoBeneficiarioWithIdOnly = await prisma.graficoBeneficiario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GraficoBeneficiarioFindManyArgs>(args?: SelectSubset<T, GraficoBeneficiarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GraficoBeneficiario.
     * @param {GraficoBeneficiarioCreateArgs} args - Arguments to create a GraficoBeneficiario.
     * @example
     * // Create one GraficoBeneficiario
     * const GraficoBeneficiario = await prisma.graficoBeneficiario.create({
     *   data: {
     *     // ... data to create a GraficoBeneficiario
     *   }
     * })
     * 
     */
    create<T extends GraficoBeneficiarioCreateArgs>(args: SelectSubset<T, GraficoBeneficiarioCreateArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GraficoBeneficiarios.
     * @param {GraficoBeneficiarioCreateManyArgs} args - Arguments to create many GraficoBeneficiarios.
     * @example
     * // Create many GraficoBeneficiarios
     * const graficoBeneficiario = await prisma.graficoBeneficiario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GraficoBeneficiarioCreateManyArgs>(args?: SelectSubset<T, GraficoBeneficiarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GraficoBeneficiarios and returns the data saved in the database.
     * @param {GraficoBeneficiarioCreateManyAndReturnArgs} args - Arguments to create many GraficoBeneficiarios.
     * @example
     * // Create many GraficoBeneficiarios
     * const graficoBeneficiario = await prisma.graficoBeneficiario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GraficoBeneficiarios and only return the `id`
     * const graficoBeneficiarioWithIdOnly = await prisma.graficoBeneficiario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GraficoBeneficiarioCreateManyAndReturnArgs>(args?: SelectSubset<T, GraficoBeneficiarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GraficoBeneficiario.
     * @param {GraficoBeneficiarioDeleteArgs} args - Arguments to delete one GraficoBeneficiario.
     * @example
     * // Delete one GraficoBeneficiario
     * const GraficoBeneficiario = await prisma.graficoBeneficiario.delete({
     *   where: {
     *     // ... filter to delete one GraficoBeneficiario
     *   }
     * })
     * 
     */
    delete<T extends GraficoBeneficiarioDeleteArgs>(args: SelectSubset<T, GraficoBeneficiarioDeleteArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GraficoBeneficiario.
     * @param {GraficoBeneficiarioUpdateArgs} args - Arguments to update one GraficoBeneficiario.
     * @example
     * // Update one GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GraficoBeneficiarioUpdateArgs>(args: SelectSubset<T, GraficoBeneficiarioUpdateArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GraficoBeneficiarios.
     * @param {GraficoBeneficiarioDeleteManyArgs} args - Arguments to filter GraficoBeneficiarios to delete.
     * @example
     * // Delete a few GraficoBeneficiarios
     * const { count } = await prisma.graficoBeneficiario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GraficoBeneficiarioDeleteManyArgs>(args?: SelectSubset<T, GraficoBeneficiarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GraficoBeneficiarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GraficoBeneficiarios
     * const graficoBeneficiario = await prisma.graficoBeneficiario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GraficoBeneficiarioUpdateManyArgs>(args: SelectSubset<T, GraficoBeneficiarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GraficoBeneficiarios and returns the data updated in the database.
     * @param {GraficoBeneficiarioUpdateManyAndReturnArgs} args - Arguments to update many GraficoBeneficiarios.
     * @example
     * // Update many GraficoBeneficiarios
     * const graficoBeneficiario = await prisma.graficoBeneficiario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GraficoBeneficiarios and only return the `id`
     * const graficoBeneficiarioWithIdOnly = await prisma.graficoBeneficiario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GraficoBeneficiarioUpdateManyAndReturnArgs>(args: SelectSubset<T, GraficoBeneficiarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GraficoBeneficiario.
     * @param {GraficoBeneficiarioUpsertArgs} args - Arguments to update or create a GraficoBeneficiario.
     * @example
     * // Update or create a GraficoBeneficiario
     * const graficoBeneficiario = await prisma.graficoBeneficiario.upsert({
     *   create: {
     *     // ... data to create a GraficoBeneficiario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GraficoBeneficiario we want to update
     *   }
     * })
     */
    upsert<T extends GraficoBeneficiarioUpsertArgs>(args: SelectSubset<T, GraficoBeneficiarioUpsertArgs<ExtArgs>>): Prisma__GraficoBeneficiarioClient<$Result.GetResult<Prisma.$GraficoBeneficiarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GraficoBeneficiarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioCountArgs} args - Arguments to filter GraficoBeneficiarios to count.
     * @example
     * // Count the number of GraficoBeneficiarios
     * const count = await prisma.graficoBeneficiario.count({
     *   where: {
     *     // ... the filter for the GraficoBeneficiarios we want to count
     *   }
     * })
    **/
    count<T extends GraficoBeneficiarioCountArgs>(
      args?: Subset<T, GraficoBeneficiarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GraficoBeneficiarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GraficoBeneficiario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GraficoBeneficiarioAggregateArgs>(args: Subset<T, GraficoBeneficiarioAggregateArgs>): Prisma.PrismaPromise<GetGraficoBeneficiarioAggregateType<T>>

    /**
     * Group by GraficoBeneficiario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GraficoBeneficiarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GraficoBeneficiarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GraficoBeneficiarioGroupByArgs['orderBy'] }
        : { orderBy?: GraficoBeneficiarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GraficoBeneficiarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGraficoBeneficiarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GraficoBeneficiario model
   */
  readonly fields: GraficoBeneficiarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GraficoBeneficiario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GraficoBeneficiarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardDefaultArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GraficoBeneficiario model
   */
  interface GraficoBeneficiarioFieldRefs {
    readonly id: FieldRef<"GraficoBeneficiario", 'Int'>
    readonly label: FieldRef<"GraficoBeneficiario", 'String'>
    readonly valor: FieldRef<"GraficoBeneficiario", 'Int'>
    readonly dashboardId: FieldRef<"GraficoBeneficiario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GraficoBeneficiario findUnique
   */
  export type GraficoBeneficiarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter, which GraficoBeneficiario to fetch.
     */
    where: GraficoBeneficiarioWhereUniqueInput
  }

  /**
   * GraficoBeneficiario findUniqueOrThrow
   */
  export type GraficoBeneficiarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter, which GraficoBeneficiario to fetch.
     */
    where: GraficoBeneficiarioWhereUniqueInput
  }

  /**
   * GraficoBeneficiario findFirst
   */
  export type GraficoBeneficiarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter, which GraficoBeneficiario to fetch.
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoBeneficiarios to fetch.
     */
    orderBy?: GraficoBeneficiarioOrderByWithRelationInput | GraficoBeneficiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GraficoBeneficiarios.
     */
    cursor?: GraficoBeneficiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoBeneficiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoBeneficiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GraficoBeneficiarios.
     */
    distinct?: GraficoBeneficiarioScalarFieldEnum | GraficoBeneficiarioScalarFieldEnum[]
  }

  /**
   * GraficoBeneficiario findFirstOrThrow
   */
  export type GraficoBeneficiarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter, which GraficoBeneficiario to fetch.
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoBeneficiarios to fetch.
     */
    orderBy?: GraficoBeneficiarioOrderByWithRelationInput | GraficoBeneficiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GraficoBeneficiarios.
     */
    cursor?: GraficoBeneficiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoBeneficiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoBeneficiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GraficoBeneficiarios.
     */
    distinct?: GraficoBeneficiarioScalarFieldEnum | GraficoBeneficiarioScalarFieldEnum[]
  }

  /**
   * GraficoBeneficiario findMany
   */
  export type GraficoBeneficiarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter, which GraficoBeneficiarios to fetch.
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GraficoBeneficiarios to fetch.
     */
    orderBy?: GraficoBeneficiarioOrderByWithRelationInput | GraficoBeneficiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GraficoBeneficiarios.
     */
    cursor?: GraficoBeneficiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GraficoBeneficiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GraficoBeneficiarios.
     */
    skip?: number
    distinct?: GraficoBeneficiarioScalarFieldEnum | GraficoBeneficiarioScalarFieldEnum[]
  }

  /**
   * GraficoBeneficiario create
   */
  export type GraficoBeneficiarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * The data needed to create a GraficoBeneficiario.
     */
    data: XOR<GraficoBeneficiarioCreateInput, GraficoBeneficiarioUncheckedCreateInput>
  }

  /**
   * GraficoBeneficiario createMany
   */
  export type GraficoBeneficiarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GraficoBeneficiarios.
     */
    data: GraficoBeneficiarioCreateManyInput | GraficoBeneficiarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GraficoBeneficiario createManyAndReturn
   */
  export type GraficoBeneficiarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * The data used to create many GraficoBeneficiarios.
     */
    data: GraficoBeneficiarioCreateManyInput | GraficoBeneficiarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GraficoBeneficiario update
   */
  export type GraficoBeneficiarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * The data needed to update a GraficoBeneficiario.
     */
    data: XOR<GraficoBeneficiarioUpdateInput, GraficoBeneficiarioUncheckedUpdateInput>
    /**
     * Choose, which GraficoBeneficiario to update.
     */
    where: GraficoBeneficiarioWhereUniqueInput
  }

  /**
   * GraficoBeneficiario updateMany
   */
  export type GraficoBeneficiarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GraficoBeneficiarios.
     */
    data: XOR<GraficoBeneficiarioUpdateManyMutationInput, GraficoBeneficiarioUncheckedUpdateManyInput>
    /**
     * Filter which GraficoBeneficiarios to update
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * Limit how many GraficoBeneficiarios to update.
     */
    limit?: number
  }

  /**
   * GraficoBeneficiario updateManyAndReturn
   */
  export type GraficoBeneficiarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * The data used to update GraficoBeneficiarios.
     */
    data: XOR<GraficoBeneficiarioUpdateManyMutationInput, GraficoBeneficiarioUncheckedUpdateManyInput>
    /**
     * Filter which GraficoBeneficiarios to update
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * Limit how many GraficoBeneficiarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GraficoBeneficiario upsert
   */
  export type GraficoBeneficiarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * The filter to search for the GraficoBeneficiario to update in case it exists.
     */
    where: GraficoBeneficiarioWhereUniqueInput
    /**
     * In case the GraficoBeneficiario found by the `where` argument doesn't exist, create a new GraficoBeneficiario with this data.
     */
    create: XOR<GraficoBeneficiarioCreateInput, GraficoBeneficiarioUncheckedCreateInput>
    /**
     * In case the GraficoBeneficiario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GraficoBeneficiarioUpdateInput, GraficoBeneficiarioUncheckedUpdateInput>
  }

  /**
   * GraficoBeneficiario delete
   */
  export type GraficoBeneficiarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
    /**
     * Filter which GraficoBeneficiario to delete.
     */
    where: GraficoBeneficiarioWhereUniqueInput
  }

  /**
   * GraficoBeneficiario deleteMany
   */
  export type GraficoBeneficiarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GraficoBeneficiarios to delete
     */
    where?: GraficoBeneficiarioWhereInput
    /**
     * Limit how many GraficoBeneficiarios to delete.
     */
    limit?: number
  }

  /**
   * GraficoBeneficiario without action
   */
  export type GraficoBeneficiarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GraficoBeneficiario
     */
    select?: GraficoBeneficiarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GraficoBeneficiario
     */
    omit?: GraficoBeneficiarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GraficoBeneficiarioInclude<ExtArgs> | null
  }


  /**
   * Model Curso
   */

  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  export type CursoAvgAggregateOutputType = {
    id: number | null
  }

  export type CursoSumAggregateOutputType = {
    id: number | null
  }

  export type CursoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
    modalidade: string | null
    criadoEm: Date | null
  }

  export type CursoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
    modalidade: string | null
    criadoEm: Date | null
  }

  export type CursoCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    modalidade: number
    criadoEm: number
    _all: number
  }


  export type CursoAvgAggregateInputType = {
    id?: true
  }

  export type CursoSumAggregateInputType = {
    id?: true
  }

  export type CursoMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    modalidade?: true
    criadoEm?: true
  }

  export type CursoMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    modalidade?: true
    criadoEm?: true
  }

  export type CursoCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    modalidade?: true
    criadoEm?: true
    _all?: true
  }

  export type CursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curso to aggregate.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursos
    **/
    _count?: true | CursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMaxAggregateInputType
  }

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>
  }




  export type CursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithAggregationInput | CursoOrderByWithAggregationInput[]
    by: CursoScalarFieldEnum[] | CursoScalarFieldEnum
    having?: CursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCountAggregateInputType | true
    _avg?: CursoAvgAggregateInputType
    _sum?: CursoSumAggregateInputType
    _min?: CursoMinAggregateInputType
    _max?: CursoMaxAggregateInputType
  }

  export type CursoGroupByOutputType = {
    id: number
    nome: string
    descricao: string
    modalidade: string
    criadoEm: Date
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoGroupByOutputType[P]>
        }
      >
    >


  export type CursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    modalidade?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["curso"]>

  export type CursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    modalidade?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["curso"]>

  export type CursoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    modalidade?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["curso"]>

  export type CursoSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
    modalidade?: boolean
    criadoEm?: boolean
  }

  export type CursoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "descricao" | "modalidade" | "criadoEm", ExtArgs["result"]["curso"]>

  export type $CursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Curso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      descricao: string
      modalidade: string
      criadoEm: Date
    }, ExtArgs["result"]["curso"]>
    composites: {}
  }

  type CursoGetPayload<S extends boolean | null | undefined | CursoDefaultArgs> = $Result.GetResult<Prisma.$CursoPayload, S>

  type CursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CursoCountAggregateInputType | true
    }

  export interface CursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Curso'], meta: { name: 'Curso' } }
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoFindUniqueArgs>(args: SelectSubset<T, CursoFindUniqueArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Curso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CursoFindUniqueOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoFindFirstArgs>(args?: SelectSubset<T, CursoFindFirstArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Curso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursoFindManyArgs>(args?: SelectSubset<T, CursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     * 
     */
    create<T extends CursoCreateArgs>(args: SelectSubset<T, CursoCreateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cursos.
     * @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoCreateManyArgs>(args?: SelectSubset<T, CursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cursos and returns the data saved in the database.
     * @param {CursoCreateManyAndReturnArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cursos and only return the `id`
     * const cursoWithIdOnly = await prisma.curso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CursoCreateManyAndReturnArgs>(args?: SelectSubset<T, CursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     * 
     */
    delete<T extends CursoDeleteArgs>(args: SelectSubset<T, CursoDeleteArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoUpdateArgs>(args: SelectSubset<T, CursoUpdateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoDeleteManyArgs>(args?: SelectSubset<T, CursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoUpdateManyArgs>(args: SelectSubset<T, CursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos and returns the data updated in the database.
     * @param {CursoUpdateManyAndReturnArgs} args - Arguments to update many Cursos.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cursos and only return the `id`
     * const cursoWithIdOnly = await prisma.curso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CursoUpdateManyAndReturnArgs>(args: SelectSubset<T, CursoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
     */
    upsert<T extends CursoUpsertArgs>(args: SelectSubset<T, CursoUpsertArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoAggregateArgs>(args: Subset<T, CursoAggregateArgs>): Prisma.PrismaPromise<GetCursoAggregateType<T>>

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Curso model
   */
  readonly fields: CursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Curso model
   */
  interface CursoFieldRefs {
    readonly id: FieldRef<"Curso", 'Int'>
    readonly nome: FieldRef<"Curso", 'String'>
    readonly descricao: FieldRef<"Curso", 'String'>
    readonly modalidade: FieldRef<"Curso", 'String'>
    readonly criadoEm: FieldRef<"Curso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findUniqueOrThrow
   */
  export type CursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findFirstOrThrow
   */
  export type CursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findMany
   */
  export type CursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter, which Cursos to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso create
   */
  export type CursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * The data needed to create a Curso.
     */
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>
  }

  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curso createManyAndReturn
   */
  export type CursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curso update
   */
  export type CursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * The data needed to update a Curso.
     */
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
    /**
     * Choose, which Curso to update.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput
    /**
     * Limit how many Cursos to update.
     */
    limit?: number
  }

  /**
   * Curso updateManyAndReturn
   */
  export type CursoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput
    /**
     * Limit how many Cursos to update.
     */
    limit?: number
  }

  /**
   * Curso upsert
   */
  export type CursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * The filter to search for the Curso to update in case it exists.
     */
    where: CursoWhereUniqueInput
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     */
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
  }

  /**
   * Curso delete
   */
  export type CursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Filter which Curso to delete.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cursos to delete
     */
    where?: CursoWhereInput
    /**
     * Limit how many Cursos to delete.
     */
    limit?: number
  }

  /**
   * Curso without action
   */
  export type CursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
  }


  /**
   * Model coordenador
   */

  export type AggregateCoordenador = {
    _count: CoordenadorCountAggregateOutputType | null
    _avg: CoordenadorAvgAggregateOutputType | null
    _sum: CoordenadorSumAggregateOutputType | null
    _min: CoordenadorMinAggregateOutputType | null
    _max: CoordenadorMaxAggregateOutputType | null
  }

  export type CoordenadorAvgAggregateOutputType = {
    id: number | null
  }

  export type CoordenadorSumAggregateOutputType = {
    id: number | null
  }

  export type CoordenadorMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    telefone: string | null
    cpf: string | null
    status: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CoordenadorMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    telefone: string | null
    cpf: string | null
    status: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CoordenadorCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    telefone: number
    cpf: number
    status: number
    cursos: number
    criadoEm: number
    atualizadoEm: number
    permissoes: number
    _all: number
  }


  export type CoordenadorAvgAggregateInputType = {
    id?: true
  }

  export type CoordenadorSumAggregateInputType = {
    id?: true
  }

  export type CoordenadorMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    cpf?: true
    status?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CoordenadorMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    cpf?: true
    status?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CoordenadorCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    cpf?: true
    status?: true
    cursos?: true
    criadoEm?: true
    atualizadoEm?: true
    permissoes?: true
    _all?: true
  }

  export type CoordenadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coordenador to aggregate.
     */
    where?: coordenadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coordenadors to fetch.
     */
    orderBy?: coordenadorOrderByWithRelationInput | coordenadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coordenadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coordenadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coordenadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coordenadors
    **/
    _count?: true | CoordenadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoordenadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoordenadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoordenadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoordenadorMaxAggregateInputType
  }

  export type GetCoordenadorAggregateType<T extends CoordenadorAggregateArgs> = {
        [P in keyof T & keyof AggregateCoordenador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoordenador[P]>
      : GetScalarType<T[P], AggregateCoordenador[P]>
  }




  export type coordenadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coordenadorWhereInput
    orderBy?: coordenadorOrderByWithAggregationInput | coordenadorOrderByWithAggregationInput[]
    by: CoordenadorScalarFieldEnum[] | CoordenadorScalarFieldEnum
    having?: coordenadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoordenadorCountAggregateInputType | true
    _avg?: CoordenadorAvgAggregateInputType
    _sum?: CoordenadorSumAggregateInputType
    _min?: CoordenadorMinAggregateInputType
    _max?: CoordenadorMaxAggregateInputType
  }

  export type CoordenadorGroupByOutputType = {
    id: number
    nome: string
    email: string
    telefone: string | null
    cpf: string | null
    status: string | null
    cursos: string[]
    criadoEm: Date
    atualizadoEm: Date
    permissoes: JsonValue | null
    _count: CoordenadorCountAggregateOutputType | null
    _avg: CoordenadorAvgAggregateOutputType | null
    _sum: CoordenadorSumAggregateOutputType | null
    _min: CoordenadorMinAggregateOutputType | null
    _max: CoordenadorMaxAggregateOutputType | null
  }

  type GetCoordenadorGroupByPayload<T extends coordenadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoordenadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoordenadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoordenadorGroupByOutputType[P]>
            : GetScalarType<T[P], CoordenadorGroupByOutputType[P]>
        }
      >
    >


  export type coordenadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    cpf?: boolean
    status?: boolean
    cursos?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    permissoes?: boolean
  }, ExtArgs["result"]["coordenador"]>

  export type coordenadorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    cpf?: boolean
    status?: boolean
    cursos?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    permissoes?: boolean
  }, ExtArgs["result"]["coordenador"]>

  export type coordenadorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    cpf?: boolean
    status?: boolean
    cursos?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    permissoes?: boolean
  }, ExtArgs["result"]["coordenador"]>

  export type coordenadorSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    cpf?: boolean
    status?: boolean
    cursos?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    permissoes?: boolean
  }

  export type coordenadorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "email" | "telefone" | "cpf" | "status" | "cursos" | "criadoEm" | "atualizadoEm" | "permissoes", ExtArgs["result"]["coordenador"]>

  export type $coordenadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coordenador"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      telefone: string | null
      cpf: string | null
      status: string | null
      cursos: string[]
      criadoEm: Date
      atualizadoEm: Date
      permissoes: Prisma.JsonValue | null
    }, ExtArgs["result"]["coordenador"]>
    composites: {}
  }

  type coordenadorGetPayload<S extends boolean | null | undefined | coordenadorDefaultArgs> = $Result.GetResult<Prisma.$coordenadorPayload, S>

  type coordenadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coordenadorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoordenadorCountAggregateInputType | true
    }

  export interface coordenadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coordenador'], meta: { name: 'coordenador' } }
    /**
     * Find zero or one Coordenador that matches the filter.
     * @param {coordenadorFindUniqueArgs} args - Arguments to find a Coordenador
     * @example
     * // Get one Coordenador
     * const coordenador = await prisma.coordenador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coordenadorFindUniqueArgs>(args: SelectSubset<T, coordenadorFindUniqueArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coordenador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coordenadorFindUniqueOrThrowArgs} args - Arguments to find a Coordenador
     * @example
     * // Get one Coordenador
     * const coordenador = await prisma.coordenador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coordenadorFindUniqueOrThrowArgs>(args: SelectSubset<T, coordenadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coordenador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorFindFirstArgs} args - Arguments to find a Coordenador
     * @example
     * // Get one Coordenador
     * const coordenador = await prisma.coordenador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coordenadorFindFirstArgs>(args?: SelectSubset<T, coordenadorFindFirstArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coordenador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorFindFirstOrThrowArgs} args - Arguments to find a Coordenador
     * @example
     * // Get one Coordenador
     * const coordenador = await prisma.coordenador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coordenadorFindFirstOrThrowArgs>(args?: SelectSubset<T, coordenadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coordenadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coordenadors
     * const coordenadors = await prisma.coordenador.findMany()
     * 
     * // Get first 10 Coordenadors
     * const coordenadors = await prisma.coordenador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coordenadorWithIdOnly = await prisma.coordenador.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coordenadorFindManyArgs>(args?: SelectSubset<T, coordenadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coordenador.
     * @param {coordenadorCreateArgs} args - Arguments to create a Coordenador.
     * @example
     * // Create one Coordenador
     * const Coordenador = await prisma.coordenador.create({
     *   data: {
     *     // ... data to create a Coordenador
     *   }
     * })
     * 
     */
    create<T extends coordenadorCreateArgs>(args: SelectSubset<T, coordenadorCreateArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coordenadors.
     * @param {coordenadorCreateManyArgs} args - Arguments to create many Coordenadors.
     * @example
     * // Create many Coordenadors
     * const coordenador = await prisma.coordenador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coordenadorCreateManyArgs>(args?: SelectSubset<T, coordenadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coordenadors and returns the data saved in the database.
     * @param {coordenadorCreateManyAndReturnArgs} args - Arguments to create many Coordenadors.
     * @example
     * // Create many Coordenadors
     * const coordenador = await prisma.coordenador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coordenadors and only return the `id`
     * const coordenadorWithIdOnly = await prisma.coordenador.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends coordenadorCreateManyAndReturnArgs>(args?: SelectSubset<T, coordenadorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coordenador.
     * @param {coordenadorDeleteArgs} args - Arguments to delete one Coordenador.
     * @example
     * // Delete one Coordenador
     * const Coordenador = await prisma.coordenador.delete({
     *   where: {
     *     // ... filter to delete one Coordenador
     *   }
     * })
     * 
     */
    delete<T extends coordenadorDeleteArgs>(args: SelectSubset<T, coordenadorDeleteArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coordenador.
     * @param {coordenadorUpdateArgs} args - Arguments to update one Coordenador.
     * @example
     * // Update one Coordenador
     * const coordenador = await prisma.coordenador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coordenadorUpdateArgs>(args: SelectSubset<T, coordenadorUpdateArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coordenadors.
     * @param {coordenadorDeleteManyArgs} args - Arguments to filter Coordenadors to delete.
     * @example
     * // Delete a few Coordenadors
     * const { count } = await prisma.coordenador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coordenadorDeleteManyArgs>(args?: SelectSubset<T, coordenadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coordenadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coordenadors
     * const coordenador = await prisma.coordenador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coordenadorUpdateManyArgs>(args: SelectSubset<T, coordenadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coordenadors and returns the data updated in the database.
     * @param {coordenadorUpdateManyAndReturnArgs} args - Arguments to update many Coordenadors.
     * @example
     * // Update many Coordenadors
     * const coordenador = await prisma.coordenador.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coordenadors and only return the `id`
     * const coordenadorWithIdOnly = await prisma.coordenador.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends coordenadorUpdateManyAndReturnArgs>(args: SelectSubset<T, coordenadorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coordenador.
     * @param {coordenadorUpsertArgs} args - Arguments to update or create a Coordenador.
     * @example
     * // Update or create a Coordenador
     * const coordenador = await prisma.coordenador.upsert({
     *   create: {
     *     // ... data to create a Coordenador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coordenador we want to update
     *   }
     * })
     */
    upsert<T extends coordenadorUpsertArgs>(args: SelectSubset<T, coordenadorUpsertArgs<ExtArgs>>): Prisma__coordenadorClient<$Result.GetResult<Prisma.$coordenadorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coordenadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorCountArgs} args - Arguments to filter Coordenadors to count.
     * @example
     * // Count the number of Coordenadors
     * const count = await prisma.coordenador.count({
     *   where: {
     *     // ... the filter for the Coordenadors we want to count
     *   }
     * })
    **/
    count<T extends coordenadorCountArgs>(
      args?: Subset<T, coordenadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoordenadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coordenador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordenadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoordenadorAggregateArgs>(args: Subset<T, CoordenadorAggregateArgs>): Prisma.PrismaPromise<GetCoordenadorAggregateType<T>>

    /**
     * Group by Coordenador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coordenadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coordenadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coordenadorGroupByArgs['orderBy'] }
        : { orderBy?: coordenadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coordenadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoordenadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coordenador model
   */
  readonly fields: coordenadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coordenador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coordenadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coordenador model
   */
  interface coordenadorFieldRefs {
    readonly id: FieldRef<"coordenador", 'Int'>
    readonly nome: FieldRef<"coordenador", 'String'>
    readonly email: FieldRef<"coordenador", 'String'>
    readonly telefone: FieldRef<"coordenador", 'String'>
    readonly cpf: FieldRef<"coordenador", 'String'>
    readonly status: FieldRef<"coordenador", 'String'>
    readonly cursos: FieldRef<"coordenador", 'String[]'>
    readonly criadoEm: FieldRef<"coordenador", 'DateTime'>
    readonly atualizadoEm: FieldRef<"coordenador", 'DateTime'>
    readonly permissoes: FieldRef<"coordenador", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * coordenador findUnique
   */
  export type coordenadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter, which coordenador to fetch.
     */
    where: coordenadorWhereUniqueInput
  }

  /**
   * coordenador findUniqueOrThrow
   */
  export type coordenadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter, which coordenador to fetch.
     */
    where: coordenadorWhereUniqueInput
  }

  /**
   * coordenador findFirst
   */
  export type coordenadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter, which coordenador to fetch.
     */
    where?: coordenadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coordenadors to fetch.
     */
    orderBy?: coordenadorOrderByWithRelationInput | coordenadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coordenadors.
     */
    cursor?: coordenadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coordenadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coordenadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coordenadors.
     */
    distinct?: CoordenadorScalarFieldEnum | CoordenadorScalarFieldEnum[]
  }

  /**
   * coordenador findFirstOrThrow
   */
  export type coordenadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter, which coordenador to fetch.
     */
    where?: coordenadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coordenadors to fetch.
     */
    orderBy?: coordenadorOrderByWithRelationInput | coordenadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coordenadors.
     */
    cursor?: coordenadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coordenadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coordenadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coordenadors.
     */
    distinct?: CoordenadorScalarFieldEnum | CoordenadorScalarFieldEnum[]
  }

  /**
   * coordenador findMany
   */
  export type coordenadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter, which coordenadors to fetch.
     */
    where?: coordenadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coordenadors to fetch.
     */
    orderBy?: coordenadorOrderByWithRelationInput | coordenadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coordenadors.
     */
    cursor?: coordenadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coordenadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coordenadors.
     */
    skip?: number
    distinct?: CoordenadorScalarFieldEnum | CoordenadorScalarFieldEnum[]
  }

  /**
   * coordenador create
   */
  export type coordenadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * The data needed to create a coordenador.
     */
    data: XOR<coordenadorCreateInput, coordenadorUncheckedCreateInput>
  }

  /**
   * coordenador createMany
   */
  export type coordenadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coordenadors.
     */
    data: coordenadorCreateManyInput | coordenadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coordenador createManyAndReturn
   */
  export type coordenadorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * The data used to create many coordenadors.
     */
    data: coordenadorCreateManyInput | coordenadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coordenador update
   */
  export type coordenadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * The data needed to update a coordenador.
     */
    data: XOR<coordenadorUpdateInput, coordenadorUncheckedUpdateInput>
    /**
     * Choose, which coordenador to update.
     */
    where: coordenadorWhereUniqueInput
  }

  /**
   * coordenador updateMany
   */
  export type coordenadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coordenadors.
     */
    data: XOR<coordenadorUpdateManyMutationInput, coordenadorUncheckedUpdateManyInput>
    /**
     * Filter which coordenadors to update
     */
    where?: coordenadorWhereInput
    /**
     * Limit how many coordenadors to update.
     */
    limit?: number
  }

  /**
   * coordenador updateManyAndReturn
   */
  export type coordenadorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * The data used to update coordenadors.
     */
    data: XOR<coordenadorUpdateManyMutationInput, coordenadorUncheckedUpdateManyInput>
    /**
     * Filter which coordenadors to update
     */
    where?: coordenadorWhereInput
    /**
     * Limit how many coordenadors to update.
     */
    limit?: number
  }

  /**
   * coordenador upsert
   */
  export type coordenadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * The filter to search for the coordenador to update in case it exists.
     */
    where: coordenadorWhereUniqueInput
    /**
     * In case the coordenador found by the `where` argument doesn't exist, create a new coordenador with this data.
     */
    create: XOR<coordenadorCreateInput, coordenadorUncheckedCreateInput>
    /**
     * In case the coordenador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coordenadorUpdateInput, coordenadorUncheckedUpdateInput>
  }

  /**
   * coordenador delete
   */
  export type coordenadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
    /**
     * Filter which coordenador to delete.
     */
    where: coordenadorWhereUniqueInput
  }

  /**
   * coordenador deleteMany
   */
  export type coordenadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coordenadors to delete
     */
    where?: coordenadorWhereInput
    /**
     * Limit how many coordenadors to delete.
     */
    limit?: number
  }

  /**
   * coordenador without action
   */
  export type coordenadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coordenador
     */
    select?: coordenadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coordenador
     */
    omit?: coordenadorOmit<ExtArgs> | null
  }


  /**
   * Model Agendamento
   */

  export type AggregateAgendamento = {
    _count: AgendamentoCountAggregateOutputType | null
    _min: AgendamentoMinAggregateOutputType | null
    _max: AgendamentoMaxAggregateOutputType | null
  }

  export type AgendamentoMinAggregateOutputType = {
    id: string | null
    beneficiario: string | null
    programa: string | null
    tipo: string | null
    aluno: string | null
    data: Date | null
    turno: string | null
    status: string | null
    criadoEm: Date | null
  }

  export type AgendamentoMaxAggregateOutputType = {
    id: string | null
    beneficiario: string | null
    programa: string | null
    tipo: string | null
    aluno: string | null
    data: Date | null
    turno: string | null
    status: string | null
    criadoEm: Date | null
  }

  export type AgendamentoCountAggregateOutputType = {
    id: number
    beneficiario: number
    programa: number
    tipo: number
    aluno: number
    data: number
    turno: number
    status: number
    criadoEm: number
    _all: number
  }


  export type AgendamentoMinAggregateInputType = {
    id?: true
    beneficiario?: true
    programa?: true
    tipo?: true
    aluno?: true
    data?: true
    turno?: true
    status?: true
    criadoEm?: true
  }

  export type AgendamentoMaxAggregateInputType = {
    id?: true
    beneficiario?: true
    programa?: true
    tipo?: true
    aluno?: true
    data?: true
    turno?: true
    status?: true
    criadoEm?: true
  }

  export type AgendamentoCountAggregateInputType = {
    id?: true
    beneficiario?: true
    programa?: true
    tipo?: true
    aluno?: true
    data?: true
    turno?: true
    status?: true
    criadoEm?: true
    _all?: true
  }

  export type AgendamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agendamento to aggregate.
     */
    where?: AgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendamentos to fetch.
     */
    orderBy?: AgendamentoOrderByWithRelationInput | AgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agendamentos
    **/
    _count?: true | AgendamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendamentoMaxAggregateInputType
  }

  export type GetAgendamentoAggregateType<T extends AgendamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendamento[P]>
      : GetScalarType<T[P], AggregateAgendamento[P]>
  }




  export type AgendamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendamentoWhereInput
    orderBy?: AgendamentoOrderByWithAggregationInput | AgendamentoOrderByWithAggregationInput[]
    by: AgendamentoScalarFieldEnum[] | AgendamentoScalarFieldEnum
    having?: AgendamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendamentoCountAggregateInputType | true
    _min?: AgendamentoMinAggregateInputType
    _max?: AgendamentoMaxAggregateInputType
  }

  export type AgendamentoGroupByOutputType = {
    id: string
    beneficiario: string
    programa: string
    tipo: string
    aluno: string
    data: Date
    turno: string
    status: string
    criadoEm: Date
    _count: AgendamentoCountAggregateOutputType | null
    _min: AgendamentoMinAggregateOutputType | null
    _max: AgendamentoMaxAggregateOutputType | null
  }

  type GetAgendamentoGroupByPayload<T extends AgendamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendamentoGroupByOutputType[P]>
            : GetScalarType<T[P], AgendamentoGroupByOutputType[P]>
        }
      >
    >


  export type AgendamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    beneficiario?: boolean
    programa?: boolean
    tipo?: boolean
    aluno?: boolean
    data?: boolean
    turno?: boolean
    status?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["agendamento"]>

  export type AgendamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    beneficiario?: boolean
    programa?: boolean
    tipo?: boolean
    aluno?: boolean
    data?: boolean
    turno?: boolean
    status?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["agendamento"]>

  export type AgendamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    beneficiario?: boolean
    programa?: boolean
    tipo?: boolean
    aluno?: boolean
    data?: boolean
    turno?: boolean
    status?: boolean
    criadoEm?: boolean
  }, ExtArgs["result"]["agendamento"]>

  export type AgendamentoSelectScalar = {
    id?: boolean
    beneficiario?: boolean
    programa?: boolean
    tipo?: boolean
    aluno?: boolean
    data?: boolean
    turno?: boolean
    status?: boolean
    criadoEm?: boolean
  }

  export type AgendamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "beneficiario" | "programa" | "tipo" | "aluno" | "data" | "turno" | "status" | "criadoEm", ExtArgs["result"]["agendamento"]>

  export type $AgendamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agendamento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      beneficiario: string
      programa: string
      tipo: string
      aluno: string
      data: Date
      turno: string
      status: string
      criadoEm: Date
    }, ExtArgs["result"]["agendamento"]>
    composites: {}
  }

  type AgendamentoGetPayload<S extends boolean | null | undefined | AgendamentoDefaultArgs> = $Result.GetResult<Prisma.$AgendamentoPayload, S>

  type AgendamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendamentoCountAggregateInputType | true
    }

  export interface AgendamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agendamento'], meta: { name: 'Agendamento' } }
    /**
     * Find zero or one Agendamento that matches the filter.
     * @param {AgendamentoFindUniqueArgs} args - Arguments to find a Agendamento
     * @example
     * // Get one Agendamento
     * const agendamento = await prisma.agendamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendamentoFindUniqueArgs>(args: SelectSubset<T, AgendamentoFindUniqueArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agendamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendamentoFindUniqueOrThrowArgs} args - Arguments to find a Agendamento
     * @example
     * // Get one Agendamento
     * const agendamento = await prisma.agendamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoFindFirstArgs} args - Arguments to find a Agendamento
     * @example
     * // Get one Agendamento
     * const agendamento = await prisma.agendamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendamentoFindFirstArgs>(args?: SelectSubset<T, AgendamentoFindFirstArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoFindFirstOrThrowArgs} args - Arguments to find a Agendamento
     * @example
     * // Get one Agendamento
     * const agendamento = await prisma.agendamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendamentos
     * const agendamentos = await prisma.agendamento.findMany()
     * 
     * // Get first 10 Agendamentos
     * const agendamentos = await prisma.agendamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendamentoWithIdOnly = await prisma.agendamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendamentoFindManyArgs>(args?: SelectSubset<T, AgendamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agendamento.
     * @param {AgendamentoCreateArgs} args - Arguments to create a Agendamento.
     * @example
     * // Create one Agendamento
     * const Agendamento = await prisma.agendamento.create({
     *   data: {
     *     // ... data to create a Agendamento
     *   }
     * })
     * 
     */
    create<T extends AgendamentoCreateArgs>(args: SelectSubset<T, AgendamentoCreateArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agendamentos.
     * @param {AgendamentoCreateManyArgs} args - Arguments to create many Agendamentos.
     * @example
     * // Create many Agendamentos
     * const agendamento = await prisma.agendamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendamentoCreateManyArgs>(args?: SelectSubset<T, AgendamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agendamentos and returns the data saved in the database.
     * @param {AgendamentoCreateManyAndReturnArgs} args - Arguments to create many Agendamentos.
     * @example
     * // Create many Agendamentos
     * const agendamento = await prisma.agendamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agendamentos and only return the `id`
     * const agendamentoWithIdOnly = await prisma.agendamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgendamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, AgendamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agendamento.
     * @param {AgendamentoDeleteArgs} args - Arguments to delete one Agendamento.
     * @example
     * // Delete one Agendamento
     * const Agendamento = await prisma.agendamento.delete({
     *   where: {
     *     // ... filter to delete one Agendamento
     *   }
     * })
     * 
     */
    delete<T extends AgendamentoDeleteArgs>(args: SelectSubset<T, AgendamentoDeleteArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agendamento.
     * @param {AgendamentoUpdateArgs} args - Arguments to update one Agendamento.
     * @example
     * // Update one Agendamento
     * const agendamento = await prisma.agendamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendamentoUpdateArgs>(args: SelectSubset<T, AgendamentoUpdateArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agendamentos.
     * @param {AgendamentoDeleteManyArgs} args - Arguments to filter Agendamentos to delete.
     * @example
     * // Delete a few Agendamentos
     * const { count } = await prisma.agendamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendamentoDeleteManyArgs>(args?: SelectSubset<T, AgendamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendamentos
     * const agendamento = await prisma.agendamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendamentoUpdateManyArgs>(args: SelectSubset<T, AgendamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendamentos and returns the data updated in the database.
     * @param {AgendamentoUpdateManyAndReturnArgs} args - Arguments to update many Agendamentos.
     * @example
     * // Update many Agendamentos
     * const agendamento = await prisma.agendamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agendamentos and only return the `id`
     * const agendamentoWithIdOnly = await prisma.agendamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgendamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, AgendamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agendamento.
     * @param {AgendamentoUpsertArgs} args - Arguments to update or create a Agendamento.
     * @example
     * // Update or create a Agendamento
     * const agendamento = await prisma.agendamento.upsert({
     *   create: {
     *     // ... data to create a Agendamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendamento we want to update
     *   }
     * })
     */
    upsert<T extends AgendamentoUpsertArgs>(args: SelectSubset<T, AgendamentoUpsertArgs<ExtArgs>>): Prisma__AgendamentoClient<$Result.GetResult<Prisma.$AgendamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoCountArgs} args - Arguments to filter Agendamentos to count.
     * @example
     * // Count the number of Agendamentos
     * const count = await prisma.agendamento.count({
     *   where: {
     *     // ... the filter for the Agendamentos we want to count
     *   }
     * })
    **/
    count<T extends AgendamentoCountArgs>(
      args?: Subset<T, AgendamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendamentoAggregateArgs>(args: Subset<T, AgendamentoAggregateArgs>): Prisma.PrismaPromise<GetAgendamentoAggregateType<T>>

    /**
     * Group by Agendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendamentoGroupByArgs['orderBy'] }
        : { orderBy?: AgendamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agendamento model
   */
  readonly fields: AgendamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agendamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agendamento model
   */
  interface AgendamentoFieldRefs {
    readonly id: FieldRef<"Agendamento", 'String'>
    readonly beneficiario: FieldRef<"Agendamento", 'String'>
    readonly programa: FieldRef<"Agendamento", 'String'>
    readonly tipo: FieldRef<"Agendamento", 'String'>
    readonly aluno: FieldRef<"Agendamento", 'String'>
    readonly data: FieldRef<"Agendamento", 'DateTime'>
    readonly turno: FieldRef<"Agendamento", 'String'>
    readonly status: FieldRef<"Agendamento", 'String'>
    readonly criadoEm: FieldRef<"Agendamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agendamento findUnique
   */
  export type AgendamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which Agendamento to fetch.
     */
    where: AgendamentoWhereUniqueInput
  }

  /**
   * Agendamento findUniqueOrThrow
   */
  export type AgendamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which Agendamento to fetch.
     */
    where: AgendamentoWhereUniqueInput
  }

  /**
   * Agendamento findFirst
   */
  export type AgendamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which Agendamento to fetch.
     */
    where?: AgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendamentos to fetch.
     */
    orderBy?: AgendamentoOrderByWithRelationInput | AgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agendamentos.
     */
    cursor?: AgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agendamentos.
     */
    distinct?: AgendamentoScalarFieldEnum | AgendamentoScalarFieldEnum[]
  }

  /**
   * Agendamento findFirstOrThrow
   */
  export type AgendamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which Agendamento to fetch.
     */
    where?: AgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendamentos to fetch.
     */
    orderBy?: AgendamentoOrderByWithRelationInput | AgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agendamentos.
     */
    cursor?: AgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agendamentos.
     */
    distinct?: AgendamentoScalarFieldEnum | AgendamentoScalarFieldEnum[]
  }

  /**
   * Agendamento findMany
   */
  export type AgendamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which Agendamentos to fetch.
     */
    where?: AgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendamentos to fetch.
     */
    orderBy?: AgendamentoOrderByWithRelationInput | AgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agendamentos.
     */
    cursor?: AgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendamentos.
     */
    skip?: number
    distinct?: AgendamentoScalarFieldEnum | AgendamentoScalarFieldEnum[]
  }

  /**
   * Agendamento create
   */
  export type AgendamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to create a Agendamento.
     */
    data: XOR<AgendamentoCreateInput, AgendamentoUncheckedCreateInput>
  }

  /**
   * Agendamento createMany
   */
  export type AgendamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agendamentos.
     */
    data: AgendamentoCreateManyInput | AgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agendamento createManyAndReturn
   */
  export type AgendamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * The data used to create many Agendamentos.
     */
    data: AgendamentoCreateManyInput | AgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agendamento update
   */
  export type AgendamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to update a Agendamento.
     */
    data: XOR<AgendamentoUpdateInput, AgendamentoUncheckedUpdateInput>
    /**
     * Choose, which Agendamento to update.
     */
    where: AgendamentoWhereUniqueInput
  }

  /**
   * Agendamento updateMany
   */
  export type AgendamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agendamentos.
     */
    data: XOR<AgendamentoUpdateManyMutationInput, AgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which Agendamentos to update
     */
    where?: AgendamentoWhereInput
    /**
     * Limit how many Agendamentos to update.
     */
    limit?: number
  }

  /**
   * Agendamento updateManyAndReturn
   */
  export type AgendamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * The data used to update Agendamentos.
     */
    data: XOR<AgendamentoUpdateManyMutationInput, AgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which Agendamentos to update
     */
    where?: AgendamentoWhereInput
    /**
     * Limit how many Agendamentos to update.
     */
    limit?: number
  }

  /**
   * Agendamento upsert
   */
  export type AgendamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * The filter to search for the Agendamento to update in case it exists.
     */
    where: AgendamentoWhereUniqueInput
    /**
     * In case the Agendamento found by the `where` argument doesn't exist, create a new Agendamento with this data.
     */
    create: XOR<AgendamentoCreateInput, AgendamentoUncheckedCreateInput>
    /**
     * In case the Agendamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendamentoUpdateInput, AgendamentoUncheckedUpdateInput>
  }

  /**
   * Agendamento delete
   */
  export type AgendamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
    /**
     * Filter which Agendamento to delete.
     */
    where: AgendamentoWhereUniqueInput
  }

  /**
   * Agendamento deleteMany
   */
  export type AgendamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agendamentos to delete
     */
    where?: AgendamentoWhereInput
    /**
     * Limit how many Agendamentos to delete.
     */
    limit?: number
  }

  /**
   * Agendamento without action
   */
  export type AgendamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agendamento
     */
    select?: AgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agendamento
     */
    omit?: AgendamentoOmit<ExtArgs> | null
  }


  /**
   * Model ProgramaAgendamento
   */

  export type AggregateProgramaAgendamento = {
    _count: ProgramaAgendamentoCountAggregateOutputType | null
    _min: ProgramaAgendamentoMinAggregateOutputType | null
    _max: ProgramaAgendamentoMaxAggregateOutputType | null
  }

  export type ProgramaAgendamentoMinAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type ProgramaAgendamentoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type ProgramaAgendamentoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type ProgramaAgendamentoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type ProgramaAgendamentoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type ProgramaAgendamentoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type ProgramaAgendamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramaAgendamento to aggregate.
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramaAgendamentos to fetch.
     */
    orderBy?: ProgramaAgendamentoOrderByWithRelationInput | ProgramaAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramaAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramaAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramaAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramaAgendamentos
    **/
    _count?: true | ProgramaAgendamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramaAgendamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramaAgendamentoMaxAggregateInputType
  }

  export type GetProgramaAgendamentoAggregateType<T extends ProgramaAgendamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramaAgendamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramaAgendamento[P]>
      : GetScalarType<T[P], AggregateProgramaAgendamento[P]>
  }




  export type ProgramaAgendamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramaAgendamentoWhereInput
    orderBy?: ProgramaAgendamentoOrderByWithAggregationInput | ProgramaAgendamentoOrderByWithAggregationInput[]
    by: ProgramaAgendamentoScalarFieldEnum[] | ProgramaAgendamentoScalarFieldEnum
    having?: ProgramaAgendamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramaAgendamentoCountAggregateInputType | true
    _min?: ProgramaAgendamentoMinAggregateInputType
    _max?: ProgramaAgendamentoMaxAggregateInputType
  }

  export type ProgramaAgendamentoGroupByOutputType = {
    id: string
    nome: string
    _count: ProgramaAgendamentoCountAggregateOutputType | null
    _min: ProgramaAgendamentoMinAggregateOutputType | null
    _max: ProgramaAgendamentoMaxAggregateOutputType | null
  }

  type GetProgramaAgendamentoGroupByPayload<T extends ProgramaAgendamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramaAgendamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramaAgendamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramaAgendamentoGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramaAgendamentoGroupByOutputType[P]>
        }
      >
    >


  export type ProgramaAgendamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["programaAgendamento"]>

  export type ProgramaAgendamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["programaAgendamento"]>

  export type ProgramaAgendamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["programaAgendamento"]>

  export type ProgramaAgendamentoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type ProgramaAgendamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome", ExtArgs["result"]["programaAgendamento"]>

  export type $ProgramaAgendamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramaAgendamento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
    }, ExtArgs["result"]["programaAgendamento"]>
    composites: {}
  }

  type ProgramaAgendamentoGetPayload<S extends boolean | null | undefined | ProgramaAgendamentoDefaultArgs> = $Result.GetResult<Prisma.$ProgramaAgendamentoPayload, S>

  type ProgramaAgendamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramaAgendamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramaAgendamentoCountAggregateInputType | true
    }

  export interface ProgramaAgendamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramaAgendamento'], meta: { name: 'ProgramaAgendamento' } }
    /**
     * Find zero or one ProgramaAgendamento that matches the filter.
     * @param {ProgramaAgendamentoFindUniqueArgs} args - Arguments to find a ProgramaAgendamento
     * @example
     * // Get one ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramaAgendamentoFindUniqueArgs>(args: SelectSubset<T, ProgramaAgendamentoFindUniqueArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramaAgendamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramaAgendamentoFindUniqueOrThrowArgs} args - Arguments to find a ProgramaAgendamento
     * @example
     * // Get one ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramaAgendamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramaAgendamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramaAgendamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoFindFirstArgs} args - Arguments to find a ProgramaAgendamento
     * @example
     * // Get one ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramaAgendamentoFindFirstArgs>(args?: SelectSubset<T, ProgramaAgendamentoFindFirstArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramaAgendamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoFindFirstOrThrowArgs} args - Arguments to find a ProgramaAgendamento
     * @example
     * // Get one ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramaAgendamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramaAgendamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramaAgendamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramaAgendamentos
     * const programaAgendamentos = await prisma.programaAgendamento.findMany()
     * 
     * // Get first 10 ProgramaAgendamentos
     * const programaAgendamentos = await prisma.programaAgendamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programaAgendamentoWithIdOnly = await prisma.programaAgendamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramaAgendamentoFindManyArgs>(args?: SelectSubset<T, ProgramaAgendamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramaAgendamento.
     * @param {ProgramaAgendamentoCreateArgs} args - Arguments to create a ProgramaAgendamento.
     * @example
     * // Create one ProgramaAgendamento
     * const ProgramaAgendamento = await prisma.programaAgendamento.create({
     *   data: {
     *     // ... data to create a ProgramaAgendamento
     *   }
     * })
     * 
     */
    create<T extends ProgramaAgendamentoCreateArgs>(args: SelectSubset<T, ProgramaAgendamentoCreateArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramaAgendamentos.
     * @param {ProgramaAgendamentoCreateManyArgs} args - Arguments to create many ProgramaAgendamentos.
     * @example
     * // Create many ProgramaAgendamentos
     * const programaAgendamento = await prisma.programaAgendamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramaAgendamentoCreateManyArgs>(args?: SelectSubset<T, ProgramaAgendamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramaAgendamentos and returns the data saved in the database.
     * @param {ProgramaAgendamentoCreateManyAndReturnArgs} args - Arguments to create many ProgramaAgendamentos.
     * @example
     * // Create many ProgramaAgendamentos
     * const programaAgendamento = await prisma.programaAgendamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramaAgendamentos and only return the `id`
     * const programaAgendamentoWithIdOnly = await prisma.programaAgendamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramaAgendamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramaAgendamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramaAgendamento.
     * @param {ProgramaAgendamentoDeleteArgs} args - Arguments to delete one ProgramaAgendamento.
     * @example
     * // Delete one ProgramaAgendamento
     * const ProgramaAgendamento = await prisma.programaAgendamento.delete({
     *   where: {
     *     // ... filter to delete one ProgramaAgendamento
     *   }
     * })
     * 
     */
    delete<T extends ProgramaAgendamentoDeleteArgs>(args: SelectSubset<T, ProgramaAgendamentoDeleteArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramaAgendamento.
     * @param {ProgramaAgendamentoUpdateArgs} args - Arguments to update one ProgramaAgendamento.
     * @example
     * // Update one ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramaAgendamentoUpdateArgs>(args: SelectSubset<T, ProgramaAgendamentoUpdateArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramaAgendamentos.
     * @param {ProgramaAgendamentoDeleteManyArgs} args - Arguments to filter ProgramaAgendamentos to delete.
     * @example
     * // Delete a few ProgramaAgendamentos
     * const { count } = await prisma.programaAgendamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramaAgendamentoDeleteManyArgs>(args?: SelectSubset<T, ProgramaAgendamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramaAgendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramaAgendamentos
     * const programaAgendamento = await prisma.programaAgendamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramaAgendamentoUpdateManyArgs>(args: SelectSubset<T, ProgramaAgendamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramaAgendamentos and returns the data updated in the database.
     * @param {ProgramaAgendamentoUpdateManyAndReturnArgs} args - Arguments to update many ProgramaAgendamentos.
     * @example
     * // Update many ProgramaAgendamentos
     * const programaAgendamento = await prisma.programaAgendamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramaAgendamentos and only return the `id`
     * const programaAgendamentoWithIdOnly = await prisma.programaAgendamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramaAgendamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramaAgendamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramaAgendamento.
     * @param {ProgramaAgendamentoUpsertArgs} args - Arguments to update or create a ProgramaAgendamento.
     * @example
     * // Update or create a ProgramaAgendamento
     * const programaAgendamento = await prisma.programaAgendamento.upsert({
     *   create: {
     *     // ... data to create a ProgramaAgendamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramaAgendamento we want to update
     *   }
     * })
     */
    upsert<T extends ProgramaAgendamentoUpsertArgs>(args: SelectSubset<T, ProgramaAgendamentoUpsertArgs<ExtArgs>>): Prisma__ProgramaAgendamentoClient<$Result.GetResult<Prisma.$ProgramaAgendamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramaAgendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoCountArgs} args - Arguments to filter ProgramaAgendamentos to count.
     * @example
     * // Count the number of ProgramaAgendamentos
     * const count = await prisma.programaAgendamento.count({
     *   where: {
     *     // ... the filter for the ProgramaAgendamentos we want to count
     *   }
     * })
    **/
    count<T extends ProgramaAgendamentoCountArgs>(
      args?: Subset<T, ProgramaAgendamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramaAgendamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramaAgendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramaAgendamentoAggregateArgs>(args: Subset<T, ProgramaAgendamentoAggregateArgs>): Prisma.PrismaPromise<GetProgramaAgendamentoAggregateType<T>>

    /**
     * Group by ProgramaAgendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAgendamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramaAgendamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramaAgendamentoGroupByArgs['orderBy'] }
        : { orderBy?: ProgramaAgendamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramaAgendamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramaAgendamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramaAgendamento model
   */
  readonly fields: ProgramaAgendamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramaAgendamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramaAgendamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramaAgendamento model
   */
  interface ProgramaAgendamentoFieldRefs {
    readonly id: FieldRef<"ProgramaAgendamento", 'String'>
    readonly nome: FieldRef<"ProgramaAgendamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProgramaAgendamento findUnique
   */
  export type ProgramaAgendamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which ProgramaAgendamento to fetch.
     */
    where: ProgramaAgendamentoWhereUniqueInput
  }

  /**
   * ProgramaAgendamento findUniqueOrThrow
   */
  export type ProgramaAgendamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which ProgramaAgendamento to fetch.
     */
    where: ProgramaAgendamentoWhereUniqueInput
  }

  /**
   * ProgramaAgendamento findFirst
   */
  export type ProgramaAgendamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which ProgramaAgendamento to fetch.
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramaAgendamentos to fetch.
     */
    orderBy?: ProgramaAgendamentoOrderByWithRelationInput | ProgramaAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramaAgendamentos.
     */
    cursor?: ProgramaAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramaAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramaAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramaAgendamentos.
     */
    distinct?: ProgramaAgendamentoScalarFieldEnum | ProgramaAgendamentoScalarFieldEnum[]
  }

  /**
   * ProgramaAgendamento findFirstOrThrow
   */
  export type ProgramaAgendamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which ProgramaAgendamento to fetch.
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramaAgendamentos to fetch.
     */
    orderBy?: ProgramaAgendamentoOrderByWithRelationInput | ProgramaAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramaAgendamentos.
     */
    cursor?: ProgramaAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramaAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramaAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramaAgendamentos.
     */
    distinct?: ProgramaAgendamentoScalarFieldEnum | ProgramaAgendamentoScalarFieldEnum[]
  }

  /**
   * ProgramaAgendamento findMany
   */
  export type ProgramaAgendamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which ProgramaAgendamentos to fetch.
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramaAgendamentos to fetch.
     */
    orderBy?: ProgramaAgendamentoOrderByWithRelationInput | ProgramaAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramaAgendamentos.
     */
    cursor?: ProgramaAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramaAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramaAgendamentos.
     */
    skip?: number
    distinct?: ProgramaAgendamentoScalarFieldEnum | ProgramaAgendamentoScalarFieldEnum[]
  }

  /**
   * ProgramaAgendamento create
   */
  export type ProgramaAgendamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to create a ProgramaAgendamento.
     */
    data: XOR<ProgramaAgendamentoCreateInput, ProgramaAgendamentoUncheckedCreateInput>
  }

  /**
   * ProgramaAgendamento createMany
   */
  export type ProgramaAgendamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramaAgendamentos.
     */
    data: ProgramaAgendamentoCreateManyInput | ProgramaAgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramaAgendamento createManyAndReturn
   */
  export type ProgramaAgendamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramaAgendamentos.
     */
    data: ProgramaAgendamentoCreateManyInput | ProgramaAgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramaAgendamento update
   */
  export type ProgramaAgendamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to update a ProgramaAgendamento.
     */
    data: XOR<ProgramaAgendamentoUpdateInput, ProgramaAgendamentoUncheckedUpdateInput>
    /**
     * Choose, which ProgramaAgendamento to update.
     */
    where: ProgramaAgendamentoWhereUniqueInput
  }

  /**
   * ProgramaAgendamento updateMany
   */
  export type ProgramaAgendamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramaAgendamentos.
     */
    data: XOR<ProgramaAgendamentoUpdateManyMutationInput, ProgramaAgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which ProgramaAgendamentos to update
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * Limit how many ProgramaAgendamentos to update.
     */
    limit?: number
  }

  /**
   * ProgramaAgendamento updateManyAndReturn
   */
  export type ProgramaAgendamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * The data used to update ProgramaAgendamentos.
     */
    data: XOR<ProgramaAgendamentoUpdateManyMutationInput, ProgramaAgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which ProgramaAgendamentos to update
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * Limit how many ProgramaAgendamentos to update.
     */
    limit?: number
  }

  /**
   * ProgramaAgendamento upsert
   */
  export type ProgramaAgendamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * The filter to search for the ProgramaAgendamento to update in case it exists.
     */
    where: ProgramaAgendamentoWhereUniqueInput
    /**
     * In case the ProgramaAgendamento found by the `where` argument doesn't exist, create a new ProgramaAgendamento with this data.
     */
    create: XOR<ProgramaAgendamentoCreateInput, ProgramaAgendamentoUncheckedCreateInput>
    /**
     * In case the ProgramaAgendamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramaAgendamentoUpdateInput, ProgramaAgendamentoUncheckedUpdateInput>
  }

  /**
   * ProgramaAgendamento delete
   */
  export type ProgramaAgendamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
    /**
     * Filter which ProgramaAgendamento to delete.
     */
    where: ProgramaAgendamentoWhereUniqueInput
  }

  /**
   * ProgramaAgendamento deleteMany
   */
  export type ProgramaAgendamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramaAgendamentos to delete
     */
    where?: ProgramaAgendamentoWhereInput
    /**
     * Limit how many ProgramaAgendamentos to delete.
     */
    limit?: number
  }

  /**
   * ProgramaAgendamento without action
   */
  export type ProgramaAgendamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramaAgendamento
     */
    select?: ProgramaAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramaAgendamento
     */
    omit?: ProgramaAgendamentoOmit<ExtArgs> | null
  }


  /**
   * Model TipoAtendimentoAgendamento
   */

  export type AggregateTipoAtendimentoAgendamento = {
    _count: TipoAtendimentoAgendamentoCountAggregateOutputType | null
    _min: TipoAtendimentoAgendamentoMinAggregateOutputType | null
    _max: TipoAtendimentoAgendamentoMaxAggregateOutputType | null
  }

  export type TipoAtendimentoAgendamentoMinAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type TipoAtendimentoAgendamentoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type TipoAtendimentoAgendamentoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type TipoAtendimentoAgendamentoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type TipoAtendimentoAgendamentoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type TipoAtendimentoAgendamentoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type TipoAtendimentoAgendamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAtendimentoAgendamento to aggregate.
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentoAgendamentos to fetch.
     */
    orderBy?: TipoAtendimentoAgendamentoOrderByWithRelationInput | TipoAtendimentoAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoAtendimentoAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentoAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentoAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoAtendimentoAgendamentos
    **/
    _count?: true | TipoAtendimentoAgendamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoAtendimentoAgendamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoAtendimentoAgendamentoMaxAggregateInputType
  }

  export type GetTipoAtendimentoAgendamentoAggregateType<T extends TipoAtendimentoAgendamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoAtendimentoAgendamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoAtendimentoAgendamento[P]>
      : GetScalarType<T[P], AggregateTipoAtendimentoAgendamento[P]>
  }




  export type TipoAtendimentoAgendamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoAtendimentoAgendamentoWhereInput
    orderBy?: TipoAtendimentoAgendamentoOrderByWithAggregationInput | TipoAtendimentoAgendamentoOrderByWithAggregationInput[]
    by: TipoAtendimentoAgendamentoScalarFieldEnum[] | TipoAtendimentoAgendamentoScalarFieldEnum
    having?: TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoAtendimentoAgendamentoCountAggregateInputType | true
    _min?: TipoAtendimentoAgendamentoMinAggregateInputType
    _max?: TipoAtendimentoAgendamentoMaxAggregateInputType
  }

  export type TipoAtendimentoAgendamentoGroupByOutputType = {
    id: string
    nome: string
    _count: TipoAtendimentoAgendamentoCountAggregateOutputType | null
    _min: TipoAtendimentoAgendamentoMinAggregateOutputType | null
    _max: TipoAtendimentoAgendamentoMaxAggregateOutputType | null
  }

  type GetTipoAtendimentoAgendamentoGroupByPayload<T extends TipoAtendimentoAgendamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoAtendimentoAgendamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoAtendimentoAgendamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoAtendimentoAgendamentoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoAtendimentoAgendamentoGroupByOutputType[P]>
        }
      >
    >


  export type TipoAtendimentoAgendamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["tipoAtendimentoAgendamento"]>

  export type TipoAtendimentoAgendamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["tipoAtendimentoAgendamento"]>

  export type TipoAtendimentoAgendamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["tipoAtendimentoAgendamento"]>

  export type TipoAtendimentoAgendamentoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type TipoAtendimentoAgendamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome", ExtArgs["result"]["tipoAtendimentoAgendamento"]>

  export type $TipoAtendimentoAgendamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoAtendimentoAgendamento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
    }, ExtArgs["result"]["tipoAtendimentoAgendamento"]>
    composites: {}
  }

  type TipoAtendimentoAgendamentoGetPayload<S extends boolean | null | undefined | TipoAtendimentoAgendamentoDefaultArgs> = $Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload, S>

  type TipoAtendimentoAgendamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoAtendimentoAgendamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoAtendimentoAgendamentoCountAggregateInputType | true
    }

  export interface TipoAtendimentoAgendamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoAtendimentoAgendamento'], meta: { name: 'TipoAtendimentoAgendamento' } }
    /**
     * Find zero or one TipoAtendimentoAgendamento that matches the filter.
     * @param {TipoAtendimentoAgendamentoFindUniqueArgs} args - Arguments to find a TipoAtendimentoAgendamento
     * @example
     * // Get one TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoAtendimentoAgendamentoFindUniqueArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoFindUniqueArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoAtendimentoAgendamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoAtendimentoAgendamentoFindUniqueOrThrowArgs} args - Arguments to find a TipoAtendimentoAgendamento
     * @example
     * // Get one TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoAtendimentoAgendamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAtendimentoAgendamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoFindFirstArgs} args - Arguments to find a TipoAtendimentoAgendamento
     * @example
     * // Get one TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoAtendimentoAgendamentoFindFirstArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoFindFirstArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAtendimentoAgendamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoFindFirstOrThrowArgs} args - Arguments to find a TipoAtendimentoAgendamento
     * @example
     * // Get one TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoAtendimentoAgendamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoAtendimentoAgendamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamentos = await prisma.tipoAtendimentoAgendamento.findMany()
     * 
     * // Get first 10 TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamentos = await prisma.tipoAtendimentoAgendamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoAtendimentoAgendamentoWithIdOnly = await prisma.tipoAtendimentoAgendamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoAtendimentoAgendamentoFindManyArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoAtendimentoAgendamento.
     * @param {TipoAtendimentoAgendamentoCreateArgs} args - Arguments to create a TipoAtendimentoAgendamento.
     * @example
     * // Create one TipoAtendimentoAgendamento
     * const TipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.create({
     *   data: {
     *     // ... data to create a TipoAtendimentoAgendamento
     *   }
     * })
     * 
     */
    create<T extends TipoAtendimentoAgendamentoCreateArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoCreateArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoAtendimentoAgendamentos.
     * @param {TipoAtendimentoAgendamentoCreateManyArgs} args - Arguments to create many TipoAtendimentoAgendamentos.
     * @example
     * // Create many TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoAtendimentoAgendamentoCreateManyArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoAtendimentoAgendamentos and returns the data saved in the database.
     * @param {TipoAtendimentoAgendamentoCreateManyAndReturnArgs} args - Arguments to create many TipoAtendimentoAgendamentos.
     * @example
     * // Create many TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoAtendimentoAgendamentos and only return the `id`
     * const tipoAtendimentoAgendamentoWithIdOnly = await prisma.tipoAtendimentoAgendamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoAtendimentoAgendamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoAtendimentoAgendamento.
     * @param {TipoAtendimentoAgendamentoDeleteArgs} args - Arguments to delete one TipoAtendimentoAgendamento.
     * @example
     * // Delete one TipoAtendimentoAgendamento
     * const TipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.delete({
     *   where: {
     *     // ... filter to delete one TipoAtendimentoAgendamento
     *   }
     * })
     * 
     */
    delete<T extends TipoAtendimentoAgendamentoDeleteArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoDeleteArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoAtendimentoAgendamento.
     * @param {TipoAtendimentoAgendamentoUpdateArgs} args - Arguments to update one TipoAtendimentoAgendamento.
     * @example
     * // Update one TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoAtendimentoAgendamentoUpdateArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoUpdateArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoAtendimentoAgendamentos.
     * @param {TipoAtendimentoAgendamentoDeleteManyArgs} args - Arguments to filter TipoAtendimentoAgendamentos to delete.
     * @example
     * // Delete a few TipoAtendimentoAgendamentos
     * const { count } = await prisma.tipoAtendimentoAgendamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoAtendimentoAgendamentoDeleteManyArgs>(args?: SelectSubset<T, TipoAtendimentoAgendamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAtendimentoAgendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoAtendimentoAgendamentoUpdateManyArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAtendimentoAgendamentos and returns the data updated in the database.
     * @param {TipoAtendimentoAgendamentoUpdateManyAndReturnArgs} args - Arguments to update many TipoAtendimentoAgendamentos.
     * @example
     * // Update many TipoAtendimentoAgendamentos
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoAtendimentoAgendamentos and only return the `id`
     * const tipoAtendimentoAgendamentoWithIdOnly = await prisma.tipoAtendimentoAgendamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoAtendimentoAgendamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoAtendimentoAgendamento.
     * @param {TipoAtendimentoAgendamentoUpsertArgs} args - Arguments to update or create a TipoAtendimentoAgendamento.
     * @example
     * // Update or create a TipoAtendimentoAgendamento
     * const tipoAtendimentoAgendamento = await prisma.tipoAtendimentoAgendamento.upsert({
     *   create: {
     *     // ... data to create a TipoAtendimentoAgendamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoAtendimentoAgendamento we want to update
     *   }
     * })
     */
    upsert<T extends TipoAtendimentoAgendamentoUpsertArgs>(args: SelectSubset<T, TipoAtendimentoAgendamentoUpsertArgs<ExtArgs>>): Prisma__TipoAtendimentoAgendamentoClient<$Result.GetResult<Prisma.$TipoAtendimentoAgendamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoAtendimentoAgendamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoCountArgs} args - Arguments to filter TipoAtendimentoAgendamentos to count.
     * @example
     * // Count the number of TipoAtendimentoAgendamentos
     * const count = await prisma.tipoAtendimentoAgendamento.count({
     *   where: {
     *     // ... the filter for the TipoAtendimentoAgendamentos we want to count
     *   }
     * })
    **/
    count<T extends TipoAtendimentoAgendamentoCountArgs>(
      args?: Subset<T, TipoAtendimentoAgendamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoAtendimentoAgendamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoAtendimentoAgendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAtendimentoAgendamentoAggregateArgs>(args: Subset<T, TipoAtendimentoAgendamentoAggregateArgs>): Prisma.PrismaPromise<GetTipoAtendimentoAgendamentoAggregateType<T>>

    /**
     * Group by TipoAtendimentoAgendamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAgendamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoAtendimentoAgendamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoAtendimentoAgendamentoGroupByArgs['orderBy'] }
        : { orderBy?: TipoAtendimentoAgendamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoAtendimentoAgendamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoAtendimentoAgendamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoAtendimentoAgendamento model
   */
  readonly fields: TipoAtendimentoAgendamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoAtendimentoAgendamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoAtendimentoAgendamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoAtendimentoAgendamento model
   */
  interface TipoAtendimentoAgendamentoFieldRefs {
    readonly id: FieldRef<"TipoAtendimentoAgendamento", 'String'>
    readonly nome: FieldRef<"TipoAtendimentoAgendamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoAtendimentoAgendamento findUnique
   */
  export type TipoAtendimentoAgendamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentoAgendamento to fetch.
     */
    where: TipoAtendimentoAgendamentoWhereUniqueInput
  }

  /**
   * TipoAtendimentoAgendamento findUniqueOrThrow
   */
  export type TipoAtendimentoAgendamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentoAgendamento to fetch.
     */
    where: TipoAtendimentoAgendamentoWhereUniqueInput
  }

  /**
   * TipoAtendimentoAgendamento findFirst
   */
  export type TipoAtendimentoAgendamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentoAgendamento to fetch.
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentoAgendamentos to fetch.
     */
    orderBy?: TipoAtendimentoAgendamentoOrderByWithRelationInput | TipoAtendimentoAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAtendimentoAgendamentos.
     */
    cursor?: TipoAtendimentoAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentoAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentoAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAtendimentoAgendamentos.
     */
    distinct?: TipoAtendimentoAgendamentoScalarFieldEnum | TipoAtendimentoAgendamentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimentoAgendamento findFirstOrThrow
   */
  export type TipoAtendimentoAgendamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentoAgendamento to fetch.
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentoAgendamentos to fetch.
     */
    orderBy?: TipoAtendimentoAgendamentoOrderByWithRelationInput | TipoAtendimentoAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAtendimentoAgendamentos.
     */
    cursor?: TipoAtendimentoAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentoAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentoAgendamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAtendimentoAgendamentos.
     */
    distinct?: TipoAtendimentoAgendamentoScalarFieldEnum | TipoAtendimentoAgendamentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimentoAgendamento findMany
   */
  export type TipoAtendimentoAgendamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentoAgendamentos to fetch.
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentoAgendamentos to fetch.
     */
    orderBy?: TipoAtendimentoAgendamentoOrderByWithRelationInput | TipoAtendimentoAgendamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoAtendimentoAgendamentos.
     */
    cursor?: TipoAtendimentoAgendamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentoAgendamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentoAgendamentos.
     */
    skip?: number
    distinct?: TipoAtendimentoAgendamentoScalarFieldEnum | TipoAtendimentoAgendamentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimentoAgendamento create
   */
  export type TipoAtendimentoAgendamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to create a TipoAtendimentoAgendamento.
     */
    data: XOR<TipoAtendimentoAgendamentoCreateInput, TipoAtendimentoAgendamentoUncheckedCreateInput>
  }

  /**
   * TipoAtendimentoAgendamento createMany
   */
  export type TipoAtendimentoAgendamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoAtendimentoAgendamentos.
     */
    data: TipoAtendimentoAgendamentoCreateManyInput | TipoAtendimentoAgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoAtendimentoAgendamento createManyAndReturn
   */
  export type TipoAtendimentoAgendamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoAtendimentoAgendamentos.
     */
    data: TipoAtendimentoAgendamentoCreateManyInput | TipoAtendimentoAgendamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoAtendimentoAgendamento update
   */
  export type TipoAtendimentoAgendamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * The data needed to update a TipoAtendimentoAgendamento.
     */
    data: XOR<TipoAtendimentoAgendamentoUpdateInput, TipoAtendimentoAgendamentoUncheckedUpdateInput>
    /**
     * Choose, which TipoAtendimentoAgendamento to update.
     */
    where: TipoAtendimentoAgendamentoWhereUniqueInput
  }

  /**
   * TipoAtendimentoAgendamento updateMany
   */
  export type TipoAtendimentoAgendamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoAtendimentoAgendamentos.
     */
    data: XOR<TipoAtendimentoAgendamentoUpdateManyMutationInput, TipoAtendimentoAgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAtendimentoAgendamentos to update
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * Limit how many TipoAtendimentoAgendamentos to update.
     */
    limit?: number
  }

  /**
   * TipoAtendimentoAgendamento updateManyAndReturn
   */
  export type TipoAtendimentoAgendamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * The data used to update TipoAtendimentoAgendamentos.
     */
    data: XOR<TipoAtendimentoAgendamentoUpdateManyMutationInput, TipoAtendimentoAgendamentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAtendimentoAgendamentos to update
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * Limit how many TipoAtendimentoAgendamentos to update.
     */
    limit?: number
  }

  /**
   * TipoAtendimentoAgendamento upsert
   */
  export type TipoAtendimentoAgendamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * The filter to search for the TipoAtendimentoAgendamento to update in case it exists.
     */
    where: TipoAtendimentoAgendamentoWhereUniqueInput
    /**
     * In case the TipoAtendimentoAgendamento found by the `where` argument doesn't exist, create a new TipoAtendimentoAgendamento with this data.
     */
    create: XOR<TipoAtendimentoAgendamentoCreateInput, TipoAtendimentoAgendamentoUncheckedCreateInput>
    /**
     * In case the TipoAtendimentoAgendamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoAtendimentoAgendamentoUpdateInput, TipoAtendimentoAgendamentoUncheckedUpdateInput>
  }

  /**
   * TipoAtendimentoAgendamento delete
   */
  export type TipoAtendimentoAgendamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
    /**
     * Filter which TipoAtendimentoAgendamento to delete.
     */
    where: TipoAtendimentoAgendamentoWhereUniqueInput
  }

  /**
   * TipoAtendimentoAgendamento deleteMany
   */
  export type TipoAtendimentoAgendamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAtendimentoAgendamentos to delete
     */
    where?: TipoAtendimentoAgendamentoWhereInput
    /**
     * Limit how many TipoAtendimentoAgendamentos to delete.
     */
    limit?: number
  }

  /**
   * TipoAtendimentoAgendamento without action
   */
  export type TipoAtendimentoAgendamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimentoAgendamento
     */
    select?: TipoAtendimentoAgendamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimentoAgendamento
     */
    omit?: TipoAtendimentoAgendamentoOmit<ExtArgs> | null
  }


  /**
   * Model Aluno
   */

  export type AggregateAluno = {
    _count: AlunoCountAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  export type AlunoMinAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type AlunoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
  }

  export type AlunoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type AlunoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type AlunoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type AlunoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type AlunoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aluno to aggregate.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alunos
    **/
    _count?: true | AlunoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlunoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlunoMaxAggregateInputType
  }

  export type GetAlunoAggregateType<T extends AlunoAggregateArgs> = {
        [P in keyof T & keyof AggregateAluno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAluno[P]>
      : GetScalarType<T[P], AggregateAluno[P]>
  }




  export type AlunoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlunoWhereInput
    orderBy?: AlunoOrderByWithAggregationInput | AlunoOrderByWithAggregationInput[]
    by: AlunoScalarFieldEnum[] | AlunoScalarFieldEnum
    having?: AlunoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlunoCountAggregateInputType | true
    _min?: AlunoMinAggregateInputType
    _max?: AlunoMaxAggregateInputType
  }

  export type AlunoGroupByOutputType = {
    id: string
    nome: string
    _count: AlunoCountAggregateOutputType | null
    _min: AlunoMinAggregateOutputType | null
    _max: AlunoMaxAggregateOutputType | null
  }

  type GetAlunoGroupByPayload<T extends AlunoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlunoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlunoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlunoGroupByOutputType[P]>
            : GetScalarType<T[P], AlunoGroupByOutputType[P]>
        }
      >
    >


  export type AlunoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["aluno"]>

  export type AlunoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["aluno"]>

  export type AlunoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["aluno"]>

  export type AlunoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type AlunoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome", ExtArgs["result"]["aluno"]>

  export type $AlunoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Aluno"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
    }, ExtArgs["result"]["aluno"]>
    composites: {}
  }

  type AlunoGetPayload<S extends boolean | null | undefined | AlunoDefaultArgs> = $Result.GetResult<Prisma.$AlunoPayload, S>

  type AlunoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlunoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlunoCountAggregateInputType | true
    }

  export interface AlunoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Aluno'], meta: { name: 'Aluno' } }
    /**
     * Find zero or one Aluno that matches the filter.
     * @param {AlunoFindUniqueArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlunoFindUniqueArgs>(args: SelectSubset<T, AlunoFindUniqueArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aluno that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlunoFindUniqueOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlunoFindUniqueOrThrowArgs>(args: SelectSubset<T, AlunoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aluno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindFirstArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlunoFindFirstArgs>(args?: SelectSubset<T, AlunoFindFirstArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aluno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindFirstOrThrowArgs} args - Arguments to find a Aluno
     * @example
     * // Get one Aluno
     * const aluno = await prisma.aluno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlunoFindFirstOrThrowArgs>(args?: SelectSubset<T, AlunoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alunos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alunos
     * const alunos = await prisma.aluno.findMany()
     * 
     * // Get first 10 Alunos
     * const alunos = await prisma.aluno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alunoWithIdOnly = await prisma.aluno.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlunoFindManyArgs>(args?: SelectSubset<T, AlunoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aluno.
     * @param {AlunoCreateArgs} args - Arguments to create a Aluno.
     * @example
     * // Create one Aluno
     * const Aluno = await prisma.aluno.create({
     *   data: {
     *     // ... data to create a Aluno
     *   }
     * })
     * 
     */
    create<T extends AlunoCreateArgs>(args: SelectSubset<T, AlunoCreateArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alunos.
     * @param {AlunoCreateManyArgs} args - Arguments to create many Alunos.
     * @example
     * // Create many Alunos
     * const aluno = await prisma.aluno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlunoCreateManyArgs>(args?: SelectSubset<T, AlunoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alunos and returns the data saved in the database.
     * @param {AlunoCreateManyAndReturnArgs} args - Arguments to create many Alunos.
     * @example
     * // Create many Alunos
     * const aluno = await prisma.aluno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alunos and only return the `id`
     * const alunoWithIdOnly = await prisma.aluno.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlunoCreateManyAndReturnArgs>(args?: SelectSubset<T, AlunoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Aluno.
     * @param {AlunoDeleteArgs} args - Arguments to delete one Aluno.
     * @example
     * // Delete one Aluno
     * const Aluno = await prisma.aluno.delete({
     *   where: {
     *     // ... filter to delete one Aluno
     *   }
     * })
     * 
     */
    delete<T extends AlunoDeleteArgs>(args: SelectSubset<T, AlunoDeleteArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aluno.
     * @param {AlunoUpdateArgs} args - Arguments to update one Aluno.
     * @example
     * // Update one Aluno
     * const aluno = await prisma.aluno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlunoUpdateArgs>(args: SelectSubset<T, AlunoUpdateArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alunos.
     * @param {AlunoDeleteManyArgs} args - Arguments to filter Alunos to delete.
     * @example
     * // Delete a few Alunos
     * const { count } = await prisma.aluno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlunoDeleteManyArgs>(args?: SelectSubset<T, AlunoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alunos
     * const aluno = await prisma.aluno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlunoUpdateManyArgs>(args: SelectSubset<T, AlunoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alunos and returns the data updated in the database.
     * @param {AlunoUpdateManyAndReturnArgs} args - Arguments to update many Alunos.
     * @example
     * // Update many Alunos
     * const aluno = await prisma.aluno.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alunos and only return the `id`
     * const alunoWithIdOnly = await prisma.aluno.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlunoUpdateManyAndReturnArgs>(args: SelectSubset<T, AlunoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Aluno.
     * @param {AlunoUpsertArgs} args - Arguments to update or create a Aluno.
     * @example
     * // Update or create a Aluno
     * const aluno = await prisma.aluno.upsert({
     *   create: {
     *     // ... data to create a Aluno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aluno we want to update
     *   }
     * })
     */
    upsert<T extends AlunoUpsertArgs>(args: SelectSubset<T, AlunoUpsertArgs<ExtArgs>>): Prisma__AlunoClient<$Result.GetResult<Prisma.$AlunoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoCountArgs} args - Arguments to filter Alunos to count.
     * @example
     * // Count the number of Alunos
     * const count = await prisma.aluno.count({
     *   where: {
     *     // ... the filter for the Alunos we want to count
     *   }
     * })
    **/
    count<T extends AlunoCountArgs>(
      args?: Subset<T, AlunoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlunoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlunoAggregateArgs>(args: Subset<T, AlunoAggregateArgs>): Prisma.PrismaPromise<GetAlunoAggregateType<T>>

    /**
     * Group by Aluno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlunoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlunoGroupByArgs['orderBy'] }
        : { orderBy?: AlunoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlunoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlunoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Aluno model
   */
  readonly fields: AlunoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aluno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlunoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Aluno model
   */
  interface AlunoFieldRefs {
    readonly id: FieldRef<"Aluno", 'String'>
    readonly nome: FieldRef<"Aluno", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Aluno findUnique
   */
  export type AlunoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno findUniqueOrThrow
   */
  export type AlunoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno findFirst
   */
  export type AlunoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno findFirstOrThrow
   */
  export type AlunoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter, which Aluno to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alunos.
     */
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno findMany
   */
  export type AlunoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter, which Alunos to fetch.
     */
    where?: AlunoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alunos to fetch.
     */
    orderBy?: AlunoOrderByWithRelationInput | AlunoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alunos.
     */
    cursor?: AlunoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alunos.
     */
    skip?: number
    distinct?: AlunoScalarFieldEnum | AlunoScalarFieldEnum[]
  }

  /**
   * Aluno create
   */
  export type AlunoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * The data needed to create a Aluno.
     */
    data: XOR<AlunoCreateInput, AlunoUncheckedCreateInput>
  }

  /**
   * Aluno createMany
   */
  export type AlunoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alunos.
     */
    data: AlunoCreateManyInput | AlunoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Aluno createManyAndReturn
   */
  export type AlunoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * The data used to create many Alunos.
     */
    data: AlunoCreateManyInput | AlunoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Aluno update
   */
  export type AlunoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * The data needed to update a Aluno.
     */
    data: XOR<AlunoUpdateInput, AlunoUncheckedUpdateInput>
    /**
     * Choose, which Aluno to update.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno updateMany
   */
  export type AlunoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alunos.
     */
    data: XOR<AlunoUpdateManyMutationInput, AlunoUncheckedUpdateManyInput>
    /**
     * Filter which Alunos to update
     */
    where?: AlunoWhereInput
    /**
     * Limit how many Alunos to update.
     */
    limit?: number
  }

  /**
   * Aluno updateManyAndReturn
   */
  export type AlunoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * The data used to update Alunos.
     */
    data: XOR<AlunoUpdateManyMutationInput, AlunoUncheckedUpdateManyInput>
    /**
     * Filter which Alunos to update
     */
    where?: AlunoWhereInput
    /**
     * Limit how many Alunos to update.
     */
    limit?: number
  }

  /**
   * Aluno upsert
   */
  export type AlunoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * The filter to search for the Aluno to update in case it exists.
     */
    where: AlunoWhereUniqueInput
    /**
     * In case the Aluno found by the `where` argument doesn't exist, create a new Aluno with this data.
     */
    create: XOR<AlunoCreateInput, AlunoUncheckedCreateInput>
    /**
     * In case the Aluno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlunoUpdateInput, AlunoUncheckedUpdateInput>
  }

  /**
   * Aluno delete
   */
  export type AlunoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
    /**
     * Filter which Aluno to delete.
     */
    where: AlunoWhereUniqueInput
  }

  /**
   * Aluno deleteMany
   */
  export type AlunoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alunos to delete
     */
    where?: AlunoWhereInput
    /**
     * Limit how many Alunos to delete.
     */
    limit?: number
  }

  /**
   * Aluno without action
   */
  export type AlunoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aluno
     */
    select?: AlunoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Aluno
     */
    omit?: AlunoOmit<ExtArgs> | null
  }


  /**
   * Model TipoAtendimento
   */

  export type AggregateTipoAtendimento = {
    _count: TipoAtendimentoCountAggregateOutputType | null
    _avg: TipoAtendimentoAvgAggregateOutputType | null
    _sum: TipoAtendimentoSumAggregateOutputType | null
    _min: TipoAtendimentoMinAggregateOutputType | null
    _max: TipoAtendimentoMaxAggregateOutputType | null
  }

  export type TipoAtendimentoAvgAggregateOutputType = {
    duracao: number | null
  }

  export type TipoAtendimentoSumAggregateOutputType = {
    duracao: number | null
  }

  export type TipoAtendimentoMinAggregateOutputType = {
    id: string | null
    nome: string | null
    sigla: string | null
    descricao: string | null
    publico: string | null
    duracao: number | null
    frequencia: string | null
    visibilidade: $Enums.Visibilidade | null
    instrucoesAluno: string | null
    orientacoesPublicas: string | null
    status: string | null
    programaId: string | null
  }

  export type TipoAtendimentoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    sigla: string | null
    descricao: string | null
    publico: string | null
    duracao: number | null
    frequencia: string | null
    visibilidade: $Enums.Visibilidade | null
    instrucoesAluno: string | null
    orientacoesPublicas: string | null
    status: string | null
    programaId: string | null
  }

  export type TipoAtendimentoCountAggregateOutputType = {
    id: number
    nome: number
    sigla: number
    descricao: number
    publico: number
    duracao: number
    frequencia: number
    visibilidade: number
    instrucoesAluno: number
    orientacoesPublicas: number
    status: number
    programaId: number
    _all: number
  }


  export type TipoAtendimentoAvgAggregateInputType = {
    duracao?: true
  }

  export type TipoAtendimentoSumAggregateInputType = {
    duracao?: true
  }

  export type TipoAtendimentoMinAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    descricao?: true
    publico?: true
    duracao?: true
    frequencia?: true
    visibilidade?: true
    instrucoesAluno?: true
    orientacoesPublicas?: true
    status?: true
    programaId?: true
  }

  export type TipoAtendimentoMaxAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    descricao?: true
    publico?: true
    duracao?: true
    frequencia?: true
    visibilidade?: true
    instrucoesAluno?: true
    orientacoesPublicas?: true
    status?: true
    programaId?: true
  }

  export type TipoAtendimentoCountAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    descricao?: true
    publico?: true
    duracao?: true
    frequencia?: true
    visibilidade?: true
    instrucoesAluno?: true
    orientacoesPublicas?: true
    status?: true
    programaId?: true
    _all?: true
  }

  export type TipoAtendimentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAtendimento to aggregate.
     */
    where?: TipoAtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentos to fetch.
     */
    orderBy?: TipoAtendimentoOrderByWithRelationInput | TipoAtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoAtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoAtendimentos
    **/
    _count?: true | TipoAtendimentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoAtendimentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoAtendimentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoAtendimentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoAtendimentoMaxAggregateInputType
  }

  export type GetTipoAtendimentoAggregateType<T extends TipoAtendimentoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoAtendimento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoAtendimento[P]>
      : GetScalarType<T[P], AggregateTipoAtendimento[P]>
  }




  export type TipoAtendimentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoAtendimentoWhereInput
    orderBy?: TipoAtendimentoOrderByWithAggregationInput | TipoAtendimentoOrderByWithAggregationInput[]
    by: TipoAtendimentoScalarFieldEnum[] | TipoAtendimentoScalarFieldEnum
    having?: TipoAtendimentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoAtendimentoCountAggregateInputType | true
    _avg?: TipoAtendimentoAvgAggregateInputType
    _sum?: TipoAtendimentoSumAggregateInputType
    _min?: TipoAtendimentoMinAggregateInputType
    _max?: TipoAtendimentoMaxAggregateInputType
  }

  export type TipoAtendimentoGroupByOutputType = {
    id: string
    nome: string
    sigla: string
    descricao: string | null
    publico: string | null
    duracao: number | null
    frequencia: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno: string | null
    orientacoesPublicas: string | null
    status: string
    programaId: string
    _count: TipoAtendimentoCountAggregateOutputType | null
    _avg: TipoAtendimentoAvgAggregateOutputType | null
    _sum: TipoAtendimentoSumAggregateOutputType | null
    _min: TipoAtendimentoMinAggregateOutputType | null
    _max: TipoAtendimentoMaxAggregateOutputType | null
  }

  type GetTipoAtendimentoGroupByPayload<T extends TipoAtendimentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoAtendimentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoAtendimentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoAtendimentoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoAtendimentoGroupByOutputType[P]>
        }
      >
    >


  export type TipoAtendimentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    descricao?: boolean
    publico?: boolean
    duracao?: boolean
    frequencia?: boolean
    visibilidade?: boolean
    instrucoesAluno?: boolean
    orientacoesPublicas?: boolean
    status?: boolean
    programaId?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoAtendimento"]>

  export type TipoAtendimentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    descricao?: boolean
    publico?: boolean
    duracao?: boolean
    frequencia?: boolean
    visibilidade?: boolean
    instrucoesAluno?: boolean
    orientacoesPublicas?: boolean
    status?: boolean
    programaId?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoAtendimento"]>

  export type TipoAtendimentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    descricao?: boolean
    publico?: boolean
    duracao?: boolean
    frequencia?: boolean
    visibilidade?: boolean
    instrucoesAluno?: boolean
    orientacoesPublicas?: boolean
    status?: boolean
    programaId?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoAtendimento"]>

  export type TipoAtendimentoSelectScalar = {
    id?: boolean
    nome?: boolean
    sigla?: boolean
    descricao?: boolean
    publico?: boolean
    duracao?: boolean
    frequencia?: boolean
    visibilidade?: boolean
    instrucoesAluno?: boolean
    orientacoesPublicas?: boolean
    status?: boolean
    programaId?: boolean
  }

  export type TipoAtendimentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "sigla" | "descricao" | "publico" | "duracao" | "frequencia" | "visibilidade" | "instrucoesAluno" | "orientacoesPublicas" | "status" | "programaId", ExtArgs["result"]["tipoAtendimento"]>
  export type TipoAtendimentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }
  export type TipoAtendimentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }
  export type TipoAtendimentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }

  export type $TipoAtendimentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoAtendimento"
    objects: {
      programa: Prisma.$ProgramaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      sigla: string
      descricao: string | null
      publico: string | null
      duracao: number | null
      frequencia: string | null
      visibilidade: $Enums.Visibilidade
      instrucoesAluno: string | null
      orientacoesPublicas: string | null
      status: string
      programaId: string
    }, ExtArgs["result"]["tipoAtendimento"]>
    composites: {}
  }

  type TipoAtendimentoGetPayload<S extends boolean | null | undefined | TipoAtendimentoDefaultArgs> = $Result.GetResult<Prisma.$TipoAtendimentoPayload, S>

  type TipoAtendimentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoAtendimentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoAtendimentoCountAggregateInputType | true
    }

  export interface TipoAtendimentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoAtendimento'], meta: { name: 'TipoAtendimento' } }
    /**
     * Find zero or one TipoAtendimento that matches the filter.
     * @param {TipoAtendimentoFindUniqueArgs} args - Arguments to find a TipoAtendimento
     * @example
     * // Get one TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoAtendimentoFindUniqueArgs>(args: SelectSubset<T, TipoAtendimentoFindUniqueArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoAtendimento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoAtendimentoFindUniqueOrThrowArgs} args - Arguments to find a TipoAtendimento
     * @example
     * // Get one TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoAtendimentoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoAtendimentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAtendimento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoFindFirstArgs} args - Arguments to find a TipoAtendimento
     * @example
     * // Get one TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoAtendimentoFindFirstArgs>(args?: SelectSubset<T, TipoAtendimentoFindFirstArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAtendimento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoFindFirstOrThrowArgs} args - Arguments to find a TipoAtendimento
     * @example
     * // Get one TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoAtendimentoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoAtendimentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoAtendimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoAtendimentos
     * const tipoAtendimentos = await prisma.tipoAtendimento.findMany()
     * 
     * // Get first 10 TipoAtendimentos
     * const tipoAtendimentos = await prisma.tipoAtendimento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoAtendimentoWithIdOnly = await prisma.tipoAtendimento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoAtendimentoFindManyArgs>(args?: SelectSubset<T, TipoAtendimentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoAtendimento.
     * @param {TipoAtendimentoCreateArgs} args - Arguments to create a TipoAtendimento.
     * @example
     * // Create one TipoAtendimento
     * const TipoAtendimento = await prisma.tipoAtendimento.create({
     *   data: {
     *     // ... data to create a TipoAtendimento
     *   }
     * })
     * 
     */
    create<T extends TipoAtendimentoCreateArgs>(args: SelectSubset<T, TipoAtendimentoCreateArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoAtendimentos.
     * @param {TipoAtendimentoCreateManyArgs} args - Arguments to create many TipoAtendimentos.
     * @example
     * // Create many TipoAtendimentos
     * const tipoAtendimento = await prisma.tipoAtendimento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoAtendimentoCreateManyArgs>(args?: SelectSubset<T, TipoAtendimentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoAtendimentos and returns the data saved in the database.
     * @param {TipoAtendimentoCreateManyAndReturnArgs} args - Arguments to create many TipoAtendimentos.
     * @example
     * // Create many TipoAtendimentos
     * const tipoAtendimento = await prisma.tipoAtendimento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoAtendimentos and only return the `id`
     * const tipoAtendimentoWithIdOnly = await prisma.tipoAtendimento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoAtendimentoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoAtendimentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoAtendimento.
     * @param {TipoAtendimentoDeleteArgs} args - Arguments to delete one TipoAtendimento.
     * @example
     * // Delete one TipoAtendimento
     * const TipoAtendimento = await prisma.tipoAtendimento.delete({
     *   where: {
     *     // ... filter to delete one TipoAtendimento
     *   }
     * })
     * 
     */
    delete<T extends TipoAtendimentoDeleteArgs>(args: SelectSubset<T, TipoAtendimentoDeleteArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoAtendimento.
     * @param {TipoAtendimentoUpdateArgs} args - Arguments to update one TipoAtendimento.
     * @example
     * // Update one TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoAtendimentoUpdateArgs>(args: SelectSubset<T, TipoAtendimentoUpdateArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoAtendimentos.
     * @param {TipoAtendimentoDeleteManyArgs} args - Arguments to filter TipoAtendimentos to delete.
     * @example
     * // Delete a few TipoAtendimentos
     * const { count } = await prisma.tipoAtendimento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoAtendimentoDeleteManyArgs>(args?: SelectSubset<T, TipoAtendimentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAtendimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoAtendimentos
     * const tipoAtendimento = await prisma.tipoAtendimento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoAtendimentoUpdateManyArgs>(args: SelectSubset<T, TipoAtendimentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAtendimentos and returns the data updated in the database.
     * @param {TipoAtendimentoUpdateManyAndReturnArgs} args - Arguments to update many TipoAtendimentos.
     * @example
     * // Update many TipoAtendimentos
     * const tipoAtendimento = await prisma.tipoAtendimento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoAtendimentos and only return the `id`
     * const tipoAtendimentoWithIdOnly = await prisma.tipoAtendimento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoAtendimentoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoAtendimentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoAtendimento.
     * @param {TipoAtendimentoUpsertArgs} args - Arguments to update or create a TipoAtendimento.
     * @example
     * // Update or create a TipoAtendimento
     * const tipoAtendimento = await prisma.tipoAtendimento.upsert({
     *   create: {
     *     // ... data to create a TipoAtendimento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoAtendimento we want to update
     *   }
     * })
     */
    upsert<T extends TipoAtendimentoUpsertArgs>(args: SelectSubset<T, TipoAtendimentoUpsertArgs<ExtArgs>>): Prisma__TipoAtendimentoClient<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoAtendimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoCountArgs} args - Arguments to filter TipoAtendimentos to count.
     * @example
     * // Count the number of TipoAtendimentos
     * const count = await prisma.tipoAtendimento.count({
     *   where: {
     *     // ... the filter for the TipoAtendimentos we want to count
     *   }
     * })
    **/
    count<T extends TipoAtendimentoCountArgs>(
      args?: Subset<T, TipoAtendimentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoAtendimentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoAtendimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAtendimentoAggregateArgs>(args: Subset<T, TipoAtendimentoAggregateArgs>): Prisma.PrismaPromise<GetTipoAtendimentoAggregateType<T>>

    /**
     * Group by TipoAtendimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtendimentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoAtendimentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoAtendimentoGroupByArgs['orderBy'] }
        : { orderBy?: TipoAtendimentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoAtendimentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoAtendimentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoAtendimento model
   */
  readonly fields: TipoAtendimentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoAtendimento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoAtendimentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programa<T extends ProgramaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramaDefaultArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoAtendimento model
   */
  interface TipoAtendimentoFieldRefs {
    readonly id: FieldRef<"TipoAtendimento", 'String'>
    readonly nome: FieldRef<"TipoAtendimento", 'String'>
    readonly sigla: FieldRef<"TipoAtendimento", 'String'>
    readonly descricao: FieldRef<"TipoAtendimento", 'String'>
    readonly publico: FieldRef<"TipoAtendimento", 'String'>
    readonly duracao: FieldRef<"TipoAtendimento", 'Int'>
    readonly frequencia: FieldRef<"TipoAtendimento", 'String'>
    readonly visibilidade: FieldRef<"TipoAtendimento", 'Visibilidade'>
    readonly instrucoesAluno: FieldRef<"TipoAtendimento", 'String'>
    readonly orientacoesPublicas: FieldRef<"TipoAtendimento", 'String'>
    readonly status: FieldRef<"TipoAtendimento", 'String'>
    readonly programaId: FieldRef<"TipoAtendimento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoAtendimento findUnique
   */
  export type TipoAtendimentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAtendimento to fetch.
     */
    where: TipoAtendimentoWhereUniqueInput
  }

  /**
   * TipoAtendimento findUniqueOrThrow
   */
  export type TipoAtendimentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAtendimento to fetch.
     */
    where: TipoAtendimentoWhereUniqueInput
  }

  /**
   * TipoAtendimento findFirst
   */
  export type TipoAtendimentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAtendimento to fetch.
     */
    where?: TipoAtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentos to fetch.
     */
    orderBy?: TipoAtendimentoOrderByWithRelationInput | TipoAtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAtendimentos.
     */
    cursor?: TipoAtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAtendimentos.
     */
    distinct?: TipoAtendimentoScalarFieldEnum | TipoAtendimentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimento findFirstOrThrow
   */
  export type TipoAtendimentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAtendimento to fetch.
     */
    where?: TipoAtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentos to fetch.
     */
    orderBy?: TipoAtendimentoOrderByWithRelationInput | TipoAtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAtendimentos.
     */
    cursor?: TipoAtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAtendimentos.
     */
    distinct?: TipoAtendimentoScalarFieldEnum | TipoAtendimentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimento findMany
   */
  export type TipoAtendimentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAtendimentos to fetch.
     */
    where?: TipoAtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAtendimentos to fetch.
     */
    orderBy?: TipoAtendimentoOrderByWithRelationInput | TipoAtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoAtendimentos.
     */
    cursor?: TipoAtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAtendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAtendimentos.
     */
    skip?: number
    distinct?: TipoAtendimentoScalarFieldEnum | TipoAtendimentoScalarFieldEnum[]
  }

  /**
   * TipoAtendimento create
   */
  export type TipoAtendimentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoAtendimento.
     */
    data: XOR<TipoAtendimentoCreateInput, TipoAtendimentoUncheckedCreateInput>
  }

  /**
   * TipoAtendimento createMany
   */
  export type TipoAtendimentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoAtendimentos.
     */
    data: TipoAtendimentoCreateManyInput | TipoAtendimentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoAtendimento createManyAndReturn
   */
  export type TipoAtendimentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoAtendimentos.
     */
    data: TipoAtendimentoCreateManyInput | TipoAtendimentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TipoAtendimento update
   */
  export type TipoAtendimentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoAtendimento.
     */
    data: XOR<TipoAtendimentoUpdateInput, TipoAtendimentoUncheckedUpdateInput>
    /**
     * Choose, which TipoAtendimento to update.
     */
    where: TipoAtendimentoWhereUniqueInput
  }

  /**
   * TipoAtendimento updateMany
   */
  export type TipoAtendimentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoAtendimentos.
     */
    data: XOR<TipoAtendimentoUpdateManyMutationInput, TipoAtendimentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAtendimentos to update
     */
    where?: TipoAtendimentoWhereInput
    /**
     * Limit how many TipoAtendimentos to update.
     */
    limit?: number
  }

  /**
   * TipoAtendimento updateManyAndReturn
   */
  export type TipoAtendimentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * The data used to update TipoAtendimentos.
     */
    data: XOR<TipoAtendimentoUpdateManyMutationInput, TipoAtendimentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAtendimentos to update
     */
    where?: TipoAtendimentoWhereInput
    /**
     * Limit how many TipoAtendimentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TipoAtendimento upsert
   */
  export type TipoAtendimentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoAtendimento to update in case it exists.
     */
    where: TipoAtendimentoWhereUniqueInput
    /**
     * In case the TipoAtendimento found by the `where` argument doesn't exist, create a new TipoAtendimento with this data.
     */
    create: XOR<TipoAtendimentoCreateInput, TipoAtendimentoUncheckedCreateInput>
    /**
     * In case the TipoAtendimento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoAtendimentoUpdateInput, TipoAtendimentoUncheckedUpdateInput>
  }

  /**
   * TipoAtendimento delete
   */
  export type TipoAtendimentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    /**
     * Filter which TipoAtendimento to delete.
     */
    where: TipoAtendimentoWhereUniqueInput
  }

  /**
   * TipoAtendimento deleteMany
   */
  export type TipoAtendimentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAtendimentos to delete
     */
    where?: TipoAtendimentoWhereInput
    /**
     * Limit how many TipoAtendimentos to delete.
     */
    limit?: number
  }

  /**
   * TipoAtendimento without action
   */
  export type TipoAtendimentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
  }


  /**
   * Model Programa
   */

  export type AggregatePrograma = {
    _count: ProgramaCountAggregateOutputType | null
    _min: ProgramaMinAggregateOutputType | null
    _max: ProgramaMaxAggregateOutputType | null
  }

  export type ProgramaMinAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    tipo: string | null
    status: string | null
    sala: string | null
    inicio: Date | null
    fim: Date | null
    curso: string | null
    assistentes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramaMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    tipo: string | null
    status: string | null
    sala: string | null
    inicio: Date | null
    fim: Date | null
    curso: string | null
    assistentes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramaCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    tipo: number
    status: number
    sala: number
    inicio: number
    fim: number
    curso: number
    assistentes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramaMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    tipo?: true
    status?: true
    sala?: true
    inicio?: true
    fim?: true
    curso?: true
    assistentes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramaMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    tipo?: true
    status?: true
    sala?: true
    inicio?: true
    fim?: true
    curso?: true
    assistentes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramaCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    tipo?: true
    status?: true
    sala?: true
    inicio?: true
    fim?: true
    curso?: true
    assistentes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programa to aggregate.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programas
    **/
    _count?: true | ProgramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramaMaxAggregateInputType
  }

  export type GetProgramaAggregateType<T extends ProgramaAggregateArgs> = {
        [P in keyof T & keyof AggregatePrograma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrograma[P]>
      : GetScalarType<T[P], AggregatePrograma[P]>
  }




  export type ProgramaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramaWhereInput
    orderBy?: ProgramaOrderByWithAggregationInput | ProgramaOrderByWithAggregationInput[]
    by: ProgramaScalarFieldEnum[] | ProgramaScalarFieldEnum
    having?: ProgramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramaCountAggregateInputType | true
    _min?: ProgramaMinAggregateInputType
    _max?: ProgramaMaxAggregateInputType
  }

  export type ProgramaGroupByOutputType = {
    id: string
    nome: string
    descricao: string | null
    tipo: string
    status: string
    sala: string | null
    inicio: Date | null
    fim: Date | null
    curso: string
    assistentes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProgramaCountAggregateOutputType | null
    _min: ProgramaMinAggregateOutputType | null
    _max: ProgramaMaxAggregateOutputType | null
  }

  type GetProgramaGroupByPayload<T extends ProgramaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramaGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramaGroupByOutputType[P]>
        }
      >
    >


  export type ProgramaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    tipo?: boolean
    status?: boolean
    sala?: boolean
    inicio?: boolean
    fim?: boolean
    curso?: boolean
    assistentes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tiposAtendimento?: boolean | Programa$tiposAtendimentoArgs<ExtArgs>
    Escala?: boolean | Programa$EscalaArgs<ExtArgs>
    _count?: boolean | ProgramaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programa"]>

  export type ProgramaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    tipo?: boolean
    status?: boolean
    sala?: boolean
    inicio?: boolean
    fim?: boolean
    curso?: boolean
    assistentes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programa"]>

  export type ProgramaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    tipo?: boolean
    status?: boolean
    sala?: boolean
    inicio?: boolean
    fim?: boolean
    curso?: boolean
    assistentes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["programa"]>

  export type ProgramaSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
    tipo?: boolean
    status?: boolean
    sala?: boolean
    inicio?: boolean
    fim?: boolean
    curso?: boolean
    assistentes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "descricao" | "tipo" | "status" | "sala" | "inicio" | "fim" | "curso" | "assistentes" | "createdAt" | "updatedAt", ExtArgs["result"]["programa"]>
  export type ProgramaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiposAtendimento?: boolean | Programa$tiposAtendimentoArgs<ExtArgs>
    Escala?: boolean | Programa$EscalaArgs<ExtArgs>
    _count?: boolean | ProgramaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Programa"
    objects: {
      tiposAtendimento: Prisma.$TipoAtendimentoPayload<ExtArgs>[]
      Escala: Prisma.$EscalaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      descricao: string | null
      tipo: string
      status: string
      sala: string | null
      inicio: Date | null
      fim: Date | null
      curso: string
      assistentes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["programa"]>
    composites: {}
  }

  type ProgramaGetPayload<S extends boolean | null | undefined | ProgramaDefaultArgs> = $Result.GetResult<Prisma.$ProgramaPayload, S>

  type ProgramaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramaCountAggregateInputType | true
    }

  export interface ProgramaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Programa'], meta: { name: 'Programa' } }
    /**
     * Find zero or one Programa that matches the filter.
     * @param {ProgramaFindUniqueArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramaFindUniqueArgs>(args: SelectSubset<T, ProgramaFindUniqueArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Programa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramaFindUniqueOrThrowArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Programa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindFirstArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramaFindFirstArgs>(args?: SelectSubset<T, ProgramaFindFirstArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Programa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindFirstOrThrowArgs} args - Arguments to find a Programa
     * @example
     * // Get one Programa
     * const programa = await prisma.programa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programas
     * const programas = await prisma.programa.findMany()
     * 
     * // Get first 10 Programas
     * const programas = await prisma.programa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programaWithIdOnly = await prisma.programa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramaFindManyArgs>(args?: SelectSubset<T, ProgramaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Programa.
     * @param {ProgramaCreateArgs} args - Arguments to create a Programa.
     * @example
     * // Create one Programa
     * const Programa = await prisma.programa.create({
     *   data: {
     *     // ... data to create a Programa
     *   }
     * })
     * 
     */
    create<T extends ProgramaCreateArgs>(args: SelectSubset<T, ProgramaCreateArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programas.
     * @param {ProgramaCreateManyArgs} args - Arguments to create many Programas.
     * @example
     * // Create many Programas
     * const programa = await prisma.programa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramaCreateManyArgs>(args?: SelectSubset<T, ProgramaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programas and returns the data saved in the database.
     * @param {ProgramaCreateManyAndReturnArgs} args - Arguments to create many Programas.
     * @example
     * // Create many Programas
     * const programa = await prisma.programa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programas and only return the `id`
     * const programaWithIdOnly = await prisma.programa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Programa.
     * @param {ProgramaDeleteArgs} args - Arguments to delete one Programa.
     * @example
     * // Delete one Programa
     * const Programa = await prisma.programa.delete({
     *   where: {
     *     // ... filter to delete one Programa
     *   }
     * })
     * 
     */
    delete<T extends ProgramaDeleteArgs>(args: SelectSubset<T, ProgramaDeleteArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Programa.
     * @param {ProgramaUpdateArgs} args - Arguments to update one Programa.
     * @example
     * // Update one Programa
     * const programa = await prisma.programa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramaUpdateArgs>(args: SelectSubset<T, ProgramaUpdateArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programas.
     * @param {ProgramaDeleteManyArgs} args - Arguments to filter Programas to delete.
     * @example
     * // Delete a few Programas
     * const { count } = await prisma.programa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramaDeleteManyArgs>(args?: SelectSubset<T, ProgramaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programas
     * const programa = await prisma.programa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramaUpdateManyArgs>(args: SelectSubset<T, ProgramaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programas and returns the data updated in the database.
     * @param {ProgramaUpdateManyAndReturnArgs} args - Arguments to update many Programas.
     * @example
     * // Update many Programas
     * const programa = await prisma.programa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programas and only return the `id`
     * const programaWithIdOnly = await prisma.programa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Programa.
     * @param {ProgramaUpsertArgs} args - Arguments to update or create a Programa.
     * @example
     * // Update or create a Programa
     * const programa = await prisma.programa.upsert({
     *   create: {
     *     // ... data to create a Programa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programa we want to update
     *   }
     * })
     */
    upsert<T extends ProgramaUpsertArgs>(args: SelectSubset<T, ProgramaUpsertArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaCountArgs} args - Arguments to filter Programas to count.
     * @example
     * // Count the number of Programas
     * const count = await prisma.programa.count({
     *   where: {
     *     // ... the filter for the Programas we want to count
     *   }
     * })
    **/
    count<T extends ProgramaCountArgs>(
      args?: Subset<T, ProgramaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramaAggregateArgs>(args: Subset<T, ProgramaAggregateArgs>): Prisma.PrismaPromise<GetProgramaAggregateType<T>>

    /**
     * Group by Programa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramaGroupByArgs['orderBy'] }
        : { orderBy?: ProgramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Programa model
   */
  readonly fields: ProgramaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tiposAtendimento<T extends Programa$tiposAtendimentoArgs<ExtArgs> = {}>(args?: Subset<T, Programa$tiposAtendimentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAtendimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Escala<T extends Programa$EscalaArgs<ExtArgs> = {}>(args?: Subset<T, Programa$EscalaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Programa model
   */
  interface ProgramaFieldRefs {
    readonly id: FieldRef<"Programa", 'String'>
    readonly nome: FieldRef<"Programa", 'String'>
    readonly descricao: FieldRef<"Programa", 'String'>
    readonly tipo: FieldRef<"Programa", 'String'>
    readonly status: FieldRef<"Programa", 'String'>
    readonly sala: FieldRef<"Programa", 'String'>
    readonly inicio: FieldRef<"Programa", 'DateTime'>
    readonly fim: FieldRef<"Programa", 'DateTime'>
    readonly curso: FieldRef<"Programa", 'String'>
    readonly assistentes: FieldRef<"Programa", 'String'>
    readonly createdAt: FieldRef<"Programa", 'DateTime'>
    readonly updatedAt: FieldRef<"Programa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Programa findUnique
   */
  export type ProgramaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa findUniqueOrThrow
   */
  export type ProgramaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa findFirst
   */
  export type ProgramaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programas.
     */
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa findFirstOrThrow
   */
  export type ProgramaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programa to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programas.
     */
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa findMany
   */
  export type ProgramaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter, which Programas to fetch.
     */
    where?: ProgramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programas to fetch.
     */
    orderBy?: ProgramaOrderByWithRelationInput | ProgramaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programas.
     */
    cursor?: ProgramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programas.
     */
    skip?: number
    distinct?: ProgramaScalarFieldEnum | ProgramaScalarFieldEnum[]
  }

  /**
   * Programa create
   */
  export type ProgramaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The data needed to create a Programa.
     */
    data: XOR<ProgramaCreateInput, ProgramaUncheckedCreateInput>
  }

  /**
   * Programa createMany
   */
  export type ProgramaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programas.
     */
    data: ProgramaCreateManyInput | ProgramaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programa createManyAndReturn
   */
  export type ProgramaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * The data used to create many Programas.
     */
    data: ProgramaCreateManyInput | ProgramaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programa update
   */
  export type ProgramaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The data needed to update a Programa.
     */
    data: XOR<ProgramaUpdateInput, ProgramaUncheckedUpdateInput>
    /**
     * Choose, which Programa to update.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa updateMany
   */
  export type ProgramaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programas.
     */
    data: XOR<ProgramaUpdateManyMutationInput, ProgramaUncheckedUpdateManyInput>
    /**
     * Filter which Programas to update
     */
    where?: ProgramaWhereInput
    /**
     * Limit how many Programas to update.
     */
    limit?: number
  }

  /**
   * Programa updateManyAndReturn
   */
  export type ProgramaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * The data used to update Programas.
     */
    data: XOR<ProgramaUpdateManyMutationInput, ProgramaUncheckedUpdateManyInput>
    /**
     * Filter which Programas to update
     */
    where?: ProgramaWhereInput
    /**
     * Limit how many Programas to update.
     */
    limit?: number
  }

  /**
   * Programa upsert
   */
  export type ProgramaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * The filter to search for the Programa to update in case it exists.
     */
    where: ProgramaWhereUniqueInput
    /**
     * In case the Programa found by the `where` argument doesn't exist, create a new Programa with this data.
     */
    create: XOR<ProgramaCreateInput, ProgramaUncheckedCreateInput>
    /**
     * In case the Programa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramaUpdateInput, ProgramaUncheckedUpdateInput>
  }

  /**
   * Programa delete
   */
  export type ProgramaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
    /**
     * Filter which Programa to delete.
     */
    where: ProgramaWhereUniqueInput
  }

  /**
   * Programa deleteMany
   */
  export type ProgramaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programas to delete
     */
    where?: ProgramaWhereInput
    /**
     * Limit how many Programas to delete.
     */
    limit?: number
  }

  /**
   * Programa.tiposAtendimento
   */
  export type Programa$tiposAtendimentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtendimento
     */
    select?: TipoAtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAtendimento
     */
    omit?: TipoAtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAtendimentoInclude<ExtArgs> | null
    where?: TipoAtendimentoWhereInput
    orderBy?: TipoAtendimentoOrderByWithRelationInput | TipoAtendimentoOrderByWithRelationInput[]
    cursor?: TipoAtendimentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TipoAtendimentoScalarFieldEnum | TipoAtendimentoScalarFieldEnum[]
  }

  /**
   * Programa.Escala
   */
  export type Programa$EscalaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    where?: EscalaWhereInput
    orderBy?: EscalaOrderByWithRelationInput | EscalaOrderByWithRelationInput[]
    cursor?: EscalaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EscalaScalarFieldEnum | EscalaScalarFieldEnum[]
  }

  /**
   * Programa without action
   */
  export type ProgramaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programa
     */
    select?: ProgramaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Programa
     */
    omit?: ProgramaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramaInclude<ExtArgs> | null
  }


  /**
   * Model Escala
   */

  export type AggregateEscala = {
    _count: EscalaCountAggregateOutputType | null
    _min: EscalaMinAggregateOutputType | null
    _max: EscalaMaxAggregateOutputType | null
  }

  export type EscalaMinAggregateOutputType = {
    id: string | null
    nome: string | null
    matricula: string | null
    curso: string | null
    status: string | null
    programaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscalaMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    matricula: string | null
    curso: string | null
    status: string | null
    programaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EscalaCountAggregateOutputType = {
    id: number
    nome: number
    matricula: number
    curso: number
    status: number
    turnos: number
    programaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EscalaMinAggregateInputType = {
    id?: true
    nome?: true
    matricula?: true
    curso?: true
    status?: true
    programaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscalaMaxAggregateInputType = {
    id?: true
    nome?: true
    matricula?: true
    curso?: true
    status?: true
    programaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EscalaCountAggregateInputType = {
    id?: true
    nome?: true
    matricula?: true
    curso?: true
    status?: true
    turnos?: true
    programaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EscalaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escala to aggregate.
     */
    where?: EscalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escalas to fetch.
     */
    orderBy?: EscalaOrderByWithRelationInput | EscalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escalas
    **/
    _count?: true | EscalaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscalaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscalaMaxAggregateInputType
  }

  export type GetEscalaAggregateType<T extends EscalaAggregateArgs> = {
        [P in keyof T & keyof AggregateEscala]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscala[P]>
      : GetScalarType<T[P], AggregateEscala[P]>
  }




  export type EscalaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscalaWhereInput
    orderBy?: EscalaOrderByWithAggregationInput | EscalaOrderByWithAggregationInput[]
    by: EscalaScalarFieldEnum[] | EscalaScalarFieldEnum
    having?: EscalaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscalaCountAggregateInputType | true
    _min?: EscalaMinAggregateInputType
    _max?: EscalaMaxAggregateInputType
  }

  export type EscalaGroupByOutputType = {
    id: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos: string[]
    programaId: string
    createdAt: Date
    updatedAt: Date
    _count: EscalaCountAggregateOutputType | null
    _min: EscalaMinAggregateOutputType | null
    _max: EscalaMaxAggregateOutputType | null
  }

  type GetEscalaGroupByPayload<T extends EscalaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscalaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscalaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscalaGroupByOutputType[P]>
            : GetScalarType<T[P], EscalaGroupByOutputType[P]>
        }
      >
    >


  export type EscalaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    matricula?: boolean
    curso?: boolean
    status?: boolean
    turnos?: boolean
    programaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escala"]>

  export type EscalaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    matricula?: boolean
    curso?: boolean
    status?: boolean
    turnos?: boolean
    programaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escala"]>

  export type EscalaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    matricula?: boolean
    curso?: boolean
    status?: boolean
    turnos?: boolean
    programaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escala"]>

  export type EscalaSelectScalar = {
    id?: boolean
    nome?: boolean
    matricula?: boolean
    curso?: boolean
    status?: boolean
    turnos?: boolean
    programaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EscalaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "matricula" | "curso" | "status" | "turnos" | "programaId" | "createdAt" | "updatedAt", ExtArgs["result"]["escala"]>
  export type EscalaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }
  export type EscalaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }
  export type EscalaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programa?: boolean | ProgramaDefaultArgs<ExtArgs>
  }

  export type $EscalaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Escala"
    objects: {
      programa: Prisma.$ProgramaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      matricula: string
      curso: string
      status: string
      turnos: string[]
      programaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["escala"]>
    composites: {}
  }

  type EscalaGetPayload<S extends boolean | null | undefined | EscalaDefaultArgs> = $Result.GetResult<Prisma.$EscalaPayload, S>

  type EscalaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EscalaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EscalaCountAggregateInputType | true
    }

  export interface EscalaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escala'], meta: { name: 'Escala' } }
    /**
     * Find zero or one Escala that matches the filter.
     * @param {EscalaFindUniqueArgs} args - Arguments to find a Escala
     * @example
     * // Get one Escala
     * const escala = await prisma.escala.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscalaFindUniqueArgs>(args: SelectSubset<T, EscalaFindUniqueArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escala that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EscalaFindUniqueOrThrowArgs} args - Arguments to find a Escala
     * @example
     * // Get one Escala
     * const escala = await prisma.escala.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscalaFindUniqueOrThrowArgs>(args: SelectSubset<T, EscalaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escala that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaFindFirstArgs} args - Arguments to find a Escala
     * @example
     * // Get one Escala
     * const escala = await prisma.escala.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscalaFindFirstArgs>(args?: SelectSubset<T, EscalaFindFirstArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escala that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaFindFirstOrThrowArgs} args - Arguments to find a Escala
     * @example
     * // Get one Escala
     * const escala = await prisma.escala.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscalaFindFirstOrThrowArgs>(args?: SelectSubset<T, EscalaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escalas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escalas
     * const escalas = await prisma.escala.findMany()
     * 
     * // Get first 10 Escalas
     * const escalas = await prisma.escala.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escalaWithIdOnly = await prisma.escala.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscalaFindManyArgs>(args?: SelectSubset<T, EscalaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escala.
     * @param {EscalaCreateArgs} args - Arguments to create a Escala.
     * @example
     * // Create one Escala
     * const Escala = await prisma.escala.create({
     *   data: {
     *     // ... data to create a Escala
     *   }
     * })
     * 
     */
    create<T extends EscalaCreateArgs>(args: SelectSubset<T, EscalaCreateArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escalas.
     * @param {EscalaCreateManyArgs} args - Arguments to create many Escalas.
     * @example
     * // Create many Escalas
     * const escala = await prisma.escala.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscalaCreateManyArgs>(args?: SelectSubset<T, EscalaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escalas and returns the data saved in the database.
     * @param {EscalaCreateManyAndReturnArgs} args - Arguments to create many Escalas.
     * @example
     * // Create many Escalas
     * const escala = await prisma.escala.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escalas and only return the `id`
     * const escalaWithIdOnly = await prisma.escala.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscalaCreateManyAndReturnArgs>(args?: SelectSubset<T, EscalaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escala.
     * @param {EscalaDeleteArgs} args - Arguments to delete one Escala.
     * @example
     * // Delete one Escala
     * const Escala = await prisma.escala.delete({
     *   where: {
     *     // ... filter to delete one Escala
     *   }
     * })
     * 
     */
    delete<T extends EscalaDeleteArgs>(args: SelectSubset<T, EscalaDeleteArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escala.
     * @param {EscalaUpdateArgs} args - Arguments to update one Escala.
     * @example
     * // Update one Escala
     * const escala = await prisma.escala.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscalaUpdateArgs>(args: SelectSubset<T, EscalaUpdateArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escalas.
     * @param {EscalaDeleteManyArgs} args - Arguments to filter Escalas to delete.
     * @example
     * // Delete a few Escalas
     * const { count } = await prisma.escala.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscalaDeleteManyArgs>(args?: SelectSubset<T, EscalaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escalas
     * const escala = await prisma.escala.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscalaUpdateManyArgs>(args: SelectSubset<T, EscalaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escalas and returns the data updated in the database.
     * @param {EscalaUpdateManyAndReturnArgs} args - Arguments to update many Escalas.
     * @example
     * // Update many Escalas
     * const escala = await prisma.escala.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escalas and only return the `id`
     * const escalaWithIdOnly = await prisma.escala.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EscalaUpdateManyAndReturnArgs>(args: SelectSubset<T, EscalaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escala.
     * @param {EscalaUpsertArgs} args - Arguments to update or create a Escala.
     * @example
     * // Update or create a Escala
     * const escala = await prisma.escala.upsert({
     *   create: {
     *     // ... data to create a Escala
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escala we want to update
     *   }
     * })
     */
    upsert<T extends EscalaUpsertArgs>(args: SelectSubset<T, EscalaUpsertArgs<ExtArgs>>): Prisma__EscalaClient<$Result.GetResult<Prisma.$EscalaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaCountArgs} args - Arguments to filter Escalas to count.
     * @example
     * // Count the number of Escalas
     * const count = await prisma.escala.count({
     *   where: {
     *     // ... the filter for the Escalas we want to count
     *   }
     * })
    **/
    count<T extends EscalaCountArgs>(
      args?: Subset<T, EscalaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscalaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscalaAggregateArgs>(args: Subset<T, EscalaAggregateArgs>): Prisma.PrismaPromise<GetEscalaAggregateType<T>>

    /**
     * Group by Escala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscalaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscalaGroupByArgs['orderBy'] }
        : { orderBy?: EscalaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscalaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscalaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escala model
   */
  readonly fields: EscalaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escala.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscalaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programa<T extends ProgramaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramaDefaultArgs<ExtArgs>>): Prisma__ProgramaClient<$Result.GetResult<Prisma.$ProgramaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Escala model
   */
  interface EscalaFieldRefs {
    readonly id: FieldRef<"Escala", 'String'>
    readonly nome: FieldRef<"Escala", 'String'>
    readonly matricula: FieldRef<"Escala", 'String'>
    readonly curso: FieldRef<"Escala", 'String'>
    readonly status: FieldRef<"Escala", 'String'>
    readonly turnos: FieldRef<"Escala", 'String[]'>
    readonly programaId: FieldRef<"Escala", 'String'>
    readonly createdAt: FieldRef<"Escala", 'DateTime'>
    readonly updatedAt: FieldRef<"Escala", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Escala findUnique
   */
  export type EscalaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter, which Escala to fetch.
     */
    where: EscalaWhereUniqueInput
  }

  /**
   * Escala findUniqueOrThrow
   */
  export type EscalaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter, which Escala to fetch.
     */
    where: EscalaWhereUniqueInput
  }

  /**
   * Escala findFirst
   */
  export type EscalaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter, which Escala to fetch.
     */
    where?: EscalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escalas to fetch.
     */
    orderBy?: EscalaOrderByWithRelationInput | EscalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escalas.
     */
    cursor?: EscalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escalas.
     */
    distinct?: EscalaScalarFieldEnum | EscalaScalarFieldEnum[]
  }

  /**
   * Escala findFirstOrThrow
   */
  export type EscalaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter, which Escala to fetch.
     */
    where?: EscalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escalas to fetch.
     */
    orderBy?: EscalaOrderByWithRelationInput | EscalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escalas.
     */
    cursor?: EscalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escalas.
     */
    distinct?: EscalaScalarFieldEnum | EscalaScalarFieldEnum[]
  }

  /**
   * Escala findMany
   */
  export type EscalaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter, which Escalas to fetch.
     */
    where?: EscalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escalas to fetch.
     */
    orderBy?: EscalaOrderByWithRelationInput | EscalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escalas.
     */
    cursor?: EscalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escalas.
     */
    skip?: number
    distinct?: EscalaScalarFieldEnum | EscalaScalarFieldEnum[]
  }

  /**
   * Escala create
   */
  export type EscalaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * The data needed to create a Escala.
     */
    data: XOR<EscalaCreateInput, EscalaUncheckedCreateInput>
  }

  /**
   * Escala createMany
   */
  export type EscalaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escalas.
     */
    data: EscalaCreateManyInput | EscalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escala createManyAndReturn
   */
  export type EscalaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * The data used to create many Escalas.
     */
    data: EscalaCreateManyInput | EscalaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Escala update
   */
  export type EscalaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * The data needed to update a Escala.
     */
    data: XOR<EscalaUpdateInput, EscalaUncheckedUpdateInput>
    /**
     * Choose, which Escala to update.
     */
    where: EscalaWhereUniqueInput
  }

  /**
   * Escala updateMany
   */
  export type EscalaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escalas.
     */
    data: XOR<EscalaUpdateManyMutationInput, EscalaUncheckedUpdateManyInput>
    /**
     * Filter which Escalas to update
     */
    where?: EscalaWhereInput
    /**
     * Limit how many Escalas to update.
     */
    limit?: number
  }

  /**
   * Escala updateManyAndReturn
   */
  export type EscalaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * The data used to update Escalas.
     */
    data: XOR<EscalaUpdateManyMutationInput, EscalaUncheckedUpdateManyInput>
    /**
     * Filter which Escalas to update
     */
    where?: EscalaWhereInput
    /**
     * Limit how many Escalas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Escala upsert
   */
  export type EscalaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * The filter to search for the Escala to update in case it exists.
     */
    where: EscalaWhereUniqueInput
    /**
     * In case the Escala found by the `where` argument doesn't exist, create a new Escala with this data.
     */
    create: XOR<EscalaCreateInput, EscalaUncheckedCreateInput>
    /**
     * In case the Escala was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscalaUpdateInput, EscalaUncheckedUpdateInput>
  }

  /**
   * Escala delete
   */
  export type EscalaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
    /**
     * Filter which Escala to delete.
     */
    where: EscalaWhereUniqueInput
  }

  /**
   * Escala deleteMany
   */
  export type EscalaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escalas to delete
     */
    where?: EscalaWhereInput
    /**
     * Limit how many Escalas to delete.
     */
    limit?: number
  }

  /**
   * Escala without action
   */
  export type EscalaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escala
     */
    select?: EscalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escala
     */
    omit?: EscalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    email: 'email',
    userName: 'userName',
    passwordHash: 'passwordHash',
    authProvider: 'authProvider',
    isVerified: 'isVerified',
    CreatedAt: 'CreatedAt',
    updatedAt: 'updatedAt',
    providerId: 'providerId',
    isAdmin: 'isAdmin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    title: 'title',
    description: 'description',
    visibility: 'visibility',
    isArchived: 'isArchived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const BoardMemberScalarFieldEnum: {
    boardId: 'boardId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type BoardMemberScalarFieldEnum = (typeof BoardMemberScalarFieldEnum)[keyof typeof BoardMemberScalarFieldEnum]


  export const ListScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    title: 'title',
    position: 'position',
    isArchived: 'isArchived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListScalarFieldEnum = (typeof ListScalarFieldEnum)[keyof typeof ListScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    position: 'position',
    status: 'status',
    dueDate: 'dueDate',
    isArchived: 'isArchived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const TaskLabelScalarFieldEnum: {
    taskId: 'taskId',
    labelId: 'labelId'
  };

  export type TaskLabelScalarFieldEnum = (typeof TaskLabelScalarFieldEnum)[keyof typeof TaskLabelScalarFieldEnum]


  export const DashboardScalarFieldEnum: {
    id: 'id',
    cursos: 'cursos',
    programas: 'programas',
    usuarios: 'usuarios',
    atendimentosMes: 'atendimentosMes'
  };

  export type DashboardScalarFieldEnum = (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum]


  export const PendenciaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    dashboardId: 'dashboardId'
  };

  export type PendenciaScalarFieldEnum = (typeof PendenciaScalarFieldEnum)[keyof typeof PendenciaScalarFieldEnum]


  export const NotificacaoScalarFieldEnum: {
    id: 'id',
    mensagem: 'mensagem',
    dashboardId: 'dashboardId'
  };

  export type NotificacaoScalarFieldEnum = (typeof NotificacaoScalarFieldEnum)[keyof typeof NotificacaoScalarFieldEnum]


  export const GraficoCursoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    valor: 'valor',
    dashboardId: 'dashboardId'
  };

  export type GraficoCursoScalarFieldEnum = (typeof GraficoCursoScalarFieldEnum)[keyof typeof GraficoCursoScalarFieldEnum]


  export const GraficoBeneficiarioScalarFieldEnum: {
    id: 'id',
    label: 'label',
    valor: 'valor',
    dashboardId: 'dashboardId'
  };

  export type GraficoBeneficiarioScalarFieldEnum = (typeof GraficoBeneficiarioScalarFieldEnum)[keyof typeof GraficoBeneficiarioScalarFieldEnum]


  export const CursoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao',
    modalidade: 'modalidade',
    criadoEm: 'criadoEm'
  };

  export type CursoScalarFieldEnum = (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum]


  export const CoordenadorScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    telefone: 'telefone',
    cpf: 'cpf',
    status: 'status',
    cursos: 'cursos',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm',
    permissoes: 'permissoes'
  };

  export type CoordenadorScalarFieldEnum = (typeof CoordenadorScalarFieldEnum)[keyof typeof CoordenadorScalarFieldEnum]


  export const AgendamentoScalarFieldEnum: {
    id: 'id',
    beneficiario: 'beneficiario',
    programa: 'programa',
    tipo: 'tipo',
    aluno: 'aluno',
    data: 'data',
    turno: 'turno',
    status: 'status',
    criadoEm: 'criadoEm'
  };

  export type AgendamentoScalarFieldEnum = (typeof AgendamentoScalarFieldEnum)[keyof typeof AgendamentoScalarFieldEnum]


  export const ProgramaAgendamentoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type ProgramaAgendamentoScalarFieldEnum = (typeof ProgramaAgendamentoScalarFieldEnum)[keyof typeof ProgramaAgendamentoScalarFieldEnum]


  export const TipoAtendimentoAgendamentoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type TipoAtendimentoAgendamentoScalarFieldEnum = (typeof TipoAtendimentoAgendamentoScalarFieldEnum)[keyof typeof TipoAtendimentoAgendamentoScalarFieldEnum]


  export const AlunoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type AlunoScalarFieldEnum = (typeof AlunoScalarFieldEnum)[keyof typeof AlunoScalarFieldEnum]


  export const TipoAtendimentoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sigla: 'sigla',
    descricao: 'descricao',
    publico: 'publico',
    duracao: 'duracao',
    frequencia: 'frequencia',
    visibilidade: 'visibilidade',
    instrucoesAluno: 'instrucoesAluno',
    orientacoesPublicas: 'orientacoesPublicas',
    status: 'status',
    programaId: 'programaId'
  };

  export type TipoAtendimentoScalarFieldEnum = (typeof TipoAtendimentoScalarFieldEnum)[keyof typeof TipoAtendimentoScalarFieldEnum]


  export const ProgramaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao',
    tipo: 'tipo',
    status: 'status',
    sala: 'sala',
    inicio: 'inicio',
    fim: 'fim',
    curso: 'curso',
    assistentes: 'assistentes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramaScalarFieldEnum = (typeof ProgramaScalarFieldEnum)[keyof typeof ProgramaScalarFieldEnum]


  export const EscalaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    matricula: 'matricula',
    curso: 'curso',
    status: 'status',
    turnos: 'turnos',
    programaId: 'programaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EscalaScalarFieldEnum = (typeof EscalaScalarFieldEnum)[keyof typeof EscalaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BoardVisibility'
   */
  export type EnumBoardVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BoardVisibility'>
    


  /**
   * Reference to a field of type 'BoardVisibility[]'
   */
  export type ListEnumBoardVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BoardVisibility[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Visibilidade'
   */
  export type EnumVisibilidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibilidade'>
    


  /**
   * Reference to a field of type 'Visibilidade[]'
   */
  export type ListEnumVisibilidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibilidade[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    userName?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    isVerified?: BoolFilter<"User"> | boolean
    CreatedAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    providerId?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    boards?: BoardListRelationFilter
    memberships?: BoardMemberListRelationFilter
    tasksCreated?: TaskListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    userName?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    CreatedAt?: SortOrder
    updatedAt?: SortOrder
    providerId?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    boards?: BoardOrderByRelationAggregateInput
    memberships?: BoardMemberOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    userName?: string
    AuthProviderAndIdUnique?: UserAuthProviderAndIdUniqueCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    isVerified?: BoolFilter<"User"> | boolean
    CreatedAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    providerId?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    boards?: BoardListRelationFilter
    memberships?: BoardMemberListRelationFilter
    tasksCreated?: TaskListRelationFilter
  }, "id" | "email" | "userName" | "AuthProviderAndIdUnique">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    userName?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    CreatedAt?: SortOrder
    updatedAt?: SortOrder
    providerId?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    userName?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    authProvider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    providerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: StringFilter<"Board"> | string
    ownerId?: StringFilter<"Board"> | string
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    visibility?: EnumBoardVisibilityFilter<"Board"> | $Enums.BoardVisibility
    isArchived?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: BoardMemberListRelationFilter
    lists?: ListListRelationFilter
    labels?: LabelListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: BoardMemberOrderByRelationAggregateInput
    lists?: ListOrderByRelationAggregateInput
    labels?: LabelOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    ownerId?: StringFilter<"Board"> | string
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    visibility?: EnumBoardVisibilityFilter<"Board"> | $Enums.BoardVisibility
    isArchived?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: BoardMemberListRelationFilter
    lists?: ListListRelationFilter
    labels?: LabelListRelationFilter
  }, "id">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Board"> | string
    ownerId?: StringWithAggregatesFilter<"Board"> | string
    title?: StringWithAggregatesFilter<"Board"> | string
    description?: StringNullableWithAggregatesFilter<"Board"> | string | null
    visibility?: EnumBoardVisibilityWithAggregatesFilter<"Board"> | $Enums.BoardVisibility
    isArchived?: BoolWithAggregatesFilter<"Board"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
  }

  export type BoardMemberWhereInput = {
    AND?: BoardMemberWhereInput | BoardMemberWhereInput[]
    OR?: BoardMemberWhereInput[]
    NOT?: BoardMemberWhereInput | BoardMemberWhereInput[]
    boardId?: StringFilter<"BoardMember"> | string
    userId?: StringFilter<"BoardMember"> | string
    role?: EnumRoleFilter<"BoardMember"> | $Enums.Role
    joinedAt?: DateTimeFilter<"BoardMember"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BoardMemberOrderByWithRelationInput = {
    boardId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    board?: BoardOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BoardMemberWhereUniqueInput = Prisma.AtLeast<{
    boardId_userId?: BoardMemberBoardIdUserIdCompoundUniqueInput
    AND?: BoardMemberWhereInput | BoardMemberWhereInput[]
    OR?: BoardMemberWhereInput[]
    NOT?: BoardMemberWhereInput | BoardMemberWhereInput[]
    boardId?: StringFilter<"BoardMember"> | string
    userId?: StringFilter<"BoardMember"> | string
    role?: EnumRoleFilter<"BoardMember"> | $Enums.Role
    joinedAt?: DateTimeFilter<"BoardMember"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "boardId_userId">

  export type BoardMemberOrderByWithAggregationInput = {
    boardId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: BoardMemberCountOrderByAggregateInput
    _max?: BoardMemberMaxOrderByAggregateInput
    _min?: BoardMemberMinOrderByAggregateInput
  }

  export type BoardMemberScalarWhereWithAggregatesInput = {
    AND?: BoardMemberScalarWhereWithAggregatesInput | BoardMemberScalarWhereWithAggregatesInput[]
    OR?: BoardMemberScalarWhereWithAggregatesInput[]
    NOT?: BoardMemberScalarWhereWithAggregatesInput | BoardMemberScalarWhereWithAggregatesInput[]
    boardId?: StringWithAggregatesFilter<"BoardMember"> | string
    userId?: StringWithAggregatesFilter<"BoardMember"> | string
    role?: EnumRoleWithAggregatesFilter<"BoardMember"> | $Enums.Role
    joinedAt?: DateTimeWithAggregatesFilter<"BoardMember"> | Date | string
  }

  export type ListWhereInput = {
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    id?: StringFilter<"List"> | string
    boardId?: StringFilter<"List"> | string
    title?: StringFilter<"List"> | string
    position?: IntFilter<"List"> | number
    isArchived?: BoolFilter<"List"> | boolean
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type ListOrderByWithRelationInput = {
    id?: SortOrder
    boardId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    board?: BoardOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    boardId?: StringFilter<"List"> | string
    title?: StringFilter<"List"> | string
    position?: IntFilter<"List"> | number
    isArchived?: BoolFilter<"List"> | boolean
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type ListOrderByWithAggregationInput = {
    id?: SortOrder
    boardId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ListCountOrderByAggregateInput
    _avg?: ListAvgOrderByAggregateInput
    _max?: ListMaxOrderByAggregateInput
    _min?: ListMinOrderByAggregateInput
    _sum?: ListSumOrderByAggregateInput
  }

  export type ListScalarWhereWithAggregatesInput = {
    AND?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    OR?: ListScalarWhereWithAggregatesInput[]
    NOT?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"List"> | string
    boardId?: StringWithAggregatesFilter<"List"> | string
    title?: StringWithAggregatesFilter<"List"> | string
    position?: IntWithAggregatesFilter<"List"> | number
    isArchived?: BoolWithAggregatesFilter<"List"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    listId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    position?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isArchived?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    labels?: TaskLabelListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    list?: ListOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    labels?: TaskLabelOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    listId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    position?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isArchived?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    labels?: TaskLabelListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    listId?: StringWithAggregatesFilter<"Task"> | string
    creatorId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    position?: IntWithAggregatesFilter<"Task"> | number
    status?: StringWithAggregatesFilter<"Task"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    isArchived?: BoolWithAggregatesFilter<"Task"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: StringFilter<"Label"> | string
    boardId?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    tasks?: TaskLabelListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    board?: BoardOrderByWithRelationInput
    tasks?: TaskLabelOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    boardId?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    tasks?: TaskLabelListRelationFilter
  }, "id">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Label"> | string
    boardId?: StringWithAggregatesFilter<"Label"> | string
    name?: StringWithAggregatesFilter<"Label"> | string
    color?: StringWithAggregatesFilter<"Label"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
  }

  export type TaskLabelWhereInput = {
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    label?: XOR<LabelScalarRelationFilter, LabelWhereInput>
  }

  export type TaskLabelOrderByWithRelationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    task?: TaskOrderByWithRelationInput
    label?: LabelOrderByWithRelationInput
  }

  export type TaskLabelWhereUniqueInput = Prisma.AtLeast<{
    taskId_labelId?: TaskLabelTaskIdLabelIdCompoundUniqueInput
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    label?: XOR<LabelScalarRelationFilter, LabelWhereInput>
  }, "taskId_labelId">

  export type TaskLabelOrderByWithAggregationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    _count?: TaskLabelCountOrderByAggregateInput
    _max?: TaskLabelMaxOrderByAggregateInput
    _min?: TaskLabelMinOrderByAggregateInput
  }

  export type TaskLabelScalarWhereWithAggregatesInput = {
    AND?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    OR?: TaskLabelScalarWhereWithAggregatesInput[]
    NOT?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    taskId?: StringWithAggregatesFilter<"TaskLabel"> | string
    labelId?: StringWithAggregatesFilter<"TaskLabel"> | string
  }

  export type DashboardWhereInput = {
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    id?: IntFilter<"Dashboard"> | number
    cursos?: IntFilter<"Dashboard"> | number
    programas?: IntFilter<"Dashboard"> | number
    usuarios?: IntFilter<"Dashboard"> | number
    atendimentosMes?: IntFilter<"Dashboard"> | number
    pendencias?: PendenciaListRelationFilter
    notificacoes?: NotificacaoListRelationFilter
    graficoCursos?: GraficoCursoListRelationFilter
    graficoBeneficiarios?: GraficoBeneficiarioListRelationFilter
  }

  export type DashboardOrderByWithRelationInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
    pendencias?: PendenciaOrderByRelationAggregateInput
    notificacoes?: NotificacaoOrderByRelationAggregateInput
    graficoCursos?: GraficoCursoOrderByRelationAggregateInput
    graficoBeneficiarios?: GraficoBeneficiarioOrderByRelationAggregateInput
  }

  export type DashboardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    cursos?: IntFilter<"Dashboard"> | number
    programas?: IntFilter<"Dashboard"> | number
    usuarios?: IntFilter<"Dashboard"> | number
    atendimentosMes?: IntFilter<"Dashboard"> | number
    pendencias?: PendenciaListRelationFilter
    notificacoes?: NotificacaoListRelationFilter
    graficoCursos?: GraficoCursoListRelationFilter
    graficoBeneficiarios?: GraficoBeneficiarioListRelationFilter
  }, "id">

  export type DashboardOrderByWithAggregationInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
    _count?: DashboardCountOrderByAggregateInput
    _avg?: DashboardAvgOrderByAggregateInput
    _max?: DashboardMaxOrderByAggregateInput
    _min?: DashboardMinOrderByAggregateInput
    _sum?: DashboardSumOrderByAggregateInput
  }

  export type DashboardScalarWhereWithAggregatesInput = {
    AND?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    OR?: DashboardScalarWhereWithAggregatesInput[]
    NOT?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dashboard"> | number
    cursos?: IntWithAggregatesFilter<"Dashboard"> | number
    programas?: IntWithAggregatesFilter<"Dashboard"> | number
    usuarios?: IntWithAggregatesFilter<"Dashboard"> | number
    atendimentosMes?: IntWithAggregatesFilter<"Dashboard"> | number
  }

  export type PendenciaWhereInput = {
    AND?: PendenciaWhereInput | PendenciaWhereInput[]
    OR?: PendenciaWhereInput[]
    NOT?: PendenciaWhereInput | PendenciaWhereInput[]
    id?: IntFilter<"Pendencia"> | number
    descricao?: StringFilter<"Pendencia"> | string
    dashboardId?: IntFilter<"Pendencia"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }

  export type PendenciaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    dashboardId?: SortOrder
    dashboard?: DashboardOrderByWithRelationInput
  }

  export type PendenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendenciaWhereInput | PendenciaWhereInput[]
    OR?: PendenciaWhereInput[]
    NOT?: PendenciaWhereInput | PendenciaWhereInput[]
    descricao?: StringFilter<"Pendencia"> | string
    dashboardId?: IntFilter<"Pendencia"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }, "id">

  export type PendenciaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    dashboardId?: SortOrder
    _count?: PendenciaCountOrderByAggregateInput
    _avg?: PendenciaAvgOrderByAggregateInput
    _max?: PendenciaMaxOrderByAggregateInput
    _min?: PendenciaMinOrderByAggregateInput
    _sum?: PendenciaSumOrderByAggregateInput
  }

  export type PendenciaScalarWhereWithAggregatesInput = {
    AND?: PendenciaScalarWhereWithAggregatesInput | PendenciaScalarWhereWithAggregatesInput[]
    OR?: PendenciaScalarWhereWithAggregatesInput[]
    NOT?: PendenciaScalarWhereWithAggregatesInput | PendenciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pendencia"> | number
    descricao?: StringWithAggregatesFilter<"Pendencia"> | string
    dashboardId?: IntWithAggregatesFilter<"Pendencia"> | number
  }

  export type NotificacaoWhereInput = {
    AND?: NotificacaoWhereInput | NotificacaoWhereInput[]
    OR?: NotificacaoWhereInput[]
    NOT?: NotificacaoWhereInput | NotificacaoWhereInput[]
    id?: IntFilter<"Notificacao"> | number
    mensagem?: StringFilter<"Notificacao"> | string
    dashboardId?: IntFilter<"Notificacao"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }

  export type NotificacaoOrderByWithRelationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    dashboardId?: SortOrder
    dashboard?: DashboardOrderByWithRelationInput
  }

  export type NotificacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificacaoWhereInput | NotificacaoWhereInput[]
    OR?: NotificacaoWhereInput[]
    NOT?: NotificacaoWhereInput | NotificacaoWhereInput[]
    mensagem?: StringFilter<"Notificacao"> | string
    dashboardId?: IntFilter<"Notificacao"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }, "id">

  export type NotificacaoOrderByWithAggregationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    dashboardId?: SortOrder
    _count?: NotificacaoCountOrderByAggregateInput
    _avg?: NotificacaoAvgOrderByAggregateInput
    _max?: NotificacaoMaxOrderByAggregateInput
    _min?: NotificacaoMinOrderByAggregateInput
    _sum?: NotificacaoSumOrderByAggregateInput
  }

  export type NotificacaoScalarWhereWithAggregatesInput = {
    AND?: NotificacaoScalarWhereWithAggregatesInput | NotificacaoScalarWhereWithAggregatesInput[]
    OR?: NotificacaoScalarWhereWithAggregatesInput[]
    NOT?: NotificacaoScalarWhereWithAggregatesInput | NotificacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notificacao"> | number
    mensagem?: StringWithAggregatesFilter<"Notificacao"> | string
    dashboardId?: IntWithAggregatesFilter<"Notificacao"> | number
  }

  export type GraficoCursoWhereInput = {
    AND?: GraficoCursoWhereInput | GraficoCursoWhereInput[]
    OR?: GraficoCursoWhereInput[]
    NOT?: GraficoCursoWhereInput | GraficoCursoWhereInput[]
    id?: IntFilter<"GraficoCurso"> | number
    label?: StringFilter<"GraficoCurso"> | string
    valor?: IntFilter<"GraficoCurso"> | number
    dashboardId?: IntFilter<"GraficoCurso"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }

  export type GraficoCursoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
    dashboard?: DashboardOrderByWithRelationInput
  }

  export type GraficoCursoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GraficoCursoWhereInput | GraficoCursoWhereInput[]
    OR?: GraficoCursoWhereInput[]
    NOT?: GraficoCursoWhereInput | GraficoCursoWhereInput[]
    label?: StringFilter<"GraficoCurso"> | string
    valor?: IntFilter<"GraficoCurso"> | number
    dashboardId?: IntFilter<"GraficoCurso"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }, "id">

  export type GraficoCursoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
    _count?: GraficoCursoCountOrderByAggregateInput
    _avg?: GraficoCursoAvgOrderByAggregateInput
    _max?: GraficoCursoMaxOrderByAggregateInput
    _min?: GraficoCursoMinOrderByAggregateInput
    _sum?: GraficoCursoSumOrderByAggregateInput
  }

  export type GraficoCursoScalarWhereWithAggregatesInput = {
    AND?: GraficoCursoScalarWhereWithAggregatesInput | GraficoCursoScalarWhereWithAggregatesInput[]
    OR?: GraficoCursoScalarWhereWithAggregatesInput[]
    NOT?: GraficoCursoScalarWhereWithAggregatesInput | GraficoCursoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GraficoCurso"> | number
    label?: StringWithAggregatesFilter<"GraficoCurso"> | string
    valor?: IntWithAggregatesFilter<"GraficoCurso"> | number
    dashboardId?: IntWithAggregatesFilter<"GraficoCurso"> | number
  }

  export type GraficoBeneficiarioWhereInput = {
    AND?: GraficoBeneficiarioWhereInput | GraficoBeneficiarioWhereInput[]
    OR?: GraficoBeneficiarioWhereInput[]
    NOT?: GraficoBeneficiarioWhereInput | GraficoBeneficiarioWhereInput[]
    id?: IntFilter<"GraficoBeneficiario"> | number
    label?: StringFilter<"GraficoBeneficiario"> | string
    valor?: IntFilter<"GraficoBeneficiario"> | number
    dashboardId?: IntFilter<"GraficoBeneficiario"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }

  export type GraficoBeneficiarioOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
    dashboard?: DashboardOrderByWithRelationInput
  }

  export type GraficoBeneficiarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GraficoBeneficiarioWhereInput | GraficoBeneficiarioWhereInput[]
    OR?: GraficoBeneficiarioWhereInput[]
    NOT?: GraficoBeneficiarioWhereInput | GraficoBeneficiarioWhereInput[]
    label?: StringFilter<"GraficoBeneficiario"> | string
    valor?: IntFilter<"GraficoBeneficiario"> | number
    dashboardId?: IntFilter<"GraficoBeneficiario"> | number
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }, "id">

  export type GraficoBeneficiarioOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
    _count?: GraficoBeneficiarioCountOrderByAggregateInput
    _avg?: GraficoBeneficiarioAvgOrderByAggregateInput
    _max?: GraficoBeneficiarioMaxOrderByAggregateInput
    _min?: GraficoBeneficiarioMinOrderByAggregateInput
    _sum?: GraficoBeneficiarioSumOrderByAggregateInput
  }

  export type GraficoBeneficiarioScalarWhereWithAggregatesInput = {
    AND?: GraficoBeneficiarioScalarWhereWithAggregatesInput | GraficoBeneficiarioScalarWhereWithAggregatesInput[]
    OR?: GraficoBeneficiarioScalarWhereWithAggregatesInput[]
    NOT?: GraficoBeneficiarioScalarWhereWithAggregatesInput | GraficoBeneficiarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GraficoBeneficiario"> | number
    label?: StringWithAggregatesFilter<"GraficoBeneficiario"> | string
    valor?: IntWithAggregatesFilter<"GraficoBeneficiario"> | number
    dashboardId?: IntWithAggregatesFilter<"GraficoBeneficiario"> | number
  }

  export type CursoWhereInput = {
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    id?: IntFilter<"Curso"> | number
    nome?: StringFilter<"Curso"> | string
    descricao?: StringFilter<"Curso"> | string
    modalidade?: StringFilter<"Curso"> | string
    criadoEm?: DateTimeFilter<"Curso"> | Date | string
  }

  export type CursoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    criadoEm?: SortOrder
  }

  export type CursoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    nome?: StringFilter<"Curso"> | string
    descricao?: StringFilter<"Curso"> | string
    modalidade?: StringFilter<"Curso"> | string
    criadoEm?: DateTimeFilter<"Curso"> | Date | string
  }, "id">

  export type CursoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    criadoEm?: SortOrder
    _count?: CursoCountOrderByAggregateInput
    _avg?: CursoAvgOrderByAggregateInput
    _max?: CursoMaxOrderByAggregateInput
    _min?: CursoMinOrderByAggregateInput
    _sum?: CursoSumOrderByAggregateInput
  }

  export type CursoScalarWhereWithAggregatesInput = {
    AND?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    OR?: CursoScalarWhereWithAggregatesInput[]
    NOT?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Curso"> | number
    nome?: StringWithAggregatesFilter<"Curso"> | string
    descricao?: StringWithAggregatesFilter<"Curso"> | string
    modalidade?: StringWithAggregatesFilter<"Curso"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Curso"> | Date | string
  }

  export type coordenadorWhereInput = {
    AND?: coordenadorWhereInput | coordenadorWhereInput[]
    OR?: coordenadorWhereInput[]
    NOT?: coordenadorWhereInput | coordenadorWhereInput[]
    id?: IntFilter<"coordenador"> | number
    nome?: StringFilter<"coordenador"> | string
    email?: StringFilter<"coordenador"> | string
    telefone?: StringNullableFilter<"coordenador"> | string | null
    cpf?: StringNullableFilter<"coordenador"> | string | null
    status?: StringNullableFilter<"coordenador"> | string | null
    cursos?: StringNullableListFilter<"coordenador">
    criadoEm?: DateTimeFilter<"coordenador"> | Date | string
    atualizadoEm?: DateTimeFilter<"coordenador"> | Date | string
    permissoes?: JsonNullableFilter<"coordenador">
  }

  export type coordenadorOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cursos?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    permissoes?: SortOrderInput | SortOrder
  }

  export type coordenadorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: coordenadorWhereInput | coordenadorWhereInput[]
    OR?: coordenadorWhereInput[]
    NOT?: coordenadorWhereInput | coordenadorWhereInput[]
    nome?: StringFilter<"coordenador"> | string
    email?: StringFilter<"coordenador"> | string
    telefone?: StringNullableFilter<"coordenador"> | string | null
    cpf?: StringNullableFilter<"coordenador"> | string | null
    status?: StringNullableFilter<"coordenador"> | string | null
    cursos?: StringNullableListFilter<"coordenador">
    criadoEm?: DateTimeFilter<"coordenador"> | Date | string
    atualizadoEm?: DateTimeFilter<"coordenador"> | Date | string
    permissoes?: JsonNullableFilter<"coordenador">
  }, "id">

  export type coordenadorOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cursos?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    permissoes?: SortOrderInput | SortOrder
    _count?: coordenadorCountOrderByAggregateInput
    _avg?: coordenadorAvgOrderByAggregateInput
    _max?: coordenadorMaxOrderByAggregateInput
    _min?: coordenadorMinOrderByAggregateInput
    _sum?: coordenadorSumOrderByAggregateInput
  }

  export type coordenadorScalarWhereWithAggregatesInput = {
    AND?: coordenadorScalarWhereWithAggregatesInput | coordenadorScalarWhereWithAggregatesInput[]
    OR?: coordenadorScalarWhereWithAggregatesInput[]
    NOT?: coordenadorScalarWhereWithAggregatesInput | coordenadorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"coordenador"> | number
    nome?: StringWithAggregatesFilter<"coordenador"> | string
    email?: StringWithAggregatesFilter<"coordenador"> | string
    telefone?: StringNullableWithAggregatesFilter<"coordenador"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"coordenador"> | string | null
    status?: StringNullableWithAggregatesFilter<"coordenador"> | string | null
    cursos?: StringNullableListFilter<"coordenador">
    criadoEm?: DateTimeWithAggregatesFilter<"coordenador"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"coordenador"> | Date | string
    permissoes?: JsonNullableWithAggregatesFilter<"coordenador">
  }

  export type AgendamentoWhereInput = {
    AND?: AgendamentoWhereInput | AgendamentoWhereInput[]
    OR?: AgendamentoWhereInput[]
    NOT?: AgendamentoWhereInput | AgendamentoWhereInput[]
    id?: StringFilter<"Agendamento"> | string
    beneficiario?: StringFilter<"Agendamento"> | string
    programa?: StringFilter<"Agendamento"> | string
    tipo?: StringFilter<"Agendamento"> | string
    aluno?: StringFilter<"Agendamento"> | string
    data?: DateTimeFilter<"Agendamento"> | Date | string
    turno?: StringFilter<"Agendamento"> | string
    status?: StringFilter<"Agendamento"> | string
    criadoEm?: DateTimeFilter<"Agendamento"> | Date | string
  }

  export type AgendamentoOrderByWithRelationInput = {
    id?: SortOrder
    beneficiario?: SortOrder
    programa?: SortOrder
    tipo?: SortOrder
    aluno?: SortOrder
    data?: SortOrder
    turno?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type AgendamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendamentoWhereInput | AgendamentoWhereInput[]
    OR?: AgendamentoWhereInput[]
    NOT?: AgendamentoWhereInput | AgendamentoWhereInput[]
    beneficiario?: StringFilter<"Agendamento"> | string
    programa?: StringFilter<"Agendamento"> | string
    tipo?: StringFilter<"Agendamento"> | string
    aluno?: StringFilter<"Agendamento"> | string
    data?: DateTimeFilter<"Agendamento"> | Date | string
    turno?: StringFilter<"Agendamento"> | string
    status?: StringFilter<"Agendamento"> | string
    criadoEm?: DateTimeFilter<"Agendamento"> | Date | string
  }, "id">

  export type AgendamentoOrderByWithAggregationInput = {
    id?: SortOrder
    beneficiario?: SortOrder
    programa?: SortOrder
    tipo?: SortOrder
    aluno?: SortOrder
    data?: SortOrder
    turno?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    _count?: AgendamentoCountOrderByAggregateInput
    _max?: AgendamentoMaxOrderByAggregateInput
    _min?: AgendamentoMinOrderByAggregateInput
  }

  export type AgendamentoScalarWhereWithAggregatesInput = {
    AND?: AgendamentoScalarWhereWithAggregatesInput | AgendamentoScalarWhereWithAggregatesInput[]
    OR?: AgendamentoScalarWhereWithAggregatesInput[]
    NOT?: AgendamentoScalarWhereWithAggregatesInput | AgendamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agendamento"> | string
    beneficiario?: StringWithAggregatesFilter<"Agendamento"> | string
    programa?: StringWithAggregatesFilter<"Agendamento"> | string
    tipo?: StringWithAggregatesFilter<"Agendamento"> | string
    aluno?: StringWithAggregatesFilter<"Agendamento"> | string
    data?: DateTimeWithAggregatesFilter<"Agendamento"> | Date | string
    turno?: StringWithAggregatesFilter<"Agendamento"> | string
    status?: StringWithAggregatesFilter<"Agendamento"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Agendamento"> | Date | string
  }

  export type ProgramaAgendamentoWhereInput = {
    AND?: ProgramaAgendamentoWhereInput | ProgramaAgendamentoWhereInput[]
    OR?: ProgramaAgendamentoWhereInput[]
    NOT?: ProgramaAgendamentoWhereInput | ProgramaAgendamentoWhereInput[]
    id?: StringFilter<"ProgramaAgendamento"> | string
    nome?: StringFilter<"ProgramaAgendamento"> | string
  }

  export type ProgramaAgendamentoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProgramaAgendamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nome?: string
    AND?: ProgramaAgendamentoWhereInput | ProgramaAgendamentoWhereInput[]
    OR?: ProgramaAgendamentoWhereInput[]
    NOT?: ProgramaAgendamentoWhereInput | ProgramaAgendamentoWhereInput[]
  }, "id" | "nome">

  export type ProgramaAgendamentoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: ProgramaAgendamentoCountOrderByAggregateInput
    _max?: ProgramaAgendamentoMaxOrderByAggregateInput
    _min?: ProgramaAgendamentoMinOrderByAggregateInput
  }

  export type ProgramaAgendamentoScalarWhereWithAggregatesInput = {
    AND?: ProgramaAgendamentoScalarWhereWithAggregatesInput | ProgramaAgendamentoScalarWhereWithAggregatesInput[]
    OR?: ProgramaAgendamentoScalarWhereWithAggregatesInput[]
    NOT?: ProgramaAgendamentoScalarWhereWithAggregatesInput | ProgramaAgendamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramaAgendamento"> | string
    nome?: StringWithAggregatesFilter<"ProgramaAgendamento"> | string
  }

  export type TipoAtendimentoAgendamentoWhereInput = {
    AND?: TipoAtendimentoAgendamentoWhereInput | TipoAtendimentoAgendamentoWhereInput[]
    OR?: TipoAtendimentoAgendamentoWhereInput[]
    NOT?: TipoAtendimentoAgendamentoWhereInput | TipoAtendimentoAgendamentoWhereInput[]
    id?: StringFilter<"TipoAtendimentoAgendamento"> | string
    nome?: StringFilter<"TipoAtendimentoAgendamento"> | string
  }

  export type TipoAtendimentoAgendamentoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type TipoAtendimentoAgendamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nome?: string
    AND?: TipoAtendimentoAgendamentoWhereInput | TipoAtendimentoAgendamentoWhereInput[]
    OR?: TipoAtendimentoAgendamentoWhereInput[]
    NOT?: TipoAtendimentoAgendamentoWhereInput | TipoAtendimentoAgendamentoWhereInput[]
  }, "id" | "nome">

  export type TipoAtendimentoAgendamentoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: TipoAtendimentoAgendamentoCountOrderByAggregateInput
    _max?: TipoAtendimentoAgendamentoMaxOrderByAggregateInput
    _min?: TipoAtendimentoAgendamentoMinOrderByAggregateInput
  }

  export type TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput = {
    AND?: TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput | TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput[]
    OR?: TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput[]
    NOT?: TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput | TipoAtendimentoAgendamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TipoAtendimentoAgendamento"> | string
    nome?: StringWithAggregatesFilter<"TipoAtendimentoAgendamento"> | string
  }

  export type AlunoWhereInput = {
    AND?: AlunoWhereInput | AlunoWhereInput[]
    OR?: AlunoWhereInput[]
    NOT?: AlunoWhereInput | AlunoWhereInput[]
    id?: StringFilter<"Aluno"> | string
    nome?: StringFilter<"Aluno"> | string
  }

  export type AlunoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type AlunoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nome?: string
    AND?: AlunoWhereInput | AlunoWhereInput[]
    OR?: AlunoWhereInput[]
    NOT?: AlunoWhereInput | AlunoWhereInput[]
  }, "id" | "nome">

  export type AlunoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: AlunoCountOrderByAggregateInput
    _max?: AlunoMaxOrderByAggregateInput
    _min?: AlunoMinOrderByAggregateInput
  }

  export type AlunoScalarWhereWithAggregatesInput = {
    AND?: AlunoScalarWhereWithAggregatesInput | AlunoScalarWhereWithAggregatesInput[]
    OR?: AlunoScalarWhereWithAggregatesInput[]
    NOT?: AlunoScalarWhereWithAggregatesInput | AlunoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Aluno"> | string
    nome?: StringWithAggregatesFilter<"Aluno"> | string
  }

  export type TipoAtendimentoWhereInput = {
    AND?: TipoAtendimentoWhereInput | TipoAtendimentoWhereInput[]
    OR?: TipoAtendimentoWhereInput[]
    NOT?: TipoAtendimentoWhereInput | TipoAtendimentoWhereInput[]
    id?: StringFilter<"TipoAtendimento"> | string
    nome?: StringFilter<"TipoAtendimento"> | string
    sigla?: StringFilter<"TipoAtendimento"> | string
    descricao?: StringNullableFilter<"TipoAtendimento"> | string | null
    publico?: StringNullableFilter<"TipoAtendimento"> | string | null
    duracao?: IntNullableFilter<"TipoAtendimento"> | number | null
    frequencia?: StringNullableFilter<"TipoAtendimento"> | string | null
    visibilidade?: EnumVisibilidadeFilter<"TipoAtendimento"> | $Enums.Visibilidade
    instrucoesAluno?: StringNullableFilter<"TipoAtendimento"> | string | null
    orientacoesPublicas?: StringNullableFilter<"TipoAtendimento"> | string | null
    status?: StringFilter<"TipoAtendimento"> | string
    programaId?: StringFilter<"TipoAtendimento"> | string
    programa?: XOR<ProgramaScalarRelationFilter, ProgramaWhereInput>
  }

  export type TipoAtendimentoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    descricao?: SortOrderInput | SortOrder
    publico?: SortOrderInput | SortOrder
    duracao?: SortOrderInput | SortOrder
    frequencia?: SortOrderInput | SortOrder
    visibilidade?: SortOrder
    instrucoesAluno?: SortOrderInput | SortOrder
    orientacoesPublicas?: SortOrderInput | SortOrder
    status?: SortOrder
    programaId?: SortOrder
    programa?: ProgramaOrderByWithRelationInput
  }

  export type TipoAtendimentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TipoAtendimentoWhereInput | TipoAtendimentoWhereInput[]
    OR?: TipoAtendimentoWhereInput[]
    NOT?: TipoAtendimentoWhereInput | TipoAtendimentoWhereInput[]
    nome?: StringFilter<"TipoAtendimento"> | string
    sigla?: StringFilter<"TipoAtendimento"> | string
    descricao?: StringNullableFilter<"TipoAtendimento"> | string | null
    publico?: StringNullableFilter<"TipoAtendimento"> | string | null
    duracao?: IntNullableFilter<"TipoAtendimento"> | number | null
    frequencia?: StringNullableFilter<"TipoAtendimento"> | string | null
    visibilidade?: EnumVisibilidadeFilter<"TipoAtendimento"> | $Enums.Visibilidade
    instrucoesAluno?: StringNullableFilter<"TipoAtendimento"> | string | null
    orientacoesPublicas?: StringNullableFilter<"TipoAtendimento"> | string | null
    status?: StringFilter<"TipoAtendimento"> | string
    programaId?: StringFilter<"TipoAtendimento"> | string
    programa?: XOR<ProgramaScalarRelationFilter, ProgramaWhereInput>
  }, "id">

  export type TipoAtendimentoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    descricao?: SortOrderInput | SortOrder
    publico?: SortOrderInput | SortOrder
    duracao?: SortOrderInput | SortOrder
    frequencia?: SortOrderInput | SortOrder
    visibilidade?: SortOrder
    instrucoesAluno?: SortOrderInput | SortOrder
    orientacoesPublicas?: SortOrderInput | SortOrder
    status?: SortOrder
    programaId?: SortOrder
    _count?: TipoAtendimentoCountOrderByAggregateInput
    _avg?: TipoAtendimentoAvgOrderByAggregateInput
    _max?: TipoAtendimentoMaxOrderByAggregateInput
    _min?: TipoAtendimentoMinOrderByAggregateInput
    _sum?: TipoAtendimentoSumOrderByAggregateInput
  }

  export type TipoAtendimentoScalarWhereWithAggregatesInput = {
    AND?: TipoAtendimentoScalarWhereWithAggregatesInput | TipoAtendimentoScalarWhereWithAggregatesInput[]
    OR?: TipoAtendimentoScalarWhereWithAggregatesInput[]
    NOT?: TipoAtendimentoScalarWhereWithAggregatesInput | TipoAtendimentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TipoAtendimento"> | string
    nome?: StringWithAggregatesFilter<"TipoAtendimento"> | string
    sigla?: StringWithAggregatesFilter<"TipoAtendimento"> | string
    descricao?: StringNullableWithAggregatesFilter<"TipoAtendimento"> | string | null
    publico?: StringNullableWithAggregatesFilter<"TipoAtendimento"> | string | null
    duracao?: IntNullableWithAggregatesFilter<"TipoAtendimento"> | number | null
    frequencia?: StringNullableWithAggregatesFilter<"TipoAtendimento"> | string | null
    visibilidade?: EnumVisibilidadeWithAggregatesFilter<"TipoAtendimento"> | $Enums.Visibilidade
    instrucoesAluno?: StringNullableWithAggregatesFilter<"TipoAtendimento"> | string | null
    orientacoesPublicas?: StringNullableWithAggregatesFilter<"TipoAtendimento"> | string | null
    status?: StringWithAggregatesFilter<"TipoAtendimento"> | string
    programaId?: StringWithAggregatesFilter<"TipoAtendimento"> | string
  }

  export type ProgramaWhereInput = {
    AND?: ProgramaWhereInput | ProgramaWhereInput[]
    OR?: ProgramaWhereInput[]
    NOT?: ProgramaWhereInput | ProgramaWhereInput[]
    id?: StringFilter<"Programa"> | string
    nome?: StringFilter<"Programa"> | string
    descricao?: StringNullableFilter<"Programa"> | string | null
    tipo?: StringFilter<"Programa"> | string
    status?: StringFilter<"Programa"> | string
    sala?: StringNullableFilter<"Programa"> | string | null
    inicio?: DateTimeNullableFilter<"Programa"> | Date | string | null
    fim?: DateTimeNullableFilter<"Programa"> | Date | string | null
    curso?: StringFilter<"Programa"> | string
    assistentes?: StringNullableFilter<"Programa"> | string | null
    createdAt?: DateTimeFilter<"Programa"> | Date | string
    updatedAt?: DateTimeFilter<"Programa"> | Date | string
    tiposAtendimento?: TipoAtendimentoListRelationFilter
    Escala?: EscalaListRelationFilter
  }

  export type ProgramaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tipo?: SortOrder
    status?: SortOrder
    sala?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fim?: SortOrderInput | SortOrder
    curso?: SortOrder
    assistentes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tiposAtendimento?: TipoAtendimentoOrderByRelationAggregateInput
    Escala?: EscalaOrderByRelationAggregateInput
  }

  export type ProgramaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramaWhereInput | ProgramaWhereInput[]
    OR?: ProgramaWhereInput[]
    NOT?: ProgramaWhereInput | ProgramaWhereInput[]
    nome?: StringFilter<"Programa"> | string
    descricao?: StringNullableFilter<"Programa"> | string | null
    tipo?: StringFilter<"Programa"> | string
    status?: StringFilter<"Programa"> | string
    sala?: StringNullableFilter<"Programa"> | string | null
    inicio?: DateTimeNullableFilter<"Programa"> | Date | string | null
    fim?: DateTimeNullableFilter<"Programa"> | Date | string | null
    curso?: StringFilter<"Programa"> | string
    assistentes?: StringNullableFilter<"Programa"> | string | null
    createdAt?: DateTimeFilter<"Programa"> | Date | string
    updatedAt?: DateTimeFilter<"Programa"> | Date | string
    tiposAtendimento?: TipoAtendimentoListRelationFilter
    Escala?: EscalaListRelationFilter
  }, "id">

  export type ProgramaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tipo?: SortOrder
    status?: SortOrder
    sala?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fim?: SortOrderInput | SortOrder
    curso?: SortOrder
    assistentes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramaCountOrderByAggregateInput
    _max?: ProgramaMaxOrderByAggregateInput
    _min?: ProgramaMinOrderByAggregateInput
  }

  export type ProgramaScalarWhereWithAggregatesInput = {
    AND?: ProgramaScalarWhereWithAggregatesInput | ProgramaScalarWhereWithAggregatesInput[]
    OR?: ProgramaScalarWhereWithAggregatesInput[]
    NOT?: ProgramaScalarWhereWithAggregatesInput | ProgramaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Programa"> | string
    nome?: StringWithAggregatesFilter<"Programa"> | string
    descricao?: StringNullableWithAggregatesFilter<"Programa"> | string | null
    tipo?: StringWithAggregatesFilter<"Programa"> | string
    status?: StringWithAggregatesFilter<"Programa"> | string
    sala?: StringNullableWithAggregatesFilter<"Programa"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"Programa"> | Date | string | null
    fim?: DateTimeNullableWithAggregatesFilter<"Programa"> | Date | string | null
    curso?: StringWithAggregatesFilter<"Programa"> | string
    assistentes?: StringNullableWithAggregatesFilter<"Programa"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Programa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Programa"> | Date | string
  }

  export type EscalaWhereInput = {
    AND?: EscalaWhereInput | EscalaWhereInput[]
    OR?: EscalaWhereInput[]
    NOT?: EscalaWhereInput | EscalaWhereInput[]
    id?: StringFilter<"Escala"> | string
    nome?: StringFilter<"Escala"> | string
    matricula?: StringFilter<"Escala"> | string
    curso?: StringFilter<"Escala"> | string
    status?: StringFilter<"Escala"> | string
    turnos?: StringNullableListFilter<"Escala">
    programaId?: StringFilter<"Escala"> | string
    createdAt?: DateTimeFilter<"Escala"> | Date | string
    updatedAt?: DateTimeFilter<"Escala"> | Date | string
    programa?: XOR<ProgramaScalarRelationFilter, ProgramaWhereInput>
  }

  export type EscalaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    matricula?: SortOrder
    curso?: SortOrder
    status?: SortOrder
    turnos?: SortOrder
    programaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programa?: ProgramaOrderByWithRelationInput
  }

  export type EscalaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EscalaWhereInput | EscalaWhereInput[]
    OR?: EscalaWhereInput[]
    NOT?: EscalaWhereInput | EscalaWhereInput[]
    nome?: StringFilter<"Escala"> | string
    matricula?: StringFilter<"Escala"> | string
    curso?: StringFilter<"Escala"> | string
    status?: StringFilter<"Escala"> | string
    turnos?: StringNullableListFilter<"Escala">
    programaId?: StringFilter<"Escala"> | string
    createdAt?: DateTimeFilter<"Escala"> | Date | string
    updatedAt?: DateTimeFilter<"Escala"> | Date | string
    programa?: XOR<ProgramaScalarRelationFilter, ProgramaWhereInput>
  }, "id">

  export type EscalaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    matricula?: SortOrder
    curso?: SortOrder
    status?: SortOrder
    turnos?: SortOrder
    programaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EscalaCountOrderByAggregateInput
    _max?: EscalaMaxOrderByAggregateInput
    _min?: EscalaMinOrderByAggregateInput
  }

  export type EscalaScalarWhereWithAggregatesInput = {
    AND?: EscalaScalarWhereWithAggregatesInput | EscalaScalarWhereWithAggregatesInput[]
    OR?: EscalaScalarWhereWithAggregatesInput[]
    NOT?: EscalaScalarWhereWithAggregatesInput | EscalaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Escala"> | string
    nome?: StringWithAggregatesFilter<"Escala"> | string
    matricula?: StringWithAggregatesFilter<"Escala"> | string
    curso?: StringWithAggregatesFilter<"Escala"> | string
    status?: StringWithAggregatesFilter<"Escala"> | string
    turnos?: StringNullableListFilter<"Escala">
    programaId?: StringWithAggregatesFilter<"Escala"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Escala"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Escala"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardCreateNestedManyWithoutOwnerInput
    memberships?: BoardMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardUncheckedCreateNestedManyWithoutOwnerInput
    memberships?: BoardMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUpdateManyWithoutOwnerNestedInput
    memberships?: BoardMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUncheckedUpdateManyWithoutOwnerNestedInput
    memberships?: BoardMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardCreateInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBoardsInput
    members?: BoardMemberCreateNestedManyWithoutBoardInput
    lists?: ListCreateNestedManyWithoutBoardInput
    labels?: LabelCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: BoardMemberUncheckedCreateNestedManyWithoutBoardInput
    lists?: ListUncheckedCreateNestedManyWithoutBoardInput
    labels?: LabelUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBoardsNestedInput
    members?: BoardMemberUpdateManyWithoutBoardNestedInput
    lists?: ListUpdateManyWithoutBoardNestedInput
    labels?: LabelUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: BoardMemberUncheckedUpdateManyWithoutBoardNestedInput
    lists?: ListUncheckedUpdateManyWithoutBoardNestedInput
    labels?: LabelUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberCreateInput = {
    role: $Enums.Role
    joinedAt?: Date | string
    board: BoardCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type BoardMemberUncheckedCreateInput = {
    boardId: string
    userId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type BoardMemberUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type BoardMemberUncheckedUpdateInput = {
    boardId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberCreateManyInput = {
    boardId: string
    userId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type BoardMemberUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberUncheckedUpdateManyInput = {
    boardId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListCreateInput = {
    id?: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutListsInput
    tasks?: TaskCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateInput = {
    id?: string
    boardId: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutListInput
  }

  export type ListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutListsNestedInput
    tasks?: TaskUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListCreateManyInput = {
    id?: string
    boardId: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    list: ListCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    listId: string
    creatorId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    listId: string
    creatorId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutLabelsInput
    tasks?: TaskLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: string
    boardId: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutLabelsNestedInput
    tasks?: TaskLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelCreateManyInput = {
    id?: string
    boardId: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateInput = {
    task: TaskCreateNestedOneWithoutLabelsInput
    label: LabelCreateNestedOneWithoutTasksInput
  }

  export type TaskLabelUncheckedCreateInput = {
    taskId: string
    labelId: string
  }

  export type TaskLabelUpdateInput = {
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
    label?: LabelUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskLabelUncheckedUpdateInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelCreateManyInput = {
    taskId: string
    labelId: string
  }

  export type TaskLabelUpdateManyMutationInput = {

  }

  export type TaskLabelUncheckedUpdateManyInput = {
    taskId?: StringFieldUpdateOperationsInput | string
    labelId?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardCreateInput = {
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaUncheckedCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoUncheckedCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoUncheckedCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUpdateInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUncheckedUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateManyInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
  }

  export type DashboardUpdateManyMutationInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
  }

  export type DashboardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
  }

  export type PendenciaCreateInput = {
    descricao: string
    dashboard: DashboardCreateNestedOneWithoutPendenciasInput
  }

  export type PendenciaUncheckedCreateInput = {
    id?: number
    descricao: string
    dashboardId: number
  }

  export type PendenciaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    dashboard?: DashboardUpdateOneRequiredWithoutPendenciasNestedInput
  }

  export type PendenciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type PendenciaCreateManyInput = {
    id?: number
    descricao: string
    dashboardId: number
  }

  export type PendenciaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type PendenciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacaoCreateInput = {
    mensagem: string
    dashboard: DashboardCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificacaoUncheckedCreateInput = {
    id?: number
    mensagem: string
    dashboardId: number
  }

  export type NotificacaoUpdateInput = {
    mensagem?: StringFieldUpdateOperationsInput | string
    dashboard?: DashboardUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacaoCreateManyInput = {
    id?: number
    mensagem: string
    dashboardId: number
  }

  export type NotificacaoUpdateManyMutationInput = {
    mensagem?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoCursoCreateInput = {
    label: string
    valor: number
    dashboard: DashboardCreateNestedOneWithoutGraficoCursosInput
  }

  export type GraficoCursoUncheckedCreateInput = {
    id?: number
    label: string
    valor: number
    dashboardId: number
  }

  export type GraficoCursoUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboard?: DashboardUpdateOneRequiredWithoutGraficoCursosNestedInput
  }

  export type GraficoCursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoCursoCreateManyInput = {
    id?: number
    label: string
    valor: number
    dashboardId: number
  }

  export type GraficoCursoUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoCursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioCreateInput = {
    label: string
    valor: number
    dashboard: DashboardCreateNestedOneWithoutGraficoBeneficiariosInput
  }

  export type GraficoBeneficiarioUncheckedCreateInput = {
    id?: number
    label: string
    valor: number
    dashboardId: number
  }

  export type GraficoBeneficiarioUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboard?: DashboardUpdateOneRequiredWithoutGraficoBeneficiariosNestedInput
  }

  export type GraficoBeneficiarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioCreateManyInput = {
    id?: number
    label: string
    valor: number
    dashboardId: number
  }

  export type GraficoBeneficiarioUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    dashboardId?: IntFieldUpdateOperationsInput | number
  }

  export type CursoCreateInput = {
    nome: string
    descricao: string
    modalidade: string
    criadoEm?: Date | string
  }

  export type CursoUncheckedCreateInput = {
    id?: number
    nome: string
    descricao: string
    modalidade: string
    criadoEm?: Date | string
  }

  export type CursoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCreateManyInput = {
    id?: number
    nome: string
    descricao: string
    modalidade: string
    criadoEm?: Date | string
  }

  export type CursoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coordenadorCreateInput = {
    nome: string
    email: string
    telefone?: string | null
    cpf?: string | null
    status?: string | null
    cursos?: coordenadorCreatecursosInput | string[]
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    telefone?: string | null
    cpf?: string | null
    status?: string | null
    cursos?: coordenadorCreatecursosInput | string[]
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cursos?: coordenadorUpdatecursosInput | string[]
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cursos?: coordenadorUpdatecursosInput | string[]
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorCreateManyInput = {
    id?: number
    nome: string
    email: string
    telefone?: string | null
    cpf?: string | null
    status?: string | null
    cursos?: coordenadorCreatecursosInput | string[]
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cursos?: coordenadorUpdatecursosInput | string[]
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type coordenadorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cursos?: coordenadorUpdatecursosInput | string[]
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    permissoes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgendamentoCreateInput = {
    id?: string
    beneficiario: string
    programa: string
    tipo: string
    aluno: string
    data: Date | string
    turno: string
    status?: string
    criadoEm?: Date | string
  }

  export type AgendamentoUncheckedCreateInput = {
    id?: string
    beneficiario: string
    programa: string
    tipo: string
    aluno: string
    data: Date | string
    turno: string
    status?: string
    criadoEm?: Date | string
  }

  export type AgendamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    beneficiario?: StringFieldUpdateOperationsInput | string
    programa?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    aluno?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    turno?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    beneficiario?: StringFieldUpdateOperationsInput | string
    programa?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    aluno?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    turno?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendamentoCreateManyInput = {
    id?: string
    beneficiario: string
    programa: string
    tipo: string
    aluno: string
    data: Date | string
    turno: string
    status?: string
    criadoEm?: Date | string
  }

  export type AgendamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    beneficiario?: StringFieldUpdateOperationsInput | string
    programa?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    aluno?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    turno?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    beneficiario?: StringFieldUpdateOperationsInput | string
    programa?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    aluno?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    turno?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramaAgendamentoCreateInput = {
    id?: string
    nome: string
  }

  export type ProgramaAgendamentoUncheckedCreateInput = {
    id?: string
    nome: string
  }

  export type ProgramaAgendamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaAgendamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaAgendamentoCreateManyInput = {
    id?: string
    nome: string
  }

  export type ProgramaAgendamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaAgendamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoAgendamentoCreateInput = {
    id?: string
    nome: string
  }

  export type TipoAtendimentoAgendamentoUncheckedCreateInput = {
    id?: string
    nome: string
  }

  export type TipoAtendimentoAgendamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoAgendamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoAgendamentoCreateManyInput = {
    id?: string
    nome: string
  }

  export type TipoAtendimentoAgendamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoAgendamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type AlunoCreateInput = {
    id?: string
    nome: string
  }

  export type AlunoUncheckedCreateInput = {
    id?: string
    nome: string
  }

  export type AlunoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type AlunoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type AlunoCreateManyInput = {
    id?: string
    nome: string
  }

  export type AlunoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type AlunoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoCreateInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
    programa: ProgramaCreateNestedOneWithoutTiposAtendimentoInput
  }

  export type TipoAtendimentoUncheckedCreateInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
    programaId: string
  }

  export type TipoAtendimentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    programa?: ProgramaUpdateOneRequiredWithoutTiposAtendimentoNestedInput
  }

  export type TipoAtendimentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    programaId?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoCreateManyInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
    programaId: string
  }

  export type TipoAtendimentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    programaId?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramaCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tiposAtendimento?: TipoAtendimentoCreateNestedManyWithoutProgramaInput
    Escala?: EscalaCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUncheckedCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tiposAtendimento?: TipoAtendimentoUncheckedCreateNestedManyWithoutProgramaInput
    Escala?: EscalaUncheckedCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiposAtendimento?: TipoAtendimentoUpdateManyWithoutProgramaNestedInput
    Escala?: EscalaUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiposAtendimento?: TipoAtendimentoUncheckedUpdateManyWithoutProgramaNestedInput
    Escala?: EscalaUncheckedUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaCreateManyInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscalaCreateInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    programa: ProgramaCreateNestedOneWithoutEscalaInput
  }

  export type EscalaUncheckedCreateInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    programaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscalaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programa?: ProgramaUpdateOneRequiredWithoutEscalaNestedInput
  }

  export type EscalaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    programaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscalaCreateManyInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    programaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscalaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscalaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    programaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type BoardMemberListRelationFilter = {
    every?: BoardMemberWhereInput
    some?: BoardMemberWhereInput
    none?: BoardMemberWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAuthProviderAndIdUniqueCompoundUniqueInput = {
    authProvider: $Enums.AuthProvider
    providerId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    passwordHash?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    CreatedAt?: SortOrder
    updatedAt?: SortOrder
    providerId?: SortOrder
    isAdmin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    passwordHash?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    CreatedAt?: SortOrder
    updatedAt?: SortOrder
    providerId?: SortOrder
    isAdmin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    passwordHash?: SortOrder
    authProvider?: SortOrder
    isVerified?: SortOrder
    CreatedAt?: SortOrder
    updatedAt?: SortOrder
    providerId?: SortOrder
    isAdmin?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBoardVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardVisibility | EnumBoardVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardVisibilityFilter<$PrismaModel> | $Enums.BoardVisibility
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ListListRelationFilter = {
    every?: ListWhereInput
    some?: ListWhereInput
    none?: ListWhereInput
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type ListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    visibility?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBoardVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardVisibility | EnumBoardVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.BoardVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBoardVisibilityFilter<$PrismaModel>
    _max?: NestedEnumBoardVisibilityFilter<$PrismaModel>
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type BoardMemberBoardIdUserIdCompoundUniqueInput = {
    boardId: string
    userId: string
  }

  export type BoardMemberCountOrderByAggregateInput = {
    boardId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type BoardMemberMaxOrderByAggregateInput = {
    boardId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type BoardMemberMinOrderByAggregateInput = {
    boardId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ListCountOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ListMaxOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListMinOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    title?: SortOrder
    position?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ListScalarRelationFilter = {
    is?: ListWhereInput
    isNot?: ListWhereInput
  }

  export type TaskLabelListRelationFilter = {
    every?: TaskLabelWhereInput
    some?: TaskLabelWhereInput
    none?: TaskLabelWhereInput
  }

  export type TaskLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type LabelScalarRelationFilter = {
    is?: LabelWhereInput
    isNot?: LabelWhereInput
  }

  export type TaskLabelTaskIdLabelIdCompoundUniqueInput = {
    taskId: string
    labelId: string
  }

  export type TaskLabelCountOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
  }

  export type TaskLabelMaxOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
  }

  export type TaskLabelMinOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
  }

  export type PendenciaListRelationFilter = {
    every?: PendenciaWhereInput
    some?: PendenciaWhereInput
    none?: PendenciaWhereInput
  }

  export type NotificacaoListRelationFilter = {
    every?: NotificacaoWhereInput
    some?: NotificacaoWhereInput
    none?: NotificacaoWhereInput
  }

  export type GraficoCursoListRelationFilter = {
    every?: GraficoCursoWhereInput
    some?: GraficoCursoWhereInput
    none?: GraficoCursoWhereInput
  }

  export type GraficoBeneficiarioListRelationFilter = {
    every?: GraficoBeneficiarioWhereInput
    some?: GraficoBeneficiarioWhereInput
    none?: GraficoBeneficiarioWhereInput
  }

  export type PendenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GraficoCursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GraficoBeneficiarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardCountOrderByAggregateInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
  }

  export type DashboardAvgOrderByAggregateInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
  }

  export type DashboardMaxOrderByAggregateInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
  }

  export type DashboardMinOrderByAggregateInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
  }

  export type DashboardSumOrderByAggregateInput = {
    id?: SortOrder
    cursos?: SortOrder
    programas?: SortOrder
    usuarios?: SortOrder
    atendimentosMes?: SortOrder
  }

  export type DashboardScalarRelationFilter = {
    is?: DashboardWhereInput
    isNot?: DashboardWhereInput
  }

  export type PendenciaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dashboardId?: SortOrder
  }

  export type PendenciaAvgOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
  }

  export type PendenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dashboardId?: SortOrder
  }

  export type PendenciaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dashboardId?: SortOrder
  }

  export type PendenciaSumOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
  }

  export type NotificacaoCountOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    dashboardId?: SortOrder
  }

  export type NotificacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
  }

  export type NotificacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    dashboardId?: SortOrder
  }

  export type NotificacaoMinOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    dashboardId?: SortOrder
  }

  export type NotificacaoSumOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoCursoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoCursoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoCursoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoCursoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoCursoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoBeneficiarioCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoBeneficiarioAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoBeneficiarioMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoBeneficiarioMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type GraficoBeneficiarioSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    dashboardId?: SortOrder
  }

  export type CursoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    criadoEm?: SortOrder
  }

  export type CursoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CursoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    criadoEm?: SortOrder
  }

  export type CursoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    criadoEm?: SortOrder
  }

  export type CursoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type coordenadorCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    cpf?: SortOrder
    status?: SortOrder
    cursos?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    permissoes?: SortOrder
  }

  export type coordenadorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type coordenadorMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    cpf?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type coordenadorMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    cpf?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type coordenadorSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AgendamentoCountOrderByAggregateInput = {
    id?: SortOrder
    beneficiario?: SortOrder
    programa?: SortOrder
    tipo?: SortOrder
    aluno?: SortOrder
    data?: SortOrder
    turno?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type AgendamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    beneficiario?: SortOrder
    programa?: SortOrder
    tipo?: SortOrder
    aluno?: SortOrder
    data?: SortOrder
    turno?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type AgendamentoMinOrderByAggregateInput = {
    id?: SortOrder
    beneficiario?: SortOrder
    programa?: SortOrder
    tipo?: SortOrder
    aluno?: SortOrder
    data?: SortOrder
    turno?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type ProgramaAgendamentoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProgramaAgendamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProgramaAgendamentoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type TipoAtendimentoAgendamentoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type TipoAtendimentoAgendamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type TipoAtendimentoAgendamentoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type AlunoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type AlunoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type AlunoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVisibilidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibilidade | EnumVisibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilidadeFilter<$PrismaModel> | $Enums.Visibilidade
  }

  export type ProgramaScalarRelationFilter = {
    is?: ProgramaWhereInput
    isNot?: ProgramaWhereInput
  }

  export type TipoAtendimentoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    descricao?: SortOrder
    publico?: SortOrder
    duracao?: SortOrder
    frequencia?: SortOrder
    visibilidade?: SortOrder
    instrucoesAluno?: SortOrder
    orientacoesPublicas?: SortOrder
    status?: SortOrder
    programaId?: SortOrder
  }

  export type TipoAtendimentoAvgOrderByAggregateInput = {
    duracao?: SortOrder
  }

  export type TipoAtendimentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    descricao?: SortOrder
    publico?: SortOrder
    duracao?: SortOrder
    frequencia?: SortOrder
    visibilidade?: SortOrder
    instrucoesAluno?: SortOrder
    orientacoesPublicas?: SortOrder
    status?: SortOrder
    programaId?: SortOrder
  }

  export type TipoAtendimentoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    descricao?: SortOrder
    publico?: SortOrder
    duracao?: SortOrder
    frequencia?: SortOrder
    visibilidade?: SortOrder
    instrucoesAluno?: SortOrder
    orientacoesPublicas?: SortOrder
    status?: SortOrder
    programaId?: SortOrder
  }

  export type TipoAtendimentoSumOrderByAggregateInput = {
    duracao?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVisibilidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibilidade | EnumVisibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilidadeWithAggregatesFilter<$PrismaModel> | $Enums.Visibilidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilidadeFilter<$PrismaModel>
    _max?: NestedEnumVisibilidadeFilter<$PrismaModel>
  }

  export type TipoAtendimentoListRelationFilter = {
    every?: TipoAtendimentoWhereInput
    some?: TipoAtendimentoWhereInput
    none?: TipoAtendimentoWhereInput
  }

  export type EscalaListRelationFilter = {
    every?: EscalaWhereInput
    some?: EscalaWhereInput
    none?: EscalaWhereInput
  }

  export type TipoAtendimentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscalaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    sala?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    curso?: SortOrder
    assistentes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    sala?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    curso?: SortOrder
    assistentes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    sala?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    curso?: SortOrder
    assistentes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscalaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    matricula?: SortOrder
    curso?: SortOrder
    status?: SortOrder
    turnos?: SortOrder
    programaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscalaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    matricula?: SortOrder
    curso?: SortOrder
    status?: SortOrder
    programaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EscalaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    matricula?: SortOrder
    curso?: SortOrder
    status?: SortOrder
    programaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput> | BoardCreateWithoutOwnerInput[] | BoardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutOwnerInput | BoardCreateOrConnectWithoutOwnerInput[]
    createMany?: BoardCreateManyOwnerInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput> | BoardMemberCreateWithoutUserInput[] | BoardMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutUserInput | BoardMemberCreateOrConnectWithoutUserInput[]
    createMany?: BoardMemberCreateManyUserInputEnvelope
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput> | BoardCreateWithoutOwnerInput[] | BoardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutOwnerInput | BoardCreateOrConnectWithoutOwnerInput[]
    createMany?: BoardCreateManyOwnerInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput> | BoardMemberCreateWithoutUserInput[] | BoardMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutUserInput | BoardMemberCreateOrConnectWithoutUserInput[]
    createMany?: BoardMemberCreateManyUserInputEnvelope
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoardUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput> | BoardCreateWithoutOwnerInput[] | BoardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutOwnerInput | BoardCreateOrConnectWithoutOwnerInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutOwnerInput | BoardUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BoardCreateManyOwnerInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutOwnerInput | BoardUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutOwnerInput | BoardUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type BoardMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput> | BoardMemberCreateWithoutUserInput[] | BoardMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutUserInput | BoardMemberCreateOrConnectWithoutUserInput[]
    upsert?: BoardMemberUpsertWithWhereUniqueWithoutUserInput | BoardMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardMemberCreateManyUserInputEnvelope
    set?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    disconnect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    delete?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    update?: BoardMemberUpdateWithWhereUniqueWithoutUserInput | BoardMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardMemberUpdateManyWithWhereWithoutUserInput | BoardMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type BoardUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput> | BoardCreateWithoutOwnerInput[] | BoardUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutOwnerInput | BoardCreateOrConnectWithoutOwnerInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutOwnerInput | BoardUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BoardCreateManyOwnerInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutOwnerInput | BoardUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutOwnerInput | BoardUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type BoardMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput> | BoardMemberCreateWithoutUserInput[] | BoardMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutUserInput | BoardMemberCreateOrConnectWithoutUserInput[]
    upsert?: BoardMemberUpsertWithWhereUniqueWithoutUserInput | BoardMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardMemberCreateManyUserInputEnvelope
    set?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    disconnect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    delete?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    update?: BoardMemberUpdateWithWhereUniqueWithoutUserInput | BoardMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardMemberUpdateManyWithWhereWithoutUserInput | BoardMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBoardsInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type BoardMemberCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput> | BoardMemberCreateWithoutBoardInput[] | BoardMemberUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutBoardInput | BoardMemberCreateOrConnectWithoutBoardInput[]
    createMany?: BoardMemberCreateManyBoardInputEnvelope
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
  }

  export type ListCreateNestedManyWithoutBoardInput = {
    create?: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput> | ListCreateWithoutBoardInput[] | ListUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ListCreateOrConnectWithoutBoardInput | ListCreateOrConnectWithoutBoardInput[]
    createMany?: ListCreateManyBoardInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type LabelCreateNestedManyWithoutBoardInput = {
    create?: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput> | LabelCreateWithoutBoardInput[] | LabelUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutBoardInput | LabelCreateOrConnectWithoutBoardInput[]
    createMany?: LabelCreateManyBoardInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type BoardMemberUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput> | BoardMemberCreateWithoutBoardInput[] | BoardMemberUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutBoardInput | BoardMemberCreateOrConnectWithoutBoardInput[]
    createMany?: BoardMemberCreateManyBoardInputEnvelope
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput> | ListCreateWithoutBoardInput[] | ListUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ListCreateOrConnectWithoutBoardInput | ListCreateOrConnectWithoutBoardInput[]
    createMany?: ListCreateManyBoardInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type LabelUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput> | LabelCreateWithoutBoardInput[] | LabelUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutBoardInput | LabelCreateOrConnectWithoutBoardInput[]
    createMany?: LabelCreateManyBoardInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type EnumBoardVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.BoardVisibility
  }

  export type UserUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    upsert?: UserUpsertWithoutBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBoardsInput, UserUpdateWithoutBoardsInput>, UserUncheckedUpdateWithoutBoardsInput>
  }

  export type BoardMemberUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput> | BoardMemberCreateWithoutBoardInput[] | BoardMemberUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutBoardInput | BoardMemberCreateOrConnectWithoutBoardInput[]
    upsert?: BoardMemberUpsertWithWhereUniqueWithoutBoardInput | BoardMemberUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardMemberCreateManyBoardInputEnvelope
    set?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    disconnect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    delete?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    update?: BoardMemberUpdateWithWhereUniqueWithoutBoardInput | BoardMemberUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardMemberUpdateManyWithWhereWithoutBoardInput | BoardMemberUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
  }

  export type ListUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput> | ListCreateWithoutBoardInput[] | ListUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ListCreateOrConnectWithoutBoardInput | ListCreateOrConnectWithoutBoardInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutBoardInput | ListUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ListCreateManyBoardInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutBoardInput | ListUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ListUpdateManyWithWhereWithoutBoardInput | ListUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type LabelUpdateManyWithoutBoardNestedInput = {
    create?: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput> | LabelCreateWithoutBoardInput[] | LabelUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutBoardInput | LabelCreateOrConnectWithoutBoardInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutBoardInput | LabelUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: LabelCreateManyBoardInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutBoardInput | LabelUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutBoardInput | LabelUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type BoardMemberUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput> | BoardMemberCreateWithoutBoardInput[] | BoardMemberUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardMemberCreateOrConnectWithoutBoardInput | BoardMemberCreateOrConnectWithoutBoardInput[]
    upsert?: BoardMemberUpsertWithWhereUniqueWithoutBoardInput | BoardMemberUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardMemberCreateManyBoardInputEnvelope
    set?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    disconnect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    delete?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    connect?: BoardMemberWhereUniqueInput | BoardMemberWhereUniqueInput[]
    update?: BoardMemberUpdateWithWhereUniqueWithoutBoardInput | BoardMemberUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardMemberUpdateManyWithWhereWithoutBoardInput | BoardMemberUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput> | ListCreateWithoutBoardInput[] | ListUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ListCreateOrConnectWithoutBoardInput | ListCreateOrConnectWithoutBoardInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutBoardInput | ListUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ListCreateManyBoardInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutBoardInput | ListUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ListUpdateManyWithWhereWithoutBoardInput | ListUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type LabelUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput> | LabelCreateWithoutBoardInput[] | LabelUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutBoardInput | LabelCreateOrConnectWithoutBoardInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutBoardInput | LabelUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: LabelCreateManyBoardInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutBoardInput | LabelUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutBoardInput | LabelUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutMembersInput = {
    create?: XOR<BoardCreateWithoutMembersInput, BoardUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BoardCreateOrConnectWithoutMembersInput
    connect?: BoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<BoardCreateWithoutMembersInput, BoardUncheckedCreateWithoutMembersInput>
    connectOrCreate?: BoardCreateOrConnectWithoutMembersInput
    upsert?: BoardUpsertWithoutMembersInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutMembersInput, BoardUpdateWithoutMembersInput>, BoardUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type BoardCreateNestedOneWithoutListsInput = {
    create?: XOR<BoardCreateWithoutListsInput, BoardUncheckedCreateWithoutListsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutListsInput
    connect?: BoardWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutListInput = {
    create?: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput> | TaskCreateWithoutListInput[] | TaskUncheckedCreateWithoutListInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutListInput | TaskCreateOrConnectWithoutListInput[]
    createMany?: TaskCreateManyListInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput> | TaskCreateWithoutListInput[] | TaskUncheckedCreateWithoutListInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutListInput | TaskCreateOrConnectWithoutListInput[]
    createMany?: TaskCreateManyListInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardUpdateOneRequiredWithoutListsNestedInput = {
    create?: XOR<BoardCreateWithoutListsInput, BoardUncheckedCreateWithoutListsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutListsInput
    upsert?: BoardUpsertWithoutListsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutListsInput, BoardUpdateWithoutListsInput>, BoardUncheckedUpdateWithoutListsInput>
  }

  export type TaskUpdateManyWithoutListNestedInput = {
    create?: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput> | TaskCreateWithoutListInput[] | TaskUncheckedCreateWithoutListInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutListInput | TaskCreateOrConnectWithoutListInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutListInput | TaskUpsertWithWhereUniqueWithoutListInput[]
    createMany?: TaskCreateManyListInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutListInput | TaskUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutListInput | TaskUpdateManyWithWhereWithoutListInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput> | TaskCreateWithoutListInput[] | TaskUncheckedCreateWithoutListInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutListInput | TaskCreateOrConnectWithoutListInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutListInput | TaskUpsertWithWhereUniqueWithoutListInput[]
    createMany?: TaskCreateManyListInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutListInput | TaskUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutListInput | TaskUpdateManyWithWhereWithoutListInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ListCreateNestedOneWithoutTasksInput = {
    create?: XOR<ListCreateWithoutTasksInput, ListUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ListCreateOrConnectWithoutTasksInput
    connect?: ListWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskLabelCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ListUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ListCreateWithoutTasksInput, ListUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ListCreateOrConnectWithoutTasksInput
    upsert?: ListUpsertWithoutTasksInput
    connect?: ListWhereUniqueInput
    update?: XOR<XOR<ListUpdateToOneWithWhereWithoutTasksInput, ListUpdateWithoutTasksInput>, ListUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type TaskLabelUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutLabelsInput = {
    create?: XOR<BoardCreateWithoutLabelsInput, BoardUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutLabelsInput
    connect?: BoardWhereUniqueInput
  }

  export type TaskLabelCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type BoardUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<BoardCreateWithoutLabelsInput, BoardUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutLabelsInput
    upsert?: BoardUpsertWithoutLabelsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutLabelsInput, BoardUpdateWithoutLabelsInput>, BoardUncheckedUpdateWithoutLabelsInput>
  }

  export type TaskLabelUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutLabelsInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    connect?: TaskWhereUniqueInput
  }

  export type LabelCreateNestedOneWithoutTasksInput = {
    create?: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTasksInput
    connect?: LabelWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    upsert?: TaskUpsertWithoutLabelsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLabelsInput, TaskUpdateWithoutLabelsInput>, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type LabelUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTasksInput
    upsert?: LabelUpsertWithoutTasksInput
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutTasksInput, LabelUpdateWithoutTasksInput>, LabelUncheckedUpdateWithoutTasksInput>
  }

  export type PendenciaCreateNestedManyWithoutDashboardInput = {
    create?: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput> | PendenciaCreateWithoutDashboardInput[] | PendenciaUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: PendenciaCreateOrConnectWithoutDashboardInput | PendenciaCreateOrConnectWithoutDashboardInput[]
    createMany?: PendenciaCreateManyDashboardInputEnvelope
    connect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
  }

  export type NotificacaoCreateNestedManyWithoutDashboardInput = {
    create?: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput> | NotificacaoCreateWithoutDashboardInput[] | NotificacaoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: NotificacaoCreateOrConnectWithoutDashboardInput | NotificacaoCreateOrConnectWithoutDashboardInput[]
    createMany?: NotificacaoCreateManyDashboardInputEnvelope
    connect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
  }

  export type GraficoCursoCreateNestedManyWithoutDashboardInput = {
    create?: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput> | GraficoCursoCreateWithoutDashboardInput[] | GraficoCursoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoCursoCreateOrConnectWithoutDashboardInput | GraficoCursoCreateOrConnectWithoutDashboardInput[]
    createMany?: GraficoCursoCreateManyDashboardInputEnvelope
    connect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
  }

  export type GraficoBeneficiarioCreateNestedManyWithoutDashboardInput = {
    create?: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput> | GraficoBeneficiarioCreateWithoutDashboardInput[] | GraficoBeneficiarioUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoBeneficiarioCreateOrConnectWithoutDashboardInput | GraficoBeneficiarioCreateOrConnectWithoutDashboardInput[]
    createMany?: GraficoBeneficiarioCreateManyDashboardInputEnvelope
    connect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
  }

  export type PendenciaUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput> | PendenciaCreateWithoutDashboardInput[] | PendenciaUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: PendenciaCreateOrConnectWithoutDashboardInput | PendenciaCreateOrConnectWithoutDashboardInput[]
    createMany?: PendenciaCreateManyDashboardInputEnvelope
    connect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
  }

  export type NotificacaoUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput> | NotificacaoCreateWithoutDashboardInput[] | NotificacaoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: NotificacaoCreateOrConnectWithoutDashboardInput | NotificacaoCreateOrConnectWithoutDashboardInput[]
    createMany?: NotificacaoCreateManyDashboardInputEnvelope
    connect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
  }

  export type GraficoCursoUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput> | GraficoCursoCreateWithoutDashboardInput[] | GraficoCursoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoCursoCreateOrConnectWithoutDashboardInput | GraficoCursoCreateOrConnectWithoutDashboardInput[]
    createMany?: GraficoCursoCreateManyDashboardInputEnvelope
    connect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
  }

  export type GraficoBeneficiarioUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput> | GraficoBeneficiarioCreateWithoutDashboardInput[] | GraficoBeneficiarioUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoBeneficiarioCreateOrConnectWithoutDashboardInput | GraficoBeneficiarioCreateOrConnectWithoutDashboardInput[]
    createMany?: GraficoBeneficiarioCreateManyDashboardInputEnvelope
    connect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
  }

  export type PendenciaUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput> | PendenciaCreateWithoutDashboardInput[] | PendenciaUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: PendenciaCreateOrConnectWithoutDashboardInput | PendenciaCreateOrConnectWithoutDashboardInput[]
    upsert?: PendenciaUpsertWithWhereUniqueWithoutDashboardInput | PendenciaUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: PendenciaCreateManyDashboardInputEnvelope
    set?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    disconnect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    delete?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    connect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    update?: PendenciaUpdateWithWhereUniqueWithoutDashboardInput | PendenciaUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: PendenciaUpdateManyWithWhereWithoutDashboardInput | PendenciaUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: PendenciaScalarWhereInput | PendenciaScalarWhereInput[]
  }

  export type NotificacaoUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput> | NotificacaoCreateWithoutDashboardInput[] | NotificacaoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: NotificacaoCreateOrConnectWithoutDashboardInput | NotificacaoCreateOrConnectWithoutDashboardInput[]
    upsert?: NotificacaoUpsertWithWhereUniqueWithoutDashboardInput | NotificacaoUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: NotificacaoCreateManyDashboardInputEnvelope
    set?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    disconnect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    delete?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    connect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    update?: NotificacaoUpdateWithWhereUniqueWithoutDashboardInput | NotificacaoUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: NotificacaoUpdateManyWithWhereWithoutDashboardInput | NotificacaoUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: NotificacaoScalarWhereInput | NotificacaoScalarWhereInput[]
  }

  export type GraficoCursoUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput> | GraficoCursoCreateWithoutDashboardInput[] | GraficoCursoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoCursoCreateOrConnectWithoutDashboardInput | GraficoCursoCreateOrConnectWithoutDashboardInput[]
    upsert?: GraficoCursoUpsertWithWhereUniqueWithoutDashboardInput | GraficoCursoUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: GraficoCursoCreateManyDashboardInputEnvelope
    set?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    disconnect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    delete?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    connect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    update?: GraficoCursoUpdateWithWhereUniqueWithoutDashboardInput | GraficoCursoUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: GraficoCursoUpdateManyWithWhereWithoutDashboardInput | GraficoCursoUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: GraficoCursoScalarWhereInput | GraficoCursoScalarWhereInput[]
  }

  export type GraficoBeneficiarioUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput> | GraficoBeneficiarioCreateWithoutDashboardInput[] | GraficoBeneficiarioUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoBeneficiarioCreateOrConnectWithoutDashboardInput | GraficoBeneficiarioCreateOrConnectWithoutDashboardInput[]
    upsert?: GraficoBeneficiarioUpsertWithWhereUniqueWithoutDashboardInput | GraficoBeneficiarioUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: GraficoBeneficiarioCreateManyDashboardInputEnvelope
    set?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    disconnect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    delete?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    connect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    update?: GraficoBeneficiarioUpdateWithWhereUniqueWithoutDashboardInput | GraficoBeneficiarioUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: GraficoBeneficiarioUpdateManyWithWhereWithoutDashboardInput | GraficoBeneficiarioUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: GraficoBeneficiarioScalarWhereInput | GraficoBeneficiarioScalarWhereInput[]
  }

  export type PendenciaUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput> | PendenciaCreateWithoutDashboardInput[] | PendenciaUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: PendenciaCreateOrConnectWithoutDashboardInput | PendenciaCreateOrConnectWithoutDashboardInput[]
    upsert?: PendenciaUpsertWithWhereUniqueWithoutDashboardInput | PendenciaUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: PendenciaCreateManyDashboardInputEnvelope
    set?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    disconnect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    delete?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    connect?: PendenciaWhereUniqueInput | PendenciaWhereUniqueInput[]
    update?: PendenciaUpdateWithWhereUniqueWithoutDashboardInput | PendenciaUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: PendenciaUpdateManyWithWhereWithoutDashboardInput | PendenciaUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: PendenciaScalarWhereInput | PendenciaScalarWhereInput[]
  }

  export type NotificacaoUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput> | NotificacaoCreateWithoutDashboardInput[] | NotificacaoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: NotificacaoCreateOrConnectWithoutDashboardInput | NotificacaoCreateOrConnectWithoutDashboardInput[]
    upsert?: NotificacaoUpsertWithWhereUniqueWithoutDashboardInput | NotificacaoUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: NotificacaoCreateManyDashboardInputEnvelope
    set?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    disconnect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    delete?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    connect?: NotificacaoWhereUniqueInput | NotificacaoWhereUniqueInput[]
    update?: NotificacaoUpdateWithWhereUniqueWithoutDashboardInput | NotificacaoUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: NotificacaoUpdateManyWithWhereWithoutDashboardInput | NotificacaoUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: NotificacaoScalarWhereInput | NotificacaoScalarWhereInput[]
  }

  export type GraficoCursoUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput> | GraficoCursoCreateWithoutDashboardInput[] | GraficoCursoUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoCursoCreateOrConnectWithoutDashboardInput | GraficoCursoCreateOrConnectWithoutDashboardInput[]
    upsert?: GraficoCursoUpsertWithWhereUniqueWithoutDashboardInput | GraficoCursoUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: GraficoCursoCreateManyDashboardInputEnvelope
    set?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    disconnect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    delete?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    connect?: GraficoCursoWhereUniqueInput | GraficoCursoWhereUniqueInput[]
    update?: GraficoCursoUpdateWithWhereUniqueWithoutDashboardInput | GraficoCursoUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: GraficoCursoUpdateManyWithWhereWithoutDashboardInput | GraficoCursoUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: GraficoCursoScalarWhereInput | GraficoCursoScalarWhereInput[]
  }

  export type GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput> | GraficoBeneficiarioCreateWithoutDashboardInput[] | GraficoBeneficiarioUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: GraficoBeneficiarioCreateOrConnectWithoutDashboardInput | GraficoBeneficiarioCreateOrConnectWithoutDashboardInput[]
    upsert?: GraficoBeneficiarioUpsertWithWhereUniqueWithoutDashboardInput | GraficoBeneficiarioUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: GraficoBeneficiarioCreateManyDashboardInputEnvelope
    set?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    disconnect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    delete?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    connect?: GraficoBeneficiarioWhereUniqueInput | GraficoBeneficiarioWhereUniqueInput[]
    update?: GraficoBeneficiarioUpdateWithWhereUniqueWithoutDashboardInput | GraficoBeneficiarioUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: GraficoBeneficiarioUpdateManyWithWhereWithoutDashboardInput | GraficoBeneficiarioUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: GraficoBeneficiarioScalarWhereInput | GraficoBeneficiarioScalarWhereInput[]
  }

  export type DashboardCreateNestedOneWithoutPendenciasInput = {
    create?: XOR<DashboardCreateWithoutPendenciasInput, DashboardUncheckedCreateWithoutPendenciasInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutPendenciasInput
    connect?: DashboardWhereUniqueInput
  }

  export type DashboardUpdateOneRequiredWithoutPendenciasNestedInput = {
    create?: XOR<DashboardCreateWithoutPendenciasInput, DashboardUncheckedCreateWithoutPendenciasInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutPendenciasInput
    upsert?: DashboardUpsertWithoutPendenciasInput
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutPendenciasInput, DashboardUpdateWithoutPendenciasInput>, DashboardUncheckedUpdateWithoutPendenciasInput>
  }

  export type DashboardCreateNestedOneWithoutNotificacoesInput = {
    create?: XOR<DashboardCreateWithoutNotificacoesInput, DashboardUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutNotificacoesInput
    connect?: DashboardWhereUniqueInput
  }

  export type DashboardUpdateOneRequiredWithoutNotificacoesNestedInput = {
    create?: XOR<DashboardCreateWithoutNotificacoesInput, DashboardUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutNotificacoesInput
    upsert?: DashboardUpsertWithoutNotificacoesInput
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutNotificacoesInput, DashboardUpdateWithoutNotificacoesInput>, DashboardUncheckedUpdateWithoutNotificacoesInput>
  }

  export type DashboardCreateNestedOneWithoutGraficoCursosInput = {
    create?: XOR<DashboardCreateWithoutGraficoCursosInput, DashboardUncheckedCreateWithoutGraficoCursosInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutGraficoCursosInput
    connect?: DashboardWhereUniqueInput
  }

  export type DashboardUpdateOneRequiredWithoutGraficoCursosNestedInput = {
    create?: XOR<DashboardCreateWithoutGraficoCursosInput, DashboardUncheckedCreateWithoutGraficoCursosInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutGraficoCursosInput
    upsert?: DashboardUpsertWithoutGraficoCursosInput
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutGraficoCursosInput, DashboardUpdateWithoutGraficoCursosInput>, DashboardUncheckedUpdateWithoutGraficoCursosInput>
  }

  export type DashboardCreateNestedOneWithoutGraficoBeneficiariosInput = {
    create?: XOR<DashboardCreateWithoutGraficoBeneficiariosInput, DashboardUncheckedCreateWithoutGraficoBeneficiariosInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutGraficoBeneficiariosInput
    connect?: DashboardWhereUniqueInput
  }

  export type DashboardUpdateOneRequiredWithoutGraficoBeneficiariosNestedInput = {
    create?: XOR<DashboardCreateWithoutGraficoBeneficiariosInput, DashboardUncheckedCreateWithoutGraficoBeneficiariosInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutGraficoBeneficiariosInput
    upsert?: DashboardUpsertWithoutGraficoBeneficiariosInput
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutGraficoBeneficiariosInput, DashboardUpdateWithoutGraficoBeneficiariosInput>, DashboardUncheckedUpdateWithoutGraficoBeneficiariosInput>
  }

  export type coordenadorCreatecursosInput = {
    set: string[]
  }

  export type coordenadorUpdatecursosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProgramaCreateNestedOneWithoutTiposAtendimentoInput = {
    create?: XOR<ProgramaCreateWithoutTiposAtendimentoInput, ProgramaUncheckedCreateWithoutTiposAtendimentoInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutTiposAtendimentoInput
    connect?: ProgramaWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVisibilidadeFieldUpdateOperationsInput = {
    set?: $Enums.Visibilidade
  }

  export type ProgramaUpdateOneRequiredWithoutTiposAtendimentoNestedInput = {
    create?: XOR<ProgramaCreateWithoutTiposAtendimentoInput, ProgramaUncheckedCreateWithoutTiposAtendimentoInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutTiposAtendimentoInput
    upsert?: ProgramaUpsertWithoutTiposAtendimentoInput
    connect?: ProgramaWhereUniqueInput
    update?: XOR<XOR<ProgramaUpdateToOneWithWhereWithoutTiposAtendimentoInput, ProgramaUpdateWithoutTiposAtendimentoInput>, ProgramaUncheckedUpdateWithoutTiposAtendimentoInput>
  }

  export type TipoAtendimentoCreateNestedManyWithoutProgramaInput = {
    create?: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput> | TipoAtendimentoCreateWithoutProgramaInput[] | TipoAtendimentoUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: TipoAtendimentoCreateOrConnectWithoutProgramaInput | TipoAtendimentoCreateOrConnectWithoutProgramaInput[]
    createMany?: TipoAtendimentoCreateManyProgramaInputEnvelope
    connect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
  }

  export type EscalaCreateNestedManyWithoutProgramaInput = {
    create?: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput> | EscalaCreateWithoutProgramaInput[] | EscalaUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: EscalaCreateOrConnectWithoutProgramaInput | EscalaCreateOrConnectWithoutProgramaInput[]
    createMany?: EscalaCreateManyProgramaInputEnvelope
    connect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
  }

  export type TipoAtendimentoUncheckedCreateNestedManyWithoutProgramaInput = {
    create?: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput> | TipoAtendimentoCreateWithoutProgramaInput[] | TipoAtendimentoUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: TipoAtendimentoCreateOrConnectWithoutProgramaInput | TipoAtendimentoCreateOrConnectWithoutProgramaInput[]
    createMany?: TipoAtendimentoCreateManyProgramaInputEnvelope
    connect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
  }

  export type EscalaUncheckedCreateNestedManyWithoutProgramaInput = {
    create?: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput> | EscalaCreateWithoutProgramaInput[] | EscalaUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: EscalaCreateOrConnectWithoutProgramaInput | EscalaCreateOrConnectWithoutProgramaInput[]
    createMany?: EscalaCreateManyProgramaInputEnvelope
    connect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
  }

  export type TipoAtendimentoUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput> | TipoAtendimentoCreateWithoutProgramaInput[] | TipoAtendimentoUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: TipoAtendimentoCreateOrConnectWithoutProgramaInput | TipoAtendimentoCreateOrConnectWithoutProgramaInput[]
    upsert?: TipoAtendimentoUpsertWithWhereUniqueWithoutProgramaInput | TipoAtendimentoUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: TipoAtendimentoCreateManyProgramaInputEnvelope
    set?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    disconnect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    delete?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    connect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    update?: TipoAtendimentoUpdateWithWhereUniqueWithoutProgramaInput | TipoAtendimentoUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: TipoAtendimentoUpdateManyWithWhereWithoutProgramaInput | TipoAtendimentoUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: TipoAtendimentoScalarWhereInput | TipoAtendimentoScalarWhereInput[]
  }

  export type EscalaUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput> | EscalaCreateWithoutProgramaInput[] | EscalaUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: EscalaCreateOrConnectWithoutProgramaInput | EscalaCreateOrConnectWithoutProgramaInput[]
    upsert?: EscalaUpsertWithWhereUniqueWithoutProgramaInput | EscalaUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: EscalaCreateManyProgramaInputEnvelope
    set?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    disconnect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    delete?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    connect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    update?: EscalaUpdateWithWhereUniqueWithoutProgramaInput | EscalaUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: EscalaUpdateManyWithWhereWithoutProgramaInput | EscalaUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: EscalaScalarWhereInput | EscalaScalarWhereInput[]
  }

  export type TipoAtendimentoUncheckedUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput> | TipoAtendimentoCreateWithoutProgramaInput[] | TipoAtendimentoUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: TipoAtendimentoCreateOrConnectWithoutProgramaInput | TipoAtendimentoCreateOrConnectWithoutProgramaInput[]
    upsert?: TipoAtendimentoUpsertWithWhereUniqueWithoutProgramaInput | TipoAtendimentoUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: TipoAtendimentoCreateManyProgramaInputEnvelope
    set?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    disconnect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    delete?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    connect?: TipoAtendimentoWhereUniqueInput | TipoAtendimentoWhereUniqueInput[]
    update?: TipoAtendimentoUpdateWithWhereUniqueWithoutProgramaInput | TipoAtendimentoUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: TipoAtendimentoUpdateManyWithWhereWithoutProgramaInput | TipoAtendimentoUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: TipoAtendimentoScalarWhereInput | TipoAtendimentoScalarWhereInput[]
  }

  export type EscalaUncheckedUpdateManyWithoutProgramaNestedInput = {
    create?: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput> | EscalaCreateWithoutProgramaInput[] | EscalaUncheckedCreateWithoutProgramaInput[]
    connectOrCreate?: EscalaCreateOrConnectWithoutProgramaInput | EscalaCreateOrConnectWithoutProgramaInput[]
    upsert?: EscalaUpsertWithWhereUniqueWithoutProgramaInput | EscalaUpsertWithWhereUniqueWithoutProgramaInput[]
    createMany?: EscalaCreateManyProgramaInputEnvelope
    set?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    disconnect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    delete?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    connect?: EscalaWhereUniqueInput | EscalaWhereUniqueInput[]
    update?: EscalaUpdateWithWhereUniqueWithoutProgramaInput | EscalaUpdateWithWhereUniqueWithoutProgramaInput[]
    updateMany?: EscalaUpdateManyWithWhereWithoutProgramaInput | EscalaUpdateManyWithWhereWithoutProgramaInput[]
    deleteMany?: EscalaScalarWhereInput | EscalaScalarWhereInput[]
  }

  export type EscalaCreateturnosInput = {
    set: string[]
  }

  export type ProgramaCreateNestedOneWithoutEscalaInput = {
    create?: XOR<ProgramaCreateWithoutEscalaInput, ProgramaUncheckedCreateWithoutEscalaInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutEscalaInput
    connect?: ProgramaWhereUniqueInput
  }

  export type EscalaUpdateturnosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProgramaUpdateOneRequiredWithoutEscalaNestedInput = {
    create?: XOR<ProgramaCreateWithoutEscalaInput, ProgramaUncheckedCreateWithoutEscalaInput>
    connectOrCreate?: ProgramaCreateOrConnectWithoutEscalaInput
    upsert?: ProgramaUpsertWithoutEscalaInput
    connect?: ProgramaWhereUniqueInput
    update?: XOR<XOR<ProgramaUpdateToOneWithWhereWithoutEscalaInput, ProgramaUpdateWithoutEscalaInput>, ProgramaUncheckedUpdateWithoutEscalaInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBoardVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardVisibility | EnumBoardVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardVisibilityFilter<$PrismaModel> | $Enums.BoardVisibility
  }

  export type NestedEnumBoardVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardVisibility | EnumBoardVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardVisibility[] | ListEnumBoardVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.BoardVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBoardVisibilityFilter<$PrismaModel>
    _max?: NestedEnumBoardVisibilityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVisibilidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibilidade | EnumVisibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilidadeFilter<$PrismaModel> | $Enums.Visibilidade
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVisibilidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibilidade | EnumVisibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibilidade[] | ListEnumVisibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilidadeWithAggregatesFilter<$PrismaModel> | $Enums.Visibilidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilidadeFilter<$PrismaModel>
    _max?: NestedEnumVisibilidadeFilter<$PrismaModel>
  }

  export type BoardCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: BoardMemberCreateNestedManyWithoutBoardInput
    lists?: ListCreateNestedManyWithoutBoardInput
    labels?: LabelCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: BoardMemberUncheckedCreateNestedManyWithoutBoardInput
    lists?: ListUncheckedCreateNestedManyWithoutBoardInput
    labels?: LabelUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutOwnerInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput>
  }

  export type BoardCreateManyOwnerInputEnvelope = {
    data: BoardCreateManyOwnerInput | BoardCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BoardMemberCreateWithoutUserInput = {
    role: $Enums.Role
    joinedAt?: Date | string
    board: BoardCreateNestedOneWithoutMembersInput
  }

  export type BoardMemberUncheckedCreateWithoutUserInput = {
    boardId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type BoardMemberCreateOrConnectWithoutUserInput = {
    where: BoardMemberWhereUniqueInput
    create: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput>
  }

  export type BoardMemberCreateManyUserInputEnvelope = {
    data: BoardMemberCreateManyUserInput | BoardMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    list: ListCreateNestedOneWithoutTasksInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: string
    listId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: TaskCreateManyCreatorInput | TaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutOwnerInput, BoardUncheckedUpdateWithoutOwnerInput>
    create: XOR<BoardCreateWithoutOwnerInput, BoardUncheckedCreateWithoutOwnerInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutOwnerInput, BoardUncheckedUpdateWithoutOwnerInput>
  }

  export type BoardUpdateManyWithWhereWithoutOwnerInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BoardScalarWhereInput = {
    AND?: BoardScalarWhereInput | BoardScalarWhereInput[]
    OR?: BoardScalarWhereInput[]
    NOT?: BoardScalarWhereInput | BoardScalarWhereInput[]
    id?: StringFilter<"Board"> | string
    ownerId?: StringFilter<"Board"> | string
    title?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    visibility?: EnumBoardVisibilityFilter<"Board"> | $Enums.BoardVisibility
    isArchived?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
  }

  export type BoardMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardMemberWhereUniqueInput
    update: XOR<BoardMemberUpdateWithoutUserInput, BoardMemberUncheckedUpdateWithoutUserInput>
    create: XOR<BoardMemberCreateWithoutUserInput, BoardMemberUncheckedCreateWithoutUserInput>
  }

  export type BoardMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardMemberWhereUniqueInput
    data: XOR<BoardMemberUpdateWithoutUserInput, BoardMemberUncheckedUpdateWithoutUserInput>
  }

  export type BoardMemberUpdateManyWithWhereWithoutUserInput = {
    where: BoardMemberScalarWhereInput
    data: XOR<BoardMemberUpdateManyMutationInput, BoardMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type BoardMemberScalarWhereInput = {
    AND?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
    OR?: BoardMemberScalarWhereInput[]
    NOT?: BoardMemberScalarWhereInput | BoardMemberScalarWhereInput[]
    boardId?: StringFilter<"BoardMember"> | string
    userId?: StringFilter<"BoardMember"> | string
    role?: EnumRoleFilter<"BoardMember"> | $Enums.Role
    joinedAt?: DateTimeFilter<"BoardMember"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    listId?: StringFilter<"Task"> | string
    creatorId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    position?: IntFilter<"Task"> | number
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isArchived?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type UserCreateWithoutBoardsInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    memberships?: BoardMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutBoardsInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    memberships?: BoardMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
  }

  export type BoardMemberCreateWithoutBoardInput = {
    role: $Enums.Role
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type BoardMemberUncheckedCreateWithoutBoardInput = {
    userId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type BoardMemberCreateOrConnectWithoutBoardInput = {
    where: BoardMemberWhereUniqueInput
    create: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput>
  }

  export type BoardMemberCreateManyBoardInputEnvelope = {
    data: BoardMemberCreateManyBoardInput | BoardMemberCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ListCreateWithoutBoardInput = {
    id?: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateWithoutBoardInput = {
    id?: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutListInput
  }

  export type ListCreateOrConnectWithoutBoardInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput>
  }

  export type ListCreateManyBoardInputEnvelope = {
    data: ListCreateManyBoardInput | ListCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type LabelCreateWithoutBoardInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutBoardInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutBoardInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput>
  }

  export type LabelCreateManyBoardInputEnvelope = {
    data: LabelCreateManyBoardInput | LabelCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBoardsInput = {
    update: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBoardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
  }

  export type UserUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    memberships?: BoardMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    memberships?: BoardMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type BoardMemberUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardMemberWhereUniqueInput
    update: XOR<BoardMemberUpdateWithoutBoardInput, BoardMemberUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardMemberCreateWithoutBoardInput, BoardMemberUncheckedCreateWithoutBoardInput>
  }

  export type BoardMemberUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardMemberWhereUniqueInput
    data: XOR<BoardMemberUpdateWithoutBoardInput, BoardMemberUncheckedUpdateWithoutBoardInput>
  }

  export type BoardMemberUpdateManyWithWhereWithoutBoardInput = {
    where: BoardMemberScalarWhereInput
    data: XOR<BoardMemberUpdateManyMutationInput, BoardMemberUncheckedUpdateManyWithoutBoardInput>
  }

  export type ListUpsertWithWhereUniqueWithoutBoardInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutBoardInput, ListUncheckedUpdateWithoutBoardInput>
    create: XOR<ListCreateWithoutBoardInput, ListUncheckedCreateWithoutBoardInput>
  }

  export type ListUpdateWithWhereUniqueWithoutBoardInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutBoardInput, ListUncheckedUpdateWithoutBoardInput>
  }

  export type ListUpdateManyWithWhereWithoutBoardInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutBoardInput>
  }

  export type ListScalarWhereInput = {
    AND?: ListScalarWhereInput | ListScalarWhereInput[]
    OR?: ListScalarWhereInput[]
    NOT?: ListScalarWhereInput | ListScalarWhereInput[]
    id?: StringFilter<"List"> | string
    boardId?: StringFilter<"List"> | string
    title?: StringFilter<"List"> | string
    position?: IntFilter<"List"> | number
    isArchived?: BoolFilter<"List"> | boolean
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
  }

  export type LabelUpsertWithWhereUniqueWithoutBoardInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutBoardInput, LabelUncheckedUpdateWithoutBoardInput>
    create: XOR<LabelCreateWithoutBoardInput, LabelUncheckedCreateWithoutBoardInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutBoardInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutBoardInput, LabelUncheckedUpdateWithoutBoardInput>
  }

  export type LabelUpdateManyWithWhereWithoutBoardInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutBoardInput>
  }

  export type LabelScalarWhereInput = {
    AND?: LabelScalarWhereInput | LabelScalarWhereInput[]
    OR?: LabelScalarWhereInput[]
    NOT?: LabelScalarWhereInput | LabelScalarWhereInput[]
    id?: StringFilter<"Label"> | string
    boardId?: StringFilter<"Label"> | string
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
  }

  export type BoardCreateWithoutMembersInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBoardsInput
    lists?: ListCreateNestedManyWithoutBoardInput
    labels?: LabelCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutMembersInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lists?: ListUncheckedCreateNestedManyWithoutBoardInput
    labels?: LabelUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutMembersInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutMembersInput, BoardUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardUncheckedCreateNestedManyWithoutOwnerInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type BoardUpsertWithoutMembersInput = {
    update: XOR<BoardUpdateWithoutMembersInput, BoardUncheckedUpdateWithoutMembersInput>
    create: XOR<BoardCreateWithoutMembersInput, BoardUncheckedCreateWithoutMembersInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutMembersInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutMembersInput, BoardUncheckedUpdateWithoutMembersInput>
  }

  export type BoardUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBoardsNestedInput
    lists?: ListUpdateManyWithoutBoardNestedInput
    labels?: LabelUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lists?: ListUncheckedUpdateManyWithoutBoardNestedInput
    labels?: LabelUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUncheckedUpdateManyWithoutOwnerNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type BoardCreateWithoutListsInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBoardsInput
    members?: BoardMemberCreateNestedManyWithoutBoardInput
    labels?: LabelCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutListsInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: BoardMemberUncheckedCreateNestedManyWithoutBoardInput
    labels?: LabelUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutListsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutListsInput, BoardUncheckedCreateWithoutListsInput>
  }

  export type TaskCreateWithoutListInput = {
    id?: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutListInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutListInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput>
  }

  export type TaskCreateManyListInputEnvelope = {
    data: TaskCreateManyListInput | TaskCreateManyListInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutListsInput = {
    update: XOR<BoardUpdateWithoutListsInput, BoardUncheckedUpdateWithoutListsInput>
    create: XOR<BoardCreateWithoutListsInput, BoardUncheckedCreateWithoutListsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutListsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutListsInput, BoardUncheckedUpdateWithoutListsInput>
  }

  export type BoardUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBoardsNestedInput
    members?: BoardMemberUpdateManyWithoutBoardNestedInput
    labels?: LabelUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: BoardMemberUncheckedUpdateManyWithoutBoardNestedInput
    labels?: LabelUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutListInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutListInput, TaskUncheckedUpdateWithoutListInput>
    create: XOR<TaskCreateWithoutListInput, TaskUncheckedCreateWithoutListInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutListInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutListInput, TaskUncheckedUpdateWithoutListInput>
  }

  export type TaskUpdateManyWithWhereWithoutListInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutListInput>
  }

  export type ListCreateWithoutTasksInput = {
    id?: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutListsInput
  }

  export type ListUncheckedCreateWithoutTasksInput = {
    id?: string
    boardId: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListCreateOrConnectWithoutTasksInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutTasksInput, ListUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardCreateNestedManyWithoutOwnerInput
    memberships?: BoardMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: string
    role: $Enums.Role
    name?: string | null
    email: string
    userName?: string | null
    passwordHash?: string | null
    authProvider: $Enums.AuthProvider
    isVerified?: boolean
    CreatedAt?: Date | string
    updatedAt?: Date | string
    providerId?: string | null
    isAdmin?: boolean
    boards?: BoardUncheckedCreateNestedManyWithoutOwnerInput
    memberships?: BoardMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type TaskLabelCreateWithoutTaskInput = {
    label: LabelCreateNestedOneWithoutTasksInput
  }

  export type TaskLabelUncheckedCreateWithoutTaskInput = {
    labelId: string
  }

  export type TaskLabelCreateOrConnectWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelCreateManyTaskInputEnvelope = {
    data: TaskLabelCreateManyTaskInput | TaskLabelCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ListUpsertWithoutTasksInput = {
    update: XOR<ListUpdateWithoutTasksInput, ListUncheckedUpdateWithoutTasksInput>
    create: XOR<ListCreateWithoutTasksInput, ListUncheckedCreateWithoutTasksInput>
    where?: ListWhereInput
  }

  export type ListUpdateToOneWithWhereWithoutTasksInput = {
    where?: ListWhereInput
    data: XOR<ListUpdateWithoutTasksInput, ListUncheckedUpdateWithoutTasksInput>
  }

  export type ListUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUpdateManyWithoutOwnerNestedInput
    memberships?: BoardMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUncheckedUpdateManyWithoutOwnerNestedInput
    memberships?: BoardMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLabelScalarWhereInput = {
    AND?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    OR?: TaskLabelScalarWhereInput[]
    NOT?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    taskId?: StringFilter<"TaskLabel"> | string
    labelId?: StringFilter<"TaskLabel"> | string
  }

  export type BoardCreateWithoutLabelsInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutBoardsInput
    members?: BoardMemberCreateNestedManyWithoutBoardInput
    lists?: ListCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutLabelsInput = {
    id?: string
    ownerId: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: BoardMemberUncheckedCreateNestedManyWithoutBoardInput
    lists?: ListUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutLabelsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutLabelsInput, BoardUncheckedCreateWithoutLabelsInput>
  }

  export type TaskLabelCreateWithoutLabelInput = {
    task: TaskCreateNestedOneWithoutLabelsInput
  }

  export type TaskLabelUncheckedCreateWithoutLabelInput = {
    taskId: string
  }

  export type TaskLabelCreateOrConnectWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelCreateManyLabelInputEnvelope = {
    data: TaskLabelCreateManyLabelInput | TaskLabelCreateManyLabelInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutLabelsInput = {
    update: XOR<BoardUpdateWithoutLabelsInput, BoardUncheckedUpdateWithoutLabelsInput>
    create: XOR<BoardCreateWithoutLabelsInput, BoardUncheckedCreateWithoutLabelsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutLabelsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutLabelsInput, BoardUncheckedUpdateWithoutLabelsInput>
  }

  export type BoardUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBoardsNestedInput
    members?: BoardMemberUpdateManyWithoutBoardNestedInput
    lists?: ListUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: BoardMemberUncheckedUpdateManyWithoutBoardNestedInput
    lists?: ListUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutLabelInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutLabelInput>
  }

  export type TaskCreateWithoutLabelsInput = {
    id?: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    list: ListCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
  }

  export type TaskUncheckedCreateWithoutLabelsInput = {
    id?: string
    listId: string
    creatorId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutLabelsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
  }

  export type LabelCreateWithoutTasksInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutTasksInput = {
    id?: string
    boardId: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabelCreateOrConnectWithoutTasksInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
  }

  export type TaskUpsertWithoutLabelsInput = {
    update: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLabelsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type TaskUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
  }

  export type TaskUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpsertWithoutTasksInput = {
    update: XOR<LabelUpdateWithoutTasksInput, LabelUncheckedUpdateWithoutTasksInput>
    create: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutTasksInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutTasksInput, LabelUncheckedUpdateWithoutTasksInput>
  }

  export type LabelUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendenciaCreateWithoutDashboardInput = {
    descricao: string
  }

  export type PendenciaUncheckedCreateWithoutDashboardInput = {
    id?: number
    descricao: string
  }

  export type PendenciaCreateOrConnectWithoutDashboardInput = {
    where: PendenciaWhereUniqueInput
    create: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput>
  }

  export type PendenciaCreateManyDashboardInputEnvelope = {
    data: PendenciaCreateManyDashboardInput | PendenciaCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type NotificacaoCreateWithoutDashboardInput = {
    mensagem: string
  }

  export type NotificacaoUncheckedCreateWithoutDashboardInput = {
    id?: number
    mensagem: string
  }

  export type NotificacaoCreateOrConnectWithoutDashboardInput = {
    where: NotificacaoWhereUniqueInput
    create: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput>
  }

  export type NotificacaoCreateManyDashboardInputEnvelope = {
    data: NotificacaoCreateManyDashboardInput | NotificacaoCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type GraficoCursoCreateWithoutDashboardInput = {
    label: string
    valor: number
  }

  export type GraficoCursoUncheckedCreateWithoutDashboardInput = {
    id?: number
    label: string
    valor: number
  }

  export type GraficoCursoCreateOrConnectWithoutDashboardInput = {
    where: GraficoCursoWhereUniqueInput
    create: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput>
  }

  export type GraficoCursoCreateManyDashboardInputEnvelope = {
    data: GraficoCursoCreateManyDashboardInput | GraficoCursoCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type GraficoBeneficiarioCreateWithoutDashboardInput = {
    label: string
    valor: number
  }

  export type GraficoBeneficiarioUncheckedCreateWithoutDashboardInput = {
    id?: number
    label: string
    valor: number
  }

  export type GraficoBeneficiarioCreateOrConnectWithoutDashboardInput = {
    where: GraficoBeneficiarioWhereUniqueInput
    create: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput>
  }

  export type GraficoBeneficiarioCreateManyDashboardInputEnvelope = {
    data: GraficoBeneficiarioCreateManyDashboardInput | GraficoBeneficiarioCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type PendenciaUpsertWithWhereUniqueWithoutDashboardInput = {
    where: PendenciaWhereUniqueInput
    update: XOR<PendenciaUpdateWithoutDashboardInput, PendenciaUncheckedUpdateWithoutDashboardInput>
    create: XOR<PendenciaCreateWithoutDashboardInput, PendenciaUncheckedCreateWithoutDashboardInput>
  }

  export type PendenciaUpdateWithWhereUniqueWithoutDashboardInput = {
    where: PendenciaWhereUniqueInput
    data: XOR<PendenciaUpdateWithoutDashboardInput, PendenciaUncheckedUpdateWithoutDashboardInput>
  }

  export type PendenciaUpdateManyWithWhereWithoutDashboardInput = {
    where: PendenciaScalarWhereInput
    data: XOR<PendenciaUpdateManyMutationInput, PendenciaUncheckedUpdateManyWithoutDashboardInput>
  }

  export type PendenciaScalarWhereInput = {
    AND?: PendenciaScalarWhereInput | PendenciaScalarWhereInput[]
    OR?: PendenciaScalarWhereInput[]
    NOT?: PendenciaScalarWhereInput | PendenciaScalarWhereInput[]
    id?: IntFilter<"Pendencia"> | number
    descricao?: StringFilter<"Pendencia"> | string
    dashboardId?: IntFilter<"Pendencia"> | number
  }

  export type NotificacaoUpsertWithWhereUniqueWithoutDashboardInput = {
    where: NotificacaoWhereUniqueInput
    update: XOR<NotificacaoUpdateWithoutDashboardInput, NotificacaoUncheckedUpdateWithoutDashboardInput>
    create: XOR<NotificacaoCreateWithoutDashboardInput, NotificacaoUncheckedCreateWithoutDashboardInput>
  }

  export type NotificacaoUpdateWithWhereUniqueWithoutDashboardInput = {
    where: NotificacaoWhereUniqueInput
    data: XOR<NotificacaoUpdateWithoutDashboardInput, NotificacaoUncheckedUpdateWithoutDashboardInput>
  }

  export type NotificacaoUpdateManyWithWhereWithoutDashboardInput = {
    where: NotificacaoScalarWhereInput
    data: XOR<NotificacaoUpdateManyMutationInput, NotificacaoUncheckedUpdateManyWithoutDashboardInput>
  }

  export type NotificacaoScalarWhereInput = {
    AND?: NotificacaoScalarWhereInput | NotificacaoScalarWhereInput[]
    OR?: NotificacaoScalarWhereInput[]
    NOT?: NotificacaoScalarWhereInput | NotificacaoScalarWhereInput[]
    id?: IntFilter<"Notificacao"> | number
    mensagem?: StringFilter<"Notificacao"> | string
    dashboardId?: IntFilter<"Notificacao"> | number
  }

  export type GraficoCursoUpsertWithWhereUniqueWithoutDashboardInput = {
    where: GraficoCursoWhereUniqueInput
    update: XOR<GraficoCursoUpdateWithoutDashboardInput, GraficoCursoUncheckedUpdateWithoutDashboardInput>
    create: XOR<GraficoCursoCreateWithoutDashboardInput, GraficoCursoUncheckedCreateWithoutDashboardInput>
  }

  export type GraficoCursoUpdateWithWhereUniqueWithoutDashboardInput = {
    where: GraficoCursoWhereUniqueInput
    data: XOR<GraficoCursoUpdateWithoutDashboardInput, GraficoCursoUncheckedUpdateWithoutDashboardInput>
  }

  export type GraficoCursoUpdateManyWithWhereWithoutDashboardInput = {
    where: GraficoCursoScalarWhereInput
    data: XOR<GraficoCursoUpdateManyMutationInput, GraficoCursoUncheckedUpdateManyWithoutDashboardInput>
  }

  export type GraficoCursoScalarWhereInput = {
    AND?: GraficoCursoScalarWhereInput | GraficoCursoScalarWhereInput[]
    OR?: GraficoCursoScalarWhereInput[]
    NOT?: GraficoCursoScalarWhereInput | GraficoCursoScalarWhereInput[]
    id?: IntFilter<"GraficoCurso"> | number
    label?: StringFilter<"GraficoCurso"> | string
    valor?: IntFilter<"GraficoCurso"> | number
    dashboardId?: IntFilter<"GraficoCurso"> | number
  }

  export type GraficoBeneficiarioUpsertWithWhereUniqueWithoutDashboardInput = {
    where: GraficoBeneficiarioWhereUniqueInput
    update: XOR<GraficoBeneficiarioUpdateWithoutDashboardInput, GraficoBeneficiarioUncheckedUpdateWithoutDashboardInput>
    create: XOR<GraficoBeneficiarioCreateWithoutDashboardInput, GraficoBeneficiarioUncheckedCreateWithoutDashboardInput>
  }

  export type GraficoBeneficiarioUpdateWithWhereUniqueWithoutDashboardInput = {
    where: GraficoBeneficiarioWhereUniqueInput
    data: XOR<GraficoBeneficiarioUpdateWithoutDashboardInput, GraficoBeneficiarioUncheckedUpdateWithoutDashboardInput>
  }

  export type GraficoBeneficiarioUpdateManyWithWhereWithoutDashboardInput = {
    where: GraficoBeneficiarioScalarWhereInput
    data: XOR<GraficoBeneficiarioUpdateManyMutationInput, GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardInput>
  }

  export type GraficoBeneficiarioScalarWhereInput = {
    AND?: GraficoBeneficiarioScalarWhereInput | GraficoBeneficiarioScalarWhereInput[]
    OR?: GraficoBeneficiarioScalarWhereInput[]
    NOT?: GraficoBeneficiarioScalarWhereInput | GraficoBeneficiarioScalarWhereInput[]
    id?: IntFilter<"GraficoBeneficiario"> | number
    label?: StringFilter<"GraficoBeneficiario"> | string
    valor?: IntFilter<"GraficoBeneficiario"> | number
    dashboardId?: IntFilter<"GraficoBeneficiario"> | number
  }

  export type DashboardCreateWithoutPendenciasInput = {
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    notificacoes?: NotificacaoCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutPendenciasInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    notificacoes?: NotificacaoUncheckedCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoUncheckedCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardCreateOrConnectWithoutPendenciasInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutPendenciasInput, DashboardUncheckedCreateWithoutPendenciasInput>
  }

  export type DashboardUpsertWithoutPendenciasInput = {
    update: XOR<DashboardUpdateWithoutPendenciasInput, DashboardUncheckedUpdateWithoutPendenciasInput>
    create: XOR<DashboardCreateWithoutPendenciasInput, DashboardUncheckedCreateWithoutPendenciasInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutPendenciasInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutPendenciasInput, DashboardUncheckedUpdateWithoutPendenciasInput>
  }

  export type DashboardUpdateWithoutPendenciasInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    notificacoes?: NotificacaoUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutPendenciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    notificacoes?: NotificacaoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateWithoutNotificacoesInput = {
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutNotificacoesInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaUncheckedCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoUncheckedCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardCreateOrConnectWithoutNotificacoesInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutNotificacoesInput, DashboardUncheckedCreateWithoutNotificacoesInput>
  }

  export type DashboardUpsertWithoutNotificacoesInput = {
    update: XOR<DashboardUpdateWithoutNotificacoesInput, DashboardUncheckedUpdateWithoutNotificacoesInput>
    create: XOR<DashboardCreateWithoutNotificacoesInput, DashboardUncheckedCreateWithoutNotificacoesInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutNotificacoesInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutNotificacoesInput, DashboardUncheckedUpdateWithoutNotificacoesInput>
  }

  export type DashboardUpdateWithoutNotificacoesInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutNotificacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUncheckedUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateWithoutGraficoCursosInput = {
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutGraficoCursosInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaUncheckedCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoUncheckedCreateNestedManyWithoutDashboardInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardCreateOrConnectWithoutGraficoCursosInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutGraficoCursosInput, DashboardUncheckedCreateWithoutGraficoCursosInput>
  }

  export type DashboardUpsertWithoutGraficoCursosInput = {
    update: XOR<DashboardUpdateWithoutGraficoCursosInput, DashboardUncheckedUpdateWithoutGraficoCursosInput>
    create: XOR<DashboardCreateWithoutGraficoCursosInput, DashboardUncheckedCreateWithoutGraficoCursosInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutGraficoCursosInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutGraficoCursosInput, DashboardUncheckedUpdateWithoutGraficoCursosInput>
  }

  export type DashboardUpdateWithoutGraficoCursosInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutGraficoCursosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUncheckedUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoBeneficiarios?: GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateWithoutGraficoBeneficiariosInput = {
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateWithoutGraficoBeneficiariosInput = {
    id?: number
    cursos: number
    programas: number
    usuarios: number
    atendimentosMes: number
    pendencias?: PendenciaUncheckedCreateNestedManyWithoutDashboardInput
    notificacoes?: NotificacaoUncheckedCreateNestedManyWithoutDashboardInput
    graficoCursos?: GraficoCursoUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardCreateOrConnectWithoutGraficoBeneficiariosInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutGraficoBeneficiariosInput, DashboardUncheckedCreateWithoutGraficoBeneficiariosInput>
  }

  export type DashboardUpsertWithoutGraficoBeneficiariosInput = {
    update: XOR<DashboardUpdateWithoutGraficoBeneficiariosInput, DashboardUncheckedUpdateWithoutGraficoBeneficiariosInput>
    create: XOR<DashboardCreateWithoutGraficoBeneficiariosInput, DashboardUncheckedCreateWithoutGraficoBeneficiariosInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutGraficoBeneficiariosInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutGraficoBeneficiariosInput, DashboardUncheckedUpdateWithoutGraficoBeneficiariosInput>
  }

  export type DashboardUpdateWithoutGraficoBeneficiariosInput = {
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateWithoutGraficoBeneficiariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cursos?: IntFieldUpdateOperationsInput | number
    programas?: IntFieldUpdateOperationsInput | number
    usuarios?: IntFieldUpdateOperationsInput | number
    atendimentosMes?: IntFieldUpdateOperationsInput | number
    pendencias?: PendenciaUncheckedUpdateManyWithoutDashboardNestedInput
    notificacoes?: NotificacaoUncheckedUpdateManyWithoutDashboardNestedInput
    graficoCursos?: GraficoCursoUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type ProgramaCreateWithoutTiposAtendimentoInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Escala?: EscalaCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUncheckedCreateWithoutTiposAtendimentoInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Escala?: EscalaUncheckedCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaCreateOrConnectWithoutTiposAtendimentoInput = {
    where: ProgramaWhereUniqueInput
    create: XOR<ProgramaCreateWithoutTiposAtendimentoInput, ProgramaUncheckedCreateWithoutTiposAtendimentoInput>
  }

  export type ProgramaUpsertWithoutTiposAtendimentoInput = {
    update: XOR<ProgramaUpdateWithoutTiposAtendimentoInput, ProgramaUncheckedUpdateWithoutTiposAtendimentoInput>
    create: XOR<ProgramaCreateWithoutTiposAtendimentoInput, ProgramaUncheckedCreateWithoutTiposAtendimentoInput>
    where?: ProgramaWhereInput
  }

  export type ProgramaUpdateToOneWithWhereWithoutTiposAtendimentoInput = {
    where?: ProgramaWhereInput
    data: XOR<ProgramaUpdateWithoutTiposAtendimentoInput, ProgramaUncheckedUpdateWithoutTiposAtendimentoInput>
  }

  export type ProgramaUpdateWithoutTiposAtendimentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escala?: EscalaUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateWithoutTiposAtendimentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Escala?: EscalaUncheckedUpdateManyWithoutProgramaNestedInput
  }

  export type TipoAtendimentoCreateWithoutProgramaInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
  }

  export type TipoAtendimentoUncheckedCreateWithoutProgramaInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
  }

  export type TipoAtendimentoCreateOrConnectWithoutProgramaInput = {
    where: TipoAtendimentoWhereUniqueInput
    create: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput>
  }

  export type TipoAtendimentoCreateManyProgramaInputEnvelope = {
    data: TipoAtendimentoCreateManyProgramaInput | TipoAtendimentoCreateManyProgramaInput[]
    skipDuplicates?: boolean
  }

  export type EscalaCreateWithoutProgramaInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscalaUncheckedCreateWithoutProgramaInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EscalaCreateOrConnectWithoutProgramaInput = {
    where: EscalaWhereUniqueInput
    create: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput>
  }

  export type EscalaCreateManyProgramaInputEnvelope = {
    data: EscalaCreateManyProgramaInput | EscalaCreateManyProgramaInput[]
    skipDuplicates?: boolean
  }

  export type TipoAtendimentoUpsertWithWhereUniqueWithoutProgramaInput = {
    where: TipoAtendimentoWhereUniqueInput
    update: XOR<TipoAtendimentoUpdateWithoutProgramaInput, TipoAtendimentoUncheckedUpdateWithoutProgramaInput>
    create: XOR<TipoAtendimentoCreateWithoutProgramaInput, TipoAtendimentoUncheckedCreateWithoutProgramaInput>
  }

  export type TipoAtendimentoUpdateWithWhereUniqueWithoutProgramaInput = {
    where: TipoAtendimentoWhereUniqueInput
    data: XOR<TipoAtendimentoUpdateWithoutProgramaInput, TipoAtendimentoUncheckedUpdateWithoutProgramaInput>
  }

  export type TipoAtendimentoUpdateManyWithWhereWithoutProgramaInput = {
    where: TipoAtendimentoScalarWhereInput
    data: XOR<TipoAtendimentoUpdateManyMutationInput, TipoAtendimentoUncheckedUpdateManyWithoutProgramaInput>
  }

  export type TipoAtendimentoScalarWhereInput = {
    AND?: TipoAtendimentoScalarWhereInput | TipoAtendimentoScalarWhereInput[]
    OR?: TipoAtendimentoScalarWhereInput[]
    NOT?: TipoAtendimentoScalarWhereInput | TipoAtendimentoScalarWhereInput[]
    id?: StringFilter<"TipoAtendimento"> | string
    nome?: StringFilter<"TipoAtendimento"> | string
    sigla?: StringFilter<"TipoAtendimento"> | string
    descricao?: StringNullableFilter<"TipoAtendimento"> | string | null
    publico?: StringNullableFilter<"TipoAtendimento"> | string | null
    duracao?: IntNullableFilter<"TipoAtendimento"> | number | null
    frequencia?: StringNullableFilter<"TipoAtendimento"> | string | null
    visibilidade?: EnumVisibilidadeFilter<"TipoAtendimento"> | $Enums.Visibilidade
    instrucoesAluno?: StringNullableFilter<"TipoAtendimento"> | string | null
    orientacoesPublicas?: StringNullableFilter<"TipoAtendimento"> | string | null
    status?: StringFilter<"TipoAtendimento"> | string
    programaId?: StringFilter<"TipoAtendimento"> | string
  }

  export type EscalaUpsertWithWhereUniqueWithoutProgramaInput = {
    where: EscalaWhereUniqueInput
    update: XOR<EscalaUpdateWithoutProgramaInput, EscalaUncheckedUpdateWithoutProgramaInput>
    create: XOR<EscalaCreateWithoutProgramaInput, EscalaUncheckedCreateWithoutProgramaInput>
  }

  export type EscalaUpdateWithWhereUniqueWithoutProgramaInput = {
    where: EscalaWhereUniqueInput
    data: XOR<EscalaUpdateWithoutProgramaInput, EscalaUncheckedUpdateWithoutProgramaInput>
  }

  export type EscalaUpdateManyWithWhereWithoutProgramaInput = {
    where: EscalaScalarWhereInput
    data: XOR<EscalaUpdateManyMutationInput, EscalaUncheckedUpdateManyWithoutProgramaInput>
  }

  export type EscalaScalarWhereInput = {
    AND?: EscalaScalarWhereInput | EscalaScalarWhereInput[]
    OR?: EscalaScalarWhereInput[]
    NOT?: EscalaScalarWhereInput | EscalaScalarWhereInput[]
    id?: StringFilter<"Escala"> | string
    nome?: StringFilter<"Escala"> | string
    matricula?: StringFilter<"Escala"> | string
    curso?: StringFilter<"Escala"> | string
    status?: StringFilter<"Escala"> | string
    turnos?: StringNullableListFilter<"Escala">
    programaId?: StringFilter<"Escala"> | string
    createdAt?: DateTimeFilter<"Escala"> | Date | string
    updatedAt?: DateTimeFilter<"Escala"> | Date | string
  }

  export type ProgramaCreateWithoutEscalaInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tiposAtendimento?: TipoAtendimentoCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaUncheckedCreateWithoutEscalaInput = {
    id?: string
    nome: string
    descricao?: string | null
    tipo: string
    status: string
    sala?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    curso: string
    assistentes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tiposAtendimento?: TipoAtendimentoUncheckedCreateNestedManyWithoutProgramaInput
  }

  export type ProgramaCreateOrConnectWithoutEscalaInput = {
    where: ProgramaWhereUniqueInput
    create: XOR<ProgramaCreateWithoutEscalaInput, ProgramaUncheckedCreateWithoutEscalaInput>
  }

  export type ProgramaUpsertWithoutEscalaInput = {
    update: XOR<ProgramaUpdateWithoutEscalaInput, ProgramaUncheckedUpdateWithoutEscalaInput>
    create: XOR<ProgramaCreateWithoutEscalaInput, ProgramaUncheckedCreateWithoutEscalaInput>
    where?: ProgramaWhereInput
  }

  export type ProgramaUpdateToOneWithWhereWithoutEscalaInput = {
    where?: ProgramaWhereInput
    data: XOR<ProgramaUpdateWithoutEscalaInput, ProgramaUncheckedUpdateWithoutEscalaInput>
  }

  export type ProgramaUpdateWithoutEscalaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiposAtendimento?: TipoAtendimentoUpdateManyWithoutProgramaNestedInput
  }

  export type ProgramaUncheckedUpdateWithoutEscalaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sala?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curso?: StringFieldUpdateOperationsInput | string
    assistentes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiposAtendimento?: TipoAtendimentoUncheckedUpdateManyWithoutProgramaNestedInput
  }

  export type BoardCreateManyOwnerInput = {
    id?: string
    title: string
    description?: string | null
    visibility?: $Enums.BoardVisibility
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardMemberCreateManyUserInput = {
    boardId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: string
    listId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: BoardMemberUpdateManyWithoutBoardNestedInput
    lists?: ListUpdateManyWithoutBoardNestedInput
    labels?: LabelUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: BoardMemberUncheckedUpdateManyWithoutBoardNestedInput
    lists?: ListUncheckedUpdateManyWithoutBoardNestedInput
    labels?: LabelUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumBoardVisibilityFieldUpdateOperationsInput | $Enums.BoardVisibility
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutMembersNestedInput
  }

  export type BoardMemberUncheckedUpdateWithoutUserInput = {
    boardId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberUncheckedUpdateManyWithoutUserInput = {
    boardId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: ListUpdateOneRequiredWithoutTasksNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberCreateManyBoardInput = {
    userId: string
    role: $Enums.Role
    joinedAt?: Date | string
  }

  export type ListCreateManyBoardInput = {
    id?: string
    title: string
    position: number
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabelCreateManyBoardInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardMemberUpdateWithoutBoardInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type BoardMemberUncheckedUpdateWithoutBoardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardMemberUncheckedUpdateManyWithoutBoardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyListInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    position: number
    status: string
    dueDate?: Date | string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateManyTaskInput = {
    labelId: string
  }

  export type TaskLabelUpdateWithoutTaskInput = {
    label?: LabelUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutTaskInput = {
    labelId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskInput = {
    labelId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelCreateManyLabelInput = {
    taskId: string
  }

  export type TaskLabelUpdateWithoutLabelInput = {
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutLabelInput = {
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelInput = {
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type PendenciaCreateManyDashboardInput = {
    id?: number
    descricao: string
  }

  export type NotificacaoCreateManyDashboardInput = {
    id?: number
    mensagem: string
  }

  export type GraficoCursoCreateManyDashboardInput = {
    id?: number
    label: string
    valor: number
  }

  export type GraficoBeneficiarioCreateManyDashboardInput = {
    id?: number
    label: string
    valor: number
  }

  export type PendenciaUpdateWithoutDashboardInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type PendenciaUncheckedUpdateWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type PendenciaUncheckedUpdateManyWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacaoUpdateWithoutDashboardInput = {
    mensagem?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacaoUncheckedUpdateWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacaoUncheckedUpdateManyWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem?: StringFieldUpdateOperationsInput | string
  }

  export type GraficoCursoUpdateWithoutDashboardInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoCursoUncheckedUpdateWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoCursoUncheckedUpdateManyWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioUpdateWithoutDashboardInput = {
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioUncheckedUpdateWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type GraficoBeneficiarioUncheckedUpdateManyWithoutDashboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
  }

  export type TipoAtendimentoCreateManyProgramaInput = {
    id?: string
    nome: string
    sigla: string
    descricao?: string | null
    publico?: string | null
    duracao?: number | null
    frequencia?: string | null
    visibilidade: $Enums.Visibilidade
    instrucoesAluno?: string | null
    orientacoesPublicas?: string | null
    status: string
  }

  export type EscalaCreateManyProgramaInput = {
    id?: string
    nome: string
    matricula: string
    curso: string
    status: string
    turnos?: EscalaCreateturnosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoAtendimentoUpdateWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoUncheckedUpdateWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TipoAtendimentoUncheckedUpdateManyWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    publico?: NullableStringFieldUpdateOperationsInput | string | null
    duracao?: NullableIntFieldUpdateOperationsInput | number | null
    frequencia?: NullableStringFieldUpdateOperationsInput | string | null
    visibilidade?: EnumVisibilidadeFieldUpdateOperationsInput | $Enums.Visibilidade
    instrucoesAluno?: NullableStringFieldUpdateOperationsInput | string | null
    orientacoesPublicas?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EscalaUpdateWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscalaUncheckedUpdateWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EscalaUncheckedUpdateManyWithoutProgramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    matricula?: StringFieldUpdateOperationsInput | string
    curso?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    turnos?: EscalaUpdateturnosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}